<html lang="en"><head><style>
/* Markdown Shell */
.containerBlog {
   padding: 200px;
   background-color: black;
   color: white;
   font-size: 20px;
   font-family: Georgia, serif;
}

.containerBlog ol {
   list-style-type: decimal;
   padding-left: 2.5rem;
}
.containerBlog ul {
   list-style-type: disc;
   padding-left: 2.5rem;
}

.containerBlog td {
   padding: 3px;
   border-color: #888;
}

.containerBlog li {
   padding: 5px 10px;
}

.containerBlog p {
   padding: 10px 0px;
}

.containerBlog a {
   color: #00B9DA;
   text-decoration: none;
}

.containerBlog p code {
  background-color: #D3D3D3;
  padding: 0px 3px;
  border-radius: 0.5rem;
}

.containerBlog h1 {
  padding: 25px 0px;
  font-weight: bold;
  font-size: 2em;
  color: #fff4f4;
  text-decoration: underline;
}
.containerBlog h2 {
  padding: 25px 0px;
  font-weight: bold;
  font-size: 1.5em;
  color: #fff4f4;
  text-decoration: underline;
}
.containerBlog h3 {
  padding: 25px 0px;
  font-weight: bold;
  font-size:1.17em;
  color: #fff4f4;
  text-decoration: underline;
}
.containerBlog h4 {
  padding: 25px 0px;
  font-weight: bold;
  font-size: 1em;
  color: #fff4f4;
  text-decoration: underline;
}
.containerBlog h5 {
  padding: 25px 0px;
  font-weight: bold;
  font-size: 0.83em;
  color: #fff4f4;
  text-decoration: underline;
}



/* Otherwise comments can go on into infinity */
span.co {
  word-break: break-word;        /* Safe wrap on words */
  overflow-wrap: anywhere;       /* Force wrap anywhere if needed */
  white-space: normal;           /* Allow wrapping */
}


code:not([class]) {
  /* your styles here */
  background-color: white;
  padding: 4px;
  border-radius: 5px;
}

code span {
  display: inline;
  white-space: pre;
}

.source-code {
  padding: 8px;
  border-color: white;
  background-color: black;
}

}
/* One off haskell constructs */
code {
  color: #154dcb;
  font-weight: bold;
}

div.source-code {
  overflow-x:auto;
  max-width:100%;
}

code.language-haskell {
  overflow-x:auto;
  max-width:100%;
}

/* Haskell Syntax */
.pr {
   color: #F8E473;
}
.op {
   color: gold;
}
.sy {
   color: #FADA5E;
}
.co {
   color: green;
}
.cr {
   color: #af64ff;
}
.va {
   color: #6693F5; 
}
.kw {
    color: #f0883e;
}

/* Haskell Syntax - Literals */
.st {
  color: #a5d6ff;
}
.ch {
  color: #2E3A59;
}
.it {}
.ra {}


/* Other Languages Via Skylighting Tokenizer */

.pp {
  color: blue;
}
.im {
  color: green;
}
.dt {
  color: green;
}
.cf {
  color: orange;
}
/*Like char */
.sc {
  color: orange;
}
/* java func */
.fu {
  color: #6693F5;
}

/* base color C lang */
.language-c {
  color: #6693F5;
}

.language-bash {
  color: #154dcb;
  font-weight: bold;
}

.language-nix {
  color: grey;
  font-weight: bold;
}

.language-java {
  color: #6693F5;
}
.language-csharp {
  color: #E3B778;
}
.language-python {
  color: #E3B778;
}
</style><style>a { color: #00B9DA; text-decoration: none; }</style></head><body><div class="fixed top-0 left-0 w-full h-full overflow-auto z-10 scroll-smooth"><div class="containerBlog"><h1 id="chapter-2-immutability-changes-everything">Chapter 2: Immutability Changes Everything</h1>
<ol>
<li>
<a href="/landing/Blog/Chapter2#1-introduction-currying-pure-evaluation-and-the-power-of-immutability">Introduction</a>
</li>
<li>
<a href="/landing/Blog/Chapter2#2-why-immutability-changes-everything">Why Immutability Changes Everything</a>
</li>
<li>
<a href="/landing/Blog/Chapter2#3-examples-of-immutability-in-haskell">Examples of Immutability in Haskell</a>
</li>
<li>
<a href="/landing/Blog/Chapter2#4-pure-functions-and-state-changes">Pure Functions and State Changes</a>
</li>
<li>
<a href="/landing/Blog/Chapter2#5-handling-state-with-monads">Handling State with Monads</a>
</li>
<li>
<a href="/landing/Blog/Chapter2#6-pure-functions-and-referential-transparency">Pure Functions and Referential Transparency</a>
</li>
<li>
<a href="/landing/Blog/Chapter2#7-immutable-data-structures">Immutable Data Structures</a>
</li>
<li>
<a href="/landing/Blog/Chapter2#8-concurrency-and-immutability">Concurrency and Immutability</a>
</li>
<li>
<a href="/landing/Blog/Chapter2#recap">Recap &amp; Exercises</a>
</li>
</ol>
<h2 id="1-introduction-currying-pure-evaluation-and-the-power-of-immutability">1. Introduction: Currying, Pure Evaluation, and the Power of Immutability</h2>
<p>Immutability is at the core of functional programming, and it fundamentally changes the way we think about writing code and how programs execute. In Haskell, this isn’t just a recommendation—it’s enforced. All data in Haskell is immutable by default, meaning once a value is assigned, it cannot be changed.</p>
<p>In contrast, object-oriented programming (OOP) tends to favor <strong>mutable state</strong> — where data can be modified directly. This seems convenient at first but introduces many hidden dangers. Mutable state can cause unpredictable behavior and bugs because data can change in ways you don’t expect.</p>
<h3 id="currying-and-pure-evaluation">Currying and Pure Evaluation</h3>
<p>One of the cornerstones of immutability in Haskell is the concept of <strong>currying</strong>. Every function in Haskell is curried, meaning it can be partially applied. You give it some arguments, and it returns a new function that takes the remaining arguments. This naturally leads to <strong>pure evaluation</strong>, where each step of a function is evaluated in isolation, without changing any state. This makes it easy to reason about your code since you know exactly what each part of the program does.</p>
<p><strong>Example:</strong></p>
<div class="source-code"><pre><code class="language-haskell"><span class="va">add</span><span> </span><span class="sy">::</span><span> </span><span class="cr">Int</span><span> </span><span class="sy">-&gt;</span><span> </span><span class="cr">Int</span><span> </span><span class="sy">-&gt;</span><span> </span><span class="cr">Int</span><span>
</span><span class="va">add</span><span> </span><span class="va">x</span><span> </span><span class="va">y</span><span> </span><span class="sy">=</span><span> </span><span class="va">x</span><span> </span><span class="op">+</span><span> </span><span class="va">y</span><span>

</span><span class="co">-- Partial application of the curried function</span><span>
</span><span class="va">increment</span><span> </span><span class="sy">=</span><span> </span><span class="va">add</span><span> </span><span class="it">1</span><span>
</span><span class="va">result</span><span> </span><span class="sy">=</span><span> </span><span class="va">increment</span><span> </span><span class="it">5</span><span>  </span><span class="co">-- Result is 6</span><span>
</span></code></pre></div>
<p>Currying promotes immutability because the partially applied function is itself an immutable value. Once a function is curried, you can reuse it with different inputs without changing its behavior.</p>
<h3 id="metaphor-of-state-immutability-the-bucket-example">Metaphor of State Immutability: The Bucket Example</h3>
<p>Think of a bucket that represents the state of your program. In a world of mutable state, you can throw things into the bucket, mix them up, and hand the bucket to someone else. But the problem is, the person you hand the bucket to doesn’t know what rules you’ve been following for mixing things. They have no idea what the original contents were or how you manipulated them.</p>
<p>On the other hand, in a world of immutable state, the bucket is passed around for people to observe, but no one is allowed to change its contents. Every time you need to modify the bucket’s contents, you create a new bucket that reflects the new state, while the original bucket stays the same. This way, everyone knows what’s in the bucket at every point in time, and there’s no ambiguity.</p>
<p>This metaphor captures the essence of immutability: you don’t change the state, you create a new state. This makes the flow of information in your program predictable, safer, and easier to reason about.</p>
<h2 id="2-why-immutability-changes-everything">2. Why Immutability Changes Everything</h2>
<p>Immutability might seem like a restriction at first, but ironically, it frees us from many of the problems that plague mutable systems. Here’s why immutability is such a game-changer:</p>
<ol>
<li>
No Hidden State: In mutable systems, state can change at any time, anywhere in the program, which makes it hard to reason about the behavior of your code. With immutability, the state of the program is always explicit. You always know what data is being worked with at any given time.
</li>
<li>
Easier Testing: Testing programs with mutable state often requires complex setups like mocks, dependency injection, and detailed tracking of side effects. In functional programming, where data is immutable and functions are pure, testing becomes much easier. You pass data into a function, observe the output, and know that the function doesn’t affect anything outside itself.
</li>
<li>
Concurrency and Parallelism: In a world with mutable state, concurrent programs often run into issues like race conditions or deadlocks, where two parts of the program are competing to change the same data at the same time. Immutability solves this problem by ensuring that no part of your program can ever change shared state, which means you can safely run operations in parallel without worrying about conflicting changes.
</li>
<li>
Predictable Code: In an immutable system, once a value is created, it can never change. This predictability eliminates many classes of bugs that are common in object-oriented systems, where data can change unexpectedly.
</li>
</ol>
<h3 id="objectoriented-languages-vs-functional-programming">Object-Oriented Languages vs Functional Programming</h3>
<p>In object-oriented languages, mutability is often the default behavior. Consider this Python example:</p>
<div class="source-code"><pre><code class="language-python"><span>x </span><span class="op">=</span><span> </span><span class="dv">5</span>
<span>x </span><span class="op">+=</span><span> </span><span class="dv">5</span><span>  </span><span class="co"># Mutates the variable &#39;x&#39;, changing its value to 10</span>
</code></pre></div>
<p>Here, the variable x is being mutated, which is a simple example, but when used in larger systems, this leads to a tangled web of state changes. In complex applications, you need to introduce mechanisms like:</p>
<ul>
<li>
Mocks: Fake versions of objects used in tests because mutable dependencies are difficult to isolate.
</li>
<li>
Dependency Injection: A way to inject dependencies at runtime to manage mutable state effectively.
</li>
<li>
Extensive Unit Tests: Since any function could change state, you need extensive testing to ensure all potential side effects are covered.
</li>
</ul>
<p>In contrast, functional programming avoids these issues altogether. Since data is immutable and functions are pure, you don’t need mocks or dependency injection to isolate behavior. You can test each function in isolation without worrying about hidden state or side effects.</p>
<h2 id="3-examples-of-immutability-in-haskell">3. Examples of Immutability in Haskell</h2>
<p>Let’s look at how Haskell handles immutability and avoids the problems of mutable state.</p>
<h3 id="immutable-data-structures">Immutable Data Structures</h3>
<p>In Haskell, once you assign a value to a variable, it can never change. This ensures that your data is always consistent, and you don’t have to worry about it being changed unexpectedly.</p>
<div class="source-code"><pre><code class="language-haskell"><span class="co">-- Example of immutable variables</span><span>
</span><span class="va">x</span><span> </span><span class="sy">::</span><span> </span><span class="cr">Int</span><span>
</span><span class="va">x</span><span> </span><span class="sy">=</span><span> </span><span class="it">5</span><span>

</span><span class="co">-- Attempting to change &#39;x&#39; will result in a compile-time error</span><span>
</span><span class="co">-- x = x + 5 -- This is illegal in Haskell</span><span>
</span></code></pre></div>
<p>In this code, x is assigned the value 5, and you cannot change x later. If you need a new value, you would create a new variable:</p>
<div class="source-code"><pre><code class="language-haskell"><span class="va">y</span><span> </span><span class="sy">::</span><span> </span><span class="cr">Int</span><span>
</span><span class="va">y</span><span> </span><span class="sy">=</span><span> </span><span class="va">x</span><span> </span><span class="op">+</span><span> </span><span class="it">5</span><span>
</span></code></pre></div>
<p>Now, y contains the new value, but x remains untouched.</p>
<h2 id="4-pure-functions-and-state-changes">4. Pure Functions and State Changes</h2>
<p>In Haskell, state changes are handled using pure functions, which means that a function’s output depends only on its input, and it doesn’t affect any external state. If you want to represent a change in state, you return a new version of the state, leaving the old state intact.</p>
<div class="source-code"><pre><code class="language-haskell"><span class="co">-- Pure function example</span><span>
</span><span class="va">addFive</span><span> </span><span class="sy">::</span><span> </span><span class="cr">Int</span><span> </span><span class="sy">-&gt;</span><span> </span><span class="cr">Int</span><span>
</span><span class="va">addFive</span><span> </span><span class="va">x</span><span> </span><span class="sy">=</span><span> </span><span class="va">x</span><span> </span><span class="op">+</span><span> </span><span class="it">5</span><span>

</span><span class="co">-- The input &#39;x&#39; is unchanged; a new value is returned</span><span>
</span><span class="va">result</span><span> </span><span class="sy">=</span><span> </span><span class="va">addFive</span><span> </span><span class="it">10</span><span>  </span><span class="co">-- result is 15</span><span>
</span></code></pre></div>
<p>This pure function guarantees that the input x remains unchanged and a new value is returned.</p>
<h2 id="5-handling-state-with-monads">5. Handling State with Monads</h2>
<p>Haskell uses monads (such as the State monad) to manage state in a controlled and predictable way. Monads allow you to work with state changes while preserving immutability, ensuring that every state transition is explicit.</p>
<div class="source-code"><pre><code class="language-haskell"><span class="kw">import</span><span> </span><span class="cr">Control.Monad.State</span><span>

</span><span class="co">-- Define a stateful computation</span><span>
</span><span class="va">incrementState</span><span> </span><span class="sy">::</span><span> </span><span class="cr">State</span><span> </span><span class="cr">Int</span><span> </span><span class="cr">Int</span><span>
</span><span class="va">incrementState</span><span> </span><span class="sy">=</span><span> </span><span class="kw">do</span><span>
    </span><span class="va">n</span><span> </span><span class="sy">&lt;-</span><span> </span><span class="va">get</span><span>
    </span><span class="va">put</span><span> </span><span class="sy">(</span><span class="va">n</span><span> </span><span class="op">+</span><span> </span><span class="it">1</span><span class="sy">)</span><span>
    </span><span class="va">return</span><span> </span><span class="va">n</span><span>

</span><span class="co">-- Running the stateful computation</span><span>
</span><span class="va">main</span><span> </span><span class="sy">=</span><span> </span><span class="va">print</span><span> </span><span class="op">$</span><span> </span><span class="va">runState</span><span> </span><span class="va">incrementState</span><span> </span><span class="it">10</span><span>
</span></code></pre></div>
<p>In this example:</p>
<ul>
<li>
incrementState is a computation that works with state (an Int) and returns a new state.
</li>
<li>
The state is threaded through the computation, but at no point is the original state mutated in place.
</li>
</ul>
<blockquote>
<p>Note: We will dive into Monads in chapter 6. For now, just understand that they allow us to model some context around the value we care about.</p>
</blockquote>
<blockquote>
<p>Note: We will dive into State management in chapter 8. For now, just understand that state management is done in a pure and deterministic manner.</p>
</blockquote>
<h2 id="6-pure-functions-and-referential-transparency">6. Pure Functions and Referential Transparency</h2>
<h3 id="pure-functions-the-core-of-immutability">Pure Functions: The Core of Immutability</h3>
<p>A <strong>pure function</strong> is a function that:</p>
<ol>
<li>
<strong>Always produces the same output</strong> given the same input.
</li>
<li>
<strong>Has no side effects</strong>, meaning it doesn&#39;t change any state or interact with the outside world (no printing, modifying global variables, etc.).
</li>
</ol>
<p>In a system that embraces immutability, pure functions are everywhere. They take inputs and produce outputs without altering anything in between. This creates code that is easy to reason about, predictable, and free from the hidden side effects that plague mutable systems.</p>
<p><strong>Example:</strong></p>
<div class="source-code"><pre><code class="language-haskell"><span class="co">-- Pure function: No side effects, output depends only on the input</span><span>
</span><span class="va">multiplyByTwo</span><span> </span><span class="sy">::</span><span> </span><span class="cr">Int</span><span> </span><span class="sy">-&gt;</span><span> </span><span class="cr">Int</span><span>
</span><span class="va">multiplyByTwo</span><span> </span><span class="va">x</span><span> </span><span class="sy">=</span><span> </span><span class="va">x</span><span> </span><span class="sy">*</span><span> </span><span class="it">2</span><span>

</span><span class="va">result</span><span> </span><span class="sy">=</span><span> </span><span class="va">multiplyByTwo</span><span> </span><span class="it">10</span><span>  </span><span class="co">-- result is 20</span><span>
</span></code></pre></div>
<p>Here, multiplyByTwo is a pure function. It doesn’t rely on or modify any external state. It simply takes an integer, multiplies it by two, and returns the result. Every time you call multiplyByTwo 10, the result will always be 20. There’s no hidden state that could change the outcome.</p>
<p>Contrast this with an impure function from an object-oriented perspective:</p>
<div class="source-code"><pre><code class="language-csharp"><span class="dt">int</span><span> counter = </span><span class="dv">0</span><span>;</span>

<span class="kw">public</span><span> </span><span class="dt">int</span><span> </span><span class="fu">incrementCounter</span><span>() {</span>
<span>    </span><span class="kw">return</span><span> ++counter;</span>
<span>}</span>
</code></pre></div>
<p>This incrementCounter function in Java is impure because it relies on the external mutable state (counter). Each time you call it, the result will change based on the current value of counter. This makes it much harder to predict how the program behaves at any given time, especially as the system grows in complexity.</p>
<h3 id="referential-transparency">Referential Transparency</h3>
<p>One of the properties that follows directly from pure functions and immutability is referential transparency. A function or expression is referentially transparent if it can be replaced by its value without changing the behavior of the program.</p>
<p><strong>Example of Referential Transparency:</strong></p>
<div class="source-code"><pre><code class="language-haskell"><span class="co">-- Pure function</span><span>
</span><span class="va">square</span><span> </span><span class="sy">::</span><span> </span><span class="cr">Int</span><span> </span><span class="sy">-&gt;</span><span> </span><span class="cr">Int</span><span>
</span><span class="va">square</span><span> </span><span class="va">x</span><span> </span><span class="sy">=</span><span> </span><span class="va">x</span><span> </span><span class="sy">*</span><span> </span><span class="va">x</span><span>

</span><span class="co">-- The following expressions are referentially transparent</span><span>
</span><span class="va">result1</span><span> </span><span class="sy">=</span><span> </span><span class="va">square</span><span> </span><span class="it">4</span><span>  </span><span class="co">-- This expression can be replaced with its result: 16</span><span>
</span><span class="va">result2</span><span> </span><span class="sy">=</span><span> </span><span class="it">16</span><span>  </span><span class="co">-- Both are equivalent</span><span>
</span></code></pre></div>
<p>In a language that guarantees immutability like Haskell, referential transparency is always maintained. This is not true in mutable languages, where state can change unexpectedly, and replacing an expression with its value could yield different results based on the current state.</p>
<h3 id="why-does-referential-transparency-matter">Why Does Referential Transparency Matter?</h3>
<ul>
<li>
Simplifies reasoning: You don’t need to track how the value of a variable might have changed elsewhere in the code. Each expression is self-contained and independent.
</li>
<li>
Improves testability: You can test functions in isolation, knowing that they will always behave the same way given the same input.
</li>
</ul>
<h2 id="7-immutable-data-structures">7. Immutable Data Structures</h2>
<p>In Haskell, all data structures are immutable by default. This means that once you create a data structure, it cannot be changed. If you want to “modify” it, you actually create a new data structure based on the old one.</p>
<h3 id="lists-in-haskell-an-immutable-data-structure">Lists in Haskell: An Immutable Data Structure</h3>
<p>One of the most fundamental data structures in Haskell is the list, which is immutable. If you want to add or remove elements from a list, you don’t modify the list in place. Instead, you create a new list.</p>
<p>Example:</p>
<div class="source-code"><pre><code class="language-haskell"><span class="co">-- Define a list</span><span>
</span><span class="va">myList</span><span> </span><span class="sy">::</span><span> </span><span class="sy">[</span><span class="cr">Int</span><span class="sy">]</span><span>
</span><span class="va">myList</span><span> </span><span class="sy">=</span><span> </span><span class="sy">[</span><span class="it">1</span><span class="sy">,</span><span> </span><span class="it">2</span><span class="sy">,</span><span> </span><span class="it">3</span><span class="sy">]</span><span>

</span><span class="co">-- Add an element to the front of the list (creates a new list)</span><span>
</span><span class="va">newList</span><span> </span><span class="sy">=</span><span> </span><span class="it">0</span><span> </span><span class="sy">:</span><span> </span><span class="va">myList</span><span>  </span><span class="co">-- newList is [0, 1, 2, 3]</span><span>
</span></code></pre></div>
<p>In this example, the : operator creates a new list by prepending the element 0 to the front of the existing list myList. The original list <code>[1, 2, 3]</code> remains unchanged.</p>
<h3 id="immutable-data-with-records">Immutable Data with Records</h3>
<p>Haskell also supports more complex data structures like records, which allow you to define immutable types with named fields.</p>
<p>Example:</p>
<div class="source-code"><pre><code class="language-haskell"><span class="co">-- Define a record for a User</span><span>
</span><span class="kw">data</span><span> </span><span class="cr">User</span><span> </span><span class="sy">=</span><span> </span><span class="cr">User</span><span> </span><span class="sy">{</span><span> </span><span class="va">userId</span><span> </span><span class="sy">::</span><span> </span><span class="cr">Int</span><span class="sy">,</span><span> </span><span class="va">userName</span><span> </span><span class="sy">::</span><span> </span><span class="cr">String</span><span> </span><span class="sy">}</span><span>

</span><span class="co">-- Create a User</span><span>
</span><span class="va">user</span><span> </span><span class="sy">::</span><span> </span><span class="cr">User</span><span>
</span><span class="va">user</span><span> </span><span class="sy">=</span><span> </span><span class="cr">User</span><span> </span><span class="sy">{</span><span> </span><span class="va">userId</span><span> </span><span class="sy">=</span><span> </span><span class="it">1</span><span class="sy">,</span><span> </span><span class="va">userName</span><span> </span><span class="sy">=</span><span> </span><span class="st">&quot;Alice&quot;</span><span> </span><span class="sy">}</span><span>

</span><span class="co">-- Create a new User with a different name</span><span>
</span><span class="va">updatedUser</span><span> </span><span class="sy">=</span><span> </span><span class="va">user</span><span> </span><span class="sy">{</span><span> </span><span class="va">userName</span><span> </span><span class="sy">=</span><span> </span><span class="st">&quot;Bob&quot;</span><span> </span><span class="sy">}</span><span>
</span></code></pre></div>
<p>In this example:</p>
<ul>
<li>
user is an immutable data structure representing a user.
</li>
<li>
If you need to “update” the user’s name, you don’t modify the original user. Instead, you create a new updatedUser with the modified userName, while user remains unchanged.
</li>
</ul>
<h3 id="efficiency-of-immutable-data-structures">Efficiency of Immutable Data Structures</h3>
<p>At first glance, immutability might seem inefficient—if you’re creating new data structures all the time, won’t that slow things down? In reality, Haskell uses techniques like persistent data structures and lazy evaluation to optimize performance.</p>
<ul>
<li>
Persistent Data Structures: Instead of copying the entire data structure every time, Haskell reuses parts of the old structure when possible. For example, if you add an element to the front of a list, Haskell doesn’t copy the entire list—it simply adds the new element and points to the existing list.
</li>
<li>
Lazy Evaluation: Haskell only evaluates expressions when absolutely necessary. This means that data isn’t copied or created until it’s needed, reducing unnecessary computations and memory usage.
</li>
</ul>
<h2 id="8-concurrency-and-immutability">8. Concurrency and Immutability</h2>
<p>Immutability has a profound effect on concurrency. In a mutable system, concurrency can lead to serious problems like race conditions and deadlocks when multiple threads try to access and modify the same state at the same time. This makes concurrent programming difficult and error-prone.</p>
<p>With immutability, these problems simply disappear. Since state cannot change, you don’t have to worry about threads interfering with each other. You can safely share data between threads without needing locks or other synchronization mechanisms.</p>
<h3 id="example-sharing-data-between-threads">Example: Sharing Data Between Threads</h3>
<p>In Haskell, you can safely share immutable data across multiple threads without worrying about one thread changing the state and causing unexpected behavior in another thread.</p>
<p><strong>Example using multiple threads:</strong></p>
<div class="source-code"><pre><code class="language-haskell"><span class="kw">import</span><span> </span><span class="cr">Control.Concurrent</span><span>

</span><span class="co">-- Define an immutable value</span><span>
</span><span class="va">sharedValue</span><span> </span><span class="sy">::</span><span> </span><span class="cr">Int</span><span>
</span><span class="va">sharedValue</span><span> </span><span class="sy">=</span><span> </span><span class="it">100</span><span>

</span><span class="co">-- Define a function to simulate work on a thread</span><span>
</span><span class="va">printSharedValue</span><span> </span><span class="sy">::</span><span> </span><span class="cr">IO</span><span> </span><span class="sy">(</span><span class="sy">)</span><span>
</span><span class="va">printSharedValue</span><span> </span><span class="sy">=</span><span> </span><span class="kw">do</span><span>
    </span><span class="va">putStrLn</span><span> </span><span class="op">$</span><span> </span><span class="st">&quot;Shared value is: &quot;</span><span> </span><span class="op">++</span><span> </span><span class="va">show</span><span> </span><span class="va">sharedValue</span><span>

</span><span class="va">main</span><span> </span><span class="sy">=</span><span> </span><span class="kw">do</span><span>
    </span><span class="co">-- Create two threads that both access the immutable shared value</span><span>
    </span><span class="sy">_</span><span> </span><span class="sy">&lt;-</span><span> </span><span class="va">forkIO</span><span> </span><span class="va">printSharedValue</span><span>
    </span><span class="sy">_</span><span> </span><span class="sy">&lt;-</span><span> </span><span class="va">forkIO</span><span> </span><span class="va">printSharedValue</span><span>
    </span><span class="co">-- Wait for threads to finish</span><span>
    </span><span class="va">threadDelay</span><span> </span><span class="it">1000000</span><span>
</span></code></pre></div>
<p>In this example, two threads both access the immutable value sharedValue. Since the value is immutable, we can be sure that no matter how many threads access it, the value will remain unchanged and there will be no race conditions or synchronization issues.</p>
<h2 id="conclusion-immutability-is-a-superpower">Conclusion: Immutability is a Superpower</h2>
<p>Immutability fundamentally changes the way we write programs by removing the complexities and risks associated with mutable state. By enforcing immutability, Haskell guarantees that:</p>
<ul>
<li>
Your functions are pure and predictable.
</li>
<li>
Your data is safe from unexpected changes.
</li>
<li>
Your programs are inherently concurrent-safe, without the need for complex synchronization mechanisms.
</li>
</ul>
<h2 id="9-recap-exercises">9. Recap &amp; Exercises</h2>
<h3 id="recap">Recap</h3>
<p>Immutability fundamentally changes the way we write programs by removing the complexities and risks associated with mutable state. By enforcing immutability, Haskell guarantees that:</p>
<ul>
<li>
Your functions are pure and predictable.
</li>
<li>
Your data is safe from unexpected changes.
</li>
<li>
Your programs are inherently concurrent-safe, without the need for complex synchronization mechanisms.
</li>
</ul>
<p>In this chapter, we’ve explored the concept of <strong>immutability</strong> in functional programming and its significant impact on how we write and reason about code. Lets recap the main points:</p>
<ul>
<li>
<strong>Currying and Pure Evaluation</strong>:
<ul>
<li>
In Haskell, all functions are curried by default, meaning they can be partially applied. Immutability ensures that partially applied functions behave predictably.
</li>
<li>
Pure functions, which always return the same output for the same input and have no side effects, are central to immutability. They create predictable and easily testable code.
</li>
</ul>
</li>
<li>
<strong>The Illusion of Mutability</strong>:
<ul>
<li>
In the real world, mutability doesn’t truly exist. Concepts like <code>x += 5</code> don’t make sense when modeling real-world behavior, as things change by creating new states, not modifying old ones.
</li>
<li>
The metaphor of the <strong>bucket</strong> illustrates how mutable state is confusing (anyone can throw things into the bucket), while immutable state keeps things clear and predictable (each person gets their own copy of the bucket).
</li>
</ul>
</li>
<li>
<strong>Referential Transparency</strong>:
<ul>
<li>
Pure functions are referentially transparent, meaning any expression can be replaced by its value without changing the program’s behavior. This makes reasoning about and optimizing code easier.
</li>
</ul>
</li>
<li>
<strong>Immutable Data Structures</strong>:
<ul>
<li>
Haskell’s lists, tuples, and records are all immutable. Once created, they cannot be changed. Instead of mutating data, we create new versions of the data.
</li>
<li>
While immutability might seem inefficient, Haskell optimizes performance with <strong>persistent data structures</strong> and <strong>lazy evaluation</strong>, ensuring that only necessary computations and memory allocations are performed.
</li>
</ul>
</li>
<li>
<strong>Concurrency and Immutability</strong>:
<ul>
<li>
Immutability simplifies concurrency by removing the possibility of race conditions, deadlocks, or corrupted state. Immutable data can be safely shared across threads without any risk of interference.
</li>
</ul>
</li>
</ul>
<p>By embracing immutability, Haskell makes it easier to write code that is predictable, scalable, and free from many of the pitfalls associated with mutable state. This drastically reduces bugs and complexity in concurrent and parallel systems.</p>
<h3 id="exercises">Exercises</h3>
<p>The following exercises will help you practice using immutability in Haskell and reinforce the concepts discussed in this chapter.</p>
<h4 id="exercise-1-implementing-pure-functions">Exercise 1: Implementing Pure Functions</h4>
<p><strong>Objective</strong>: Write a few pure functions that take inputs and return outputs without modifying any external state.</p>
<ol>
<li>
<p>Write a pure function <code>square</code> that takes an integer and returns its square.</p>
<div class="source-code"><pre><code class="language-haskell"><span class="va">square</span><span> </span><span class="sy">::</span><span> </span><span class="cr">Int</span><span> </span><span class="sy">-&gt;</span><span> </span><span class="cr">Int</span><span>
</span><span class="co">-- Your implementation here</span><span>
</span></code></pre></div>
</li>
<li>
<p>Write a pure function <code>calculateDiscount</code> that takes a price and a discount percentage and returns the price after applying the discount. The discount should be a <code>Float</code>.</p>
<div class="source-code"><pre><code class="language-haskell"><span class="va">calculateDiscount</span><span> </span><span class="sy">::</span><span> </span><span class="cr">Float</span><span> </span><span class="sy">-&gt;</span><span> </span><span class="cr">Float</span><span> </span><span class="sy">-&gt;</span><span> </span><span class="cr">Float</span><span>
</span><span class="co">-- Your implementation here</span><span>
</span></code></pre></div>
</li>
<li>
<p>Write a pure function <code>doubleList</code> that takes a list of integers and returns a new list with all integers doubled.</p>
<div class="source-code"><pre><code class="language-haskell"><span class="va">doubleList</span><span> </span><span class="sy">::</span><span> </span><span class="sy">[</span><span class="cr">Int</span><span class="sy">]</span><span> </span><span class="sy">-&gt;</span><span> </span><span class="sy">[</span><span class="cr">Int</span><span class="sy">]</span><span>
</span><span class="co">-- Your implementation here</span><span>
</span></code></pre></div>
</li>
</ol>
<p><strong>Hint</strong>: Remember, these functions should not modify the input data. They should return new values based on the inputs.</p>
<hr>
<h4 id="exercise-2-working-with-immutable-data-structures">Exercise 2: Working with Immutable Data Structures</h4>
<p><strong>Objective</strong>: Practice working with immutable data structures in Haskell by creating lists and modifying them without mutating the original data.</p>
<ol>
<li>
<p>Define a list <code>numbers :: [Int]</code> that contains the integers 1 through 5.</p>
<div class="source-code"><pre><code class="language-haskell"><span class="va">numbers</span><span> </span><span class="sy">::</span><span> </span><span class="sy">[</span><span class="cr">Int</span><span class="sy">]</span><span>
</span><span class="co">-- Your implementation here</span><span>
</span></code></pre></div>
</li>
<li>
<p>Write a function <code>addElement</code> that takes an integer and a list of integers and returns a new list with the integer added to the front of the list.</p>
<div class="source-code"><pre><code class="language-haskell"><span class="va">addElement</span><span> </span><span class="sy">::</span><span> </span><span class="cr">Int</span><span> </span><span class="sy">-&gt;</span><span> </span><span class="sy">[</span><span class="cr">Int</span><span class="sy">]</span><span> </span><span class="sy">-&gt;</span><span> </span><span class="sy">[</span><span class="cr">Int</span><span class="sy">]</span><span>
</span><span class="co">-- Your implementation here</span><span>
</span></code></pre></div>
</li>
<li>
<p>Use the <code>addElement</code> function to add the number 6 to the <code>numbers</code> list, and then print both the original and the new list to verify that <code>numbers</code> has not been modified.</p>
<div class="source-code"><pre><code class="language-haskell"><span class="va">main</span><span> </span><span class="sy">::</span><span> </span><span class="cr">IO</span><span> </span><span class="sy">(</span><span class="sy">)</span><span>
</span><span class="va">main</span><span> </span><span class="sy">=</span><span> </span><span class="kw">do</span><span>
    </span><span class="kw">let</span><span> </span><span class="va">newNumbers</span><span> </span><span class="sy">=</span><span> </span><span class="va">addElement</span><span> </span><span class="it">6</span><span> </span><span class="va">numbers</span><span>
    </span><span class="va">print</span><span> </span><span class="va">numbers</span><span>       </span><span class="co">-- Should still be [1, 2, 3, 4, 5]</span><span>
    </span><span class="va">print</span><span> </span><span class="va">newNumbers</span><span>    </span><span class="co">-- Should be [6, 1, 2, 3, 4, 5]</span><span>
</span></code></pre></div>
</li>
</ol>
<p><strong>Hint</strong>: Use the <code>:</code> operator to add an element to the front of the list.</p>
<hr>
<h4 id="exercise-3-managing-state-with-immutability">Exercise 3: Managing State with Immutability</h4>
<p><strong>Objective</strong>: Practice managing state using immutable structures by implementing a simple counter.</p>
<ol>
<li>
<p>Write a function <code>incrementCounter</code> that takes an integer (the current counter value) and returns the new counter value after incrementing it by 1.</p>
<div class="source-code"><pre><code class="language-haskell"><span class="va">incrementCounter</span><span> </span><span class="sy">::</span><span> </span><span class="cr">Int</span><span> </span><span class="sy">-&gt;</span><span> </span><span class="cr">Int</span><span>
</span><span class="co">-- Your implementation here</span><span>
</span></code></pre></div>
</li>
<li>
<p>Write a function <code>updateCounter</code> that simulates a sequence of counter updates. It should take an initial counter value and a list of updates (e.g., <code>[+1, +1, -1]</code>), and return the final counter value.</p>
<div class="source-code"><pre><code class="language-haskell"><span class="va">updateCounter</span><span> </span><span class="sy">::</span><span> </span><span class="cr">Int</span><span> </span><span class="sy">-&gt;</span><span> </span><span class="sy">[</span><span class="cr">Int</span><span class="sy">]</span><span> </span><span class="sy">-&gt;</span><span> </span><span class="cr">Int</span><span>
</span><span class="co">-- Your implementation here</span><span>
</span></code></pre></div>
</li>
<li>
<p>Simulate counter updates and print the results. For example, starting with a counter of 5 and applying updates <code>[1, 1, -1]</code> should return 6.</p>
<div class="source-code"><pre><code class="language-haskell"><span class="va">main</span><span> </span><span class="sy">::</span><span> </span><span class="cr">IO</span><span> </span><span class="sy">(</span><span class="sy">)</span><span>
</span><span class="va">main</span><span> </span><span class="sy">=</span><span> </span><span class="kw">do</span><span>
    </span><span class="kw">let</span><span> </span><span class="va">result</span><span> </span><span class="sy">=</span><span> </span><span class="va">updateCounter</span><span> </span><span class="it">5</span><span> </span><span class="sy">[</span><span class="it">1</span><span class="sy">,</span><span> </span><span class="it">1</span><span class="sy">,</span><span> </span><span class="it">-1</span><span class="sy">]</span><span>
    </span><span class="va">print</span><span> </span><span class="va">result</span><span>  </span><span class="co">-- Should be 6</span><span>
</span></code></pre></div>
</li>
</ol>
<hr>
<h4 id="exercise-4-simulating-state-changes-with-pure-functions">Exercise 4: Simulating State Changes with Pure Functions</h4>
<p><strong>Objective</strong>: Write a pure function that simulates state changes over time without using any mutable state.</p>
<ol>
<li>
<p>Imagine a simple game where a character moves along a 2D grid. The state of the game is represented by the character’s coordinates (<code>(x, y)</code>).</p>
<p>Write a function <code>moveCharacter</code> that takes the current position <code>(x, y)</code> and a direction (e.g., <code>Left</code>, <code>Right</code>, <code>Up</code>, <code>Down</code>), and returns the new position.</p>
<div class="source-code"><pre><code class="language-haskell"><span class="kw">data</span><span> </span><span class="cr">Direction</span><span> </span><span class="sy">=</span><span> </span><span class="cr">Left</span><span> </span><span class="sy">|</span><span> </span><span class="cr">Right</span><span> </span><span class="sy">|</span><span> </span><span class="cr">Up</span><span> </span><span class="sy">|</span><span> </span><span class="cr">Down</span><span>

</span><span class="va">moveCharacter</span><span> </span><span class="sy">::</span><span> </span><span class="sy">(</span><span class="cr">Int</span><span class="sy">,</span><span> </span><span class="cr">Int</span><span class="sy">)</span><span> </span><span class="sy">-&gt;</span><span> </span><span class="cr">Direction</span><span> </span><span class="sy">-&gt;</span><span> </span><span class="sy">(</span><span class="cr">Int</span><span class="sy">,</span><span> </span><span class="cr">Int</span><span class="sy">)</span><span>
</span><span class="co">-- Your implementation here</span><span>
</span></code></pre></div>
</li>
<li>
<p>Simulate a sequence of moves using a list of directions and print the final position of the character. For example, starting at <code>(0, 0)</code> and moving <code>[Right, Up, Up, Left]</code> should return <code>(-1, 2)</code>.</p>
<div class="source-code"><pre><code class="language-haskell"><span class="va">main</span><span> </span><span class="sy">::</span><span> </span><span class="cr">IO</span><span> </span><span class="sy">(</span><span class="sy">)</span><span>
</span><span class="va">main</span><span> </span><span class="sy">=</span><span> </span><span class="kw">do</span><span>
    </span><span class="kw">let</span><span> </span><span class="va">finalPosition</span><span> </span><span class="sy">=</span><span> </span><span class="va">foldl</span><span> </span><span class="va">moveCharacter</span><span> </span><span class="sy">(</span><span class="it">0</span><span class="sy">,</span><span> </span><span class="it">0</span><span class="sy">)</span><span> </span><span class="sy">[</span><span class="cr">Right</span><span class="sy">,</span><span> </span><span class="cr">Up</span><span class="sy">,</span><span> </span><span class="cr">Up</span><span class="sy">,</span><span> </span><span class="cr">Left</span><span class="sy">]</span><span>
    </span><span class="va">print</span><span> </span><span class="va">finalPosition</span><span>  </span><span class="co">-- Should print (-1, 2)</span><span>
</span></code></pre></div>
</li>
</ol>
<p><strong>Hint</strong>: The <code>foldl</code> function can be used to apply <code>moveCharacter</code> to each direction in the list, updating the position step by step.</p>
<p><a href="/landing/Blog/Chapter1">Previous Chapter</a> |
<a href="/landing/Blog/Chapter3">Next Chapter</a></p>
</div></div></body></html>