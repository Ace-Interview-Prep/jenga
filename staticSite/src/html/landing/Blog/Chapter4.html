<html lang="en"><head><style>
/* Markdown Shell */
.containerBlog {
   padding: 200px;
   background-color: black;
   color: white;
   font-size: 20px;
   font-family: Georgia, serif;
}

.containerBlog ol {
   list-style-type: decimal;
   padding-left: 2.5rem;
}
.containerBlog ul {
   list-style-type: disc;
   padding-left: 2.5rem;
}

.containerBlog td {
   padding: 3px;
   border-color: #888;
}

.containerBlog li {
   padding: 5px 10px;
}

.containerBlog p {
   padding: 10px 0px;
}

.containerBlog a {
   color: #00B9DA;
   text-decoration: none;
}

.containerBlog p code {
  background-color: #D3D3D3;
  padding: 0px 3px;
  border-radius: 0.5rem;
}

.containerBlog h1 {
  padding: 25px 0px;
  font-weight: bold;
  font-size: 2em;
  color: #fff4f4;
  text-decoration: underline;
}
.containerBlog h2 {
  padding: 25px 0px;
  font-weight: bold;
  font-size: 1.5em;
  color: #fff4f4;
  text-decoration: underline;
}
.containerBlog h3 {
  padding: 25px 0px;
  font-weight: bold;
  font-size:1.17em;
  color: #fff4f4;
  text-decoration: underline;
}
.containerBlog h4 {
  padding: 25px 0px;
  font-weight: bold;
  font-size: 1em;
  color: #fff4f4;
  text-decoration: underline;
}
.containerBlog h5 {
  padding: 25px 0px;
  font-weight: bold;
  font-size: 0.83em;
  color: #fff4f4;
  text-decoration: underline;
}



/* Otherwise comments can go on into infinity */
span.co {
  word-break: break-word;        /* Safe wrap on words */
  overflow-wrap: anywhere;       /* Force wrap anywhere if needed */
  white-space: normal;           /* Allow wrapping */
}


code:not([class]) {
  /* your styles here */
  background-color: white;
  padding: 4px;
  border-radius: 5px;
}

code span {
  display: inline;
  white-space: pre;
}

.source-code {
  padding: 8px;
  border-color: white;
  background-color: black;
}

}
/* One off haskell constructs */
code {
  color: #154dcb;
  font-weight: bold;
}

div.source-code {
  overflow-x:auto;
  max-width:100%;
}

code.language-haskell {
  overflow-x:auto;
  max-width:100%;
}

/* Haskell Syntax */
.pr {
   color: #F8E473;
}
.op {
   color: gold;
}
.sy {
   color: #FADA5E;
}
.co {
   color: green;
}
.cr {
   color: #af64ff;
}
.va {
   color: #6693F5; 
}
.kw {
    color: #f0883e;
}

/* Haskell Syntax - Literals */
.st {
  color: #a5d6ff;
}
.ch {
  color: #2E3A59;
}
.it {}
.ra {}


/* Other Languages Via Skylighting Tokenizer */

.pp {
  color: blue;
}
.im {
  color: green;
}
.dt {
  color: green;
}
.cf {
  color: orange;
}
/*Like char */
.sc {
  color: orange;
}
/* java func */
.fu {
  color: #6693F5;
}

/* base color C lang */
.language-c {
  color: #6693F5;
}

.language-bash {
  color: #154dcb;
  font-weight: bold;
}

.language-nix {
  color: grey;
  font-weight: bold;
}

.language-java {
  color: #6693F5;
}
.language-csharp {
  color: #E3B778;
}
.language-python {
  color: #E3B778;
}
</style><style>a { color: #00B9DA; text-decoration: none; }</style></head><body><div class="fixed top-0 left-0 w-full h-full overflow-auto z-10 scroll-smooth"><div class="containerBlog"><h1 id="lesson-4-working-with-lists-and-sets">Lesson 4 - Working with Lists and Sets</h1>
<ol>
<li>
<a href="/landing/Blog/Chapter4#1-introduction">Introduction</a>
</li>
<li>
<a href="/landing/Blog/Chapter4#2-list-comprehensions-a-declarative-approach-to-lists">List Comprehensions: A Declarative Approach to Lists</a>
</li>
<li>
<a href="/landing/Blog/Chapter4#3-folds-reducing-lists-to-a-single-value">Folds: Reducing Lists to a Single Value</a>
</li>
<li>
<a href="/landing/Blog/Chapter4#4-spines-understanding-the-structure-of-lists">Spines: Understanding the Structure of Lists</a>
</li>
<li>
<a href="/landing/Blog/Chapter4#recap">Recap &amp; Exercises</a>
</li>
</ol>
<h2 id="1-introduction">1. Introduction</h2>
<p>Lists and sets are fundamental to Haskell and functional programming in general. They allow us to manipulate collections of data in powerful, declarative ways. In this lesson, we&#39;ll explore how to work with lists efficiently and expressively, using key concepts like <strong>list comprehensions</strong>, <strong>spines</strong>, and <strong>folds</strong>. Understanding these tools will allow you to manipulate collections with a level of precision and flexibility that procedural approaches simply cannot match.</p>
<h2 id="2-list-comprehensions-a-declarative-approach-to-lists">2. List Comprehensions: A Declarative Approach to Lists</h2>
<p>In Haskell, <strong>list comprehensions</strong> provide a clean and concise way to generate and transform lists. If you’ve worked with list comprehensions in Python, the idea will be familiar, but Haskell’s version is more powerful due to the type system and the declarative nature of the language.</p>
<p>List comprehensions allow you to express complex operations on lists in a readable, mathematical form. You can think of them as a way to &quot;declare&quot; what you want the list to look like, rather than &quot;instructing&quot; the computer step by step on how to build it.</p>
<h3 id="syntax-of-list-comprehensions">Syntax of List Comprehensions</h3>
<p>At its core, a list comprehension looks like this:</p>
<div class="source-code"><pre><code class="language-haskell"><span class="sy">[</span><span class="va">expression</span><span> </span><span class="sy">|</span><span> </span><span class="va">element</span><span> </span><span class="sy">&lt;-</span><span> </span><span class="va">list</span><span class="sy">,</span><span> </span><span class="va">condition</span><span class="sy">]</span><span>
</span></code></pre></div>
<ul>
<li>
<strong>expression:</strong> Defines how each element in the resulting list will be constructed.
</li>
<li>
<strong>element &lt;- list:</strong> Defines where the elements are drawn from.
</li>
<li>
<strong>condition:</strong> A filter that specifies which elements should be included in the resulting list.
</li>
</ul>
<h4 id="example-1-simple-list-comprehension">Example 1: Simple List Comprehension</h4>
<p>Let’s start with a basic example: squaring all the numbers in a list.</p>
<div class="source-code"><pre><code class="language-haskell"><span class="va">squares</span><span> </span><span class="sy">::</span><span> </span><span class="sy">[</span><span class="cr">Int</span><span class="sy">]</span><span> </span><span class="sy">-&gt;</span><span> </span><span class="sy">[</span><span class="cr">Int</span><span class="sy">]</span><span>
</span><span class="va">squares</span><span> </span><span class="va">xs</span><span> </span><span class="sy">=</span><span> </span><span class="sy">[</span><span class="va">x</span><span> </span><span class="sy">*</span><span> </span><span class="va">x</span><span> </span><span class="sy">|</span><span> </span><span class="va">x</span><span> </span><span class="sy">&lt;-</span><span> </span><span class="va">xs</span><span>
</span></code></pre></div>
<p>In this example:</p>
<ul>
<li>
The expression <code>x * x</code> tells Haskell to square each element <code>x</code> from the list <code>xs</code>.
</li>
<li>
The result is a new list where each element is the square of the corresponding element in the original list.
</li>
</ul>
<h4 id="example-2-adding-a-condition">Example 2: Adding a Condition</h4>
<p>Now, let’s say we only want the squares of the <strong>even numbers</strong> in a list.</p>
<div class="source-code"><pre><code class="language-haskell"><span class="va">evenSquares</span><span> </span><span class="sy">::</span><span> </span><span class="sy">[</span><span class="cr">Int</span><span class="sy">]</span><span> </span><span class="sy">-&gt;</span><span> </span><span class="sy">[</span><span class="cr">Int</span><span class="sy">]</span><span>
</span><span class="va">evenSquares</span><span> </span><span class="va">xs</span><span> </span><span class="sy">=</span><span> </span><span class="sy">[</span><span class="va">x</span><span> </span><span class="sy">*</span><span> </span><span class="va">x</span><span> </span><span class="sy">|</span><span> </span><span class="va">x</span><span> </span><span class="sy">&lt;-</span><span> </span><span class="va">xs</span><span class="sy">,</span><span> </span><span class="va">even</span><span> </span><span class="va">x</span><span class="sy">]</span><span>
</span></code></pre></div>
<p>Here, we’ve added a condition (<code>even x</code>) to filter the list before squaring the numbers. Only the elements that satisfy the condition (i.e., are even) are passed into the expression for squaring.</p>
<h4 id="realworld-example-generating-cartesian-products">Real-World Example: Generating Cartesian Products</h4>
<p>List comprehensions become even more powerful when working with multiple lists. For example, let’s generate all possible pairs from two lists—a common operation when working with Cartesian products.</p>
<div class="source-code"><pre><code class="language-haskell"><span class="va">cartesianProduct</span><span> </span><span class="sy">::</span><span> </span><span class="sy">[</span><span class="va">a</span><span class="sy">]</span><span> </span><span class="sy">-&gt;</span><span> </span><span class="sy">[</span><span class="va">b</span><span class="sy">]</span><span> </span><span class="sy">-&gt;</span><span> </span><span class="sy">[</span><span class="sy">(</span><span class="va">a</span><span class="sy">,</span><span> </span><span class="va">b</span><span class="sy">)</span><span class="sy">]</span><span>
</span><span class="va">cartesianProduct</span><span> </span><span class="va">xs</span><span> </span><span class="va">ys</span><span> </span><span class="sy">=</span><span> </span><span class="sy">[</span><span class="sy">(</span><span class="va">x</span><span class="sy">,</span><span> </span><span class="va">y</span><span class="sy">)</span><span> </span><span class="sy">|</span><span> </span><span class="va">x</span><span> </span><span class="sy">&lt;-</span><span> </span><span class="va">xs</span><span class="sy">,</span><span> </span><span class="va">y</span><span> </span><span class="sy">&lt;-</span><span> </span><span class="va">ys</span><span class="sy">]</span><span>
</span></code></pre></div>
<p>This list comprehension iterates over both lists and generates every possible pair <code>(x, y)</code> from the elements of <code>xs</code> and <code>ys</code>. You can imagine using this approach to generate test cases, grid coordinates, or combinations in larger applications.</p>
<h2 id="3-folds-reducing-lists-to-a-single-value">3. Folds: Reducing Lists to a Single Value</h2>
<p>In Haskell, <strong>folds</strong> are one of the most important ways to process and reduce lists. They allow you to take a list and &quot;collapse&quot; it into a single value, whether that’s a sum, a product, a concatenated string, or any other result.</p>
<p>At their core, folds apply a binary function (a function that takes two arguments) to a list and an accumulator, folding the list into a single result. Folds are extremely versatile and can be used to implement many common operations, like summing a list, finding the maximum element, or even recreating other list-processing functions like <code>map</code> or <code>filter</code>.</p>
<h3 id="types-of-folds">Types of Folds</h3>
<p>There are two main types of folds in Haskell:</p>
<ul>
<li>
<strong>foldr</strong>: Fold from the right.
</li>
<li>
<strong>foldl</strong>: Fold from the left.
</li>
</ul>
<p>While they both serve the same purpose—reducing a list to a single value—their difference lies in the direction in which they process the list and how they interact with Haskell’s <strong>lazy evaluation</strong> model.</p>
<hr>
<h3 id="foldr-folding-from-the-right">foldr: Folding from the Right</h3>
<p><code>foldr</code> stands for <strong>fold-right</strong>, and it works by processing the list from <strong>right to left</strong>. It takes three arguments:</p>
<ul>
<li>
A <strong>binary function</strong> (a function that takes two arguments).
</li>
<li>
A <strong>starting accumulator</strong> (the initial value to start folding with).
</li>
<li>
The <strong>list</strong> to be folded.
</li>
</ul>
<p>The folding process begins at the <strong>end</strong> of the list and moves toward the beginning, combining elements along the way.</p>
<h4 id="syntax-of-foldr">Syntax of foldr:</h4>
<div class="source-code"><pre><code class="language-haskell"><span class="va">foldr</span><span> </span><span class="sy">::</span><span> </span><span class="sy">(</span><span class="va">a</span><span> </span><span class="sy">-&gt;</span><span> </span><span class="va">b</span><span> </span><span class="sy">-&gt;</span><span> </span><span class="va">b</span><span class="sy">)</span><span> </span><span class="sy">-&gt;</span><span> </span><span class="va">b</span><span> </span><span class="sy">-&gt;</span><span> </span><span class="sy">[</span><span class="va">a</span><span class="sy">]</span><span> </span><span class="sy">-&gt;</span><span> </span><span class="va">b</span><span>
</span></code></pre></div>
<p>This means that <code>foldr</code> takes:</p>
<ul>
<li>
A function of type <code>(a -&gt; b -&gt; b)</code>—the binary function to apply.
</li>
<li>
A starting value of type <code>b</code>.
</li>
<li>
A list of type <code>[a]</code> to be folded.
</li>
</ul>
<p>Let’s break this down with an example:</p>
<h4 id="example-1-summing-a-list-with-foldr">Example 1: Summing a List with foldr</h4>
<div class="source-code"><pre><code class="language-haskell"><span class="va">sumList</span><span> </span><span class="sy">::</span><span> </span><span class="sy">[</span><span class="cr">Int</span><span class="sy">]</span><span> </span><span class="sy">-&gt;</span><span> </span><span class="cr">Int</span><span>
</span><span class="va">sumList</span><span> </span><span class="sy">=</span><span> </span><span class="va">foldr</span><span> </span><span class="sy">(</span><span class="op">+</span><span class="sy">)</span><span> </span><span class="it">0</span><span>
</span></code></pre></div>
<p>Here, we’re using foldr to sum a list of integers:</p>
<ul>
<li>
The function <code>(+): (Int -&gt; Int -&gt; Int)</code> is applied between each pair of elements.
</li>
<li>
<code>0</code> is the starting value (the accumulator).
</li>
<li>
The list is processed from right to left.
</li>
</ul>
<p>The process looks something like this for the list <code>[1, 2, 3]</code>:</p>
<div class="source-code"><pre><code class="language-haskell"><span class="va">foldr</span><span> </span><span class="sy">(</span><span class="op">+</span><span class="sy">)</span><span> </span><span class="it">0</span><span> </span><span class="sy">[</span><span class="it">1</span><span class="sy">,</span><span> </span><span class="it">2</span><span class="sy">,</span><span> </span><span class="it">3</span><span class="sy">]</span><span>
</span><span class="co">-- becomes: 1 + (2 + (3 + 0))</span><span>
</span><span class="co">-- result: 6</span><span>
</span></code></pre></div>
<p>Notice how we start at the end <code>(3 + 0)</code>, then move left, folding the result into each element along the way.</p>
<h4 id="example-2-building-a-list-backwards">Example 2: Building a List Backwards</h4>
<p>Another interesting use case for <code>foldr</code> is that you can use it to rebuild lists or other structures. For example, let’s use <code>foldr</code> to implement the <code>map</code> function:</p>
<div class="source-code"><pre><code class="language-haskell"><span class="va">mapWithFoldr</span><span> </span><span class="sy">::</span><span> </span><span class="sy">(</span><span class="va">a</span><span> </span><span class="sy">-&gt;</span><span> </span><span class="va">b</span><span class="sy">)</span><span> </span><span class="sy">-&gt;</span><span> </span><span class="sy">[</span><span class="va">a</span><span class="sy">]</span><span> </span><span class="sy">-&gt;</span><span> </span><span class="sy">[</span><span class="va">b</span><span class="sy">]</span><span>
</span><span class="va">mapWithFoldr</span><span> </span><span class="va">f</span><span> </span><span class="sy">=</span><span> </span><span class="va">foldr</span><span> </span><span class="sy">(</span><span class="va">x</span><span> </span><span class="va">xs</span><span> </span><span class="sy">-&gt;</span><span> </span><span class="va">f</span><span> </span><span class="va">x</span><span> </span><span class="sy">:</span><span> </span><span class="va">xs</span><span class="sy">)</span><span> </span><span class="sy">[</span><span class="sy">]</span><span>
</span></code></pre></div>
<p>Here, we use <code>foldr</code> to apply a function <code>f</code> to every element in the list, appending the result to the front of the list (using <code>:</code>) as we go.</p>
<h3 id="foldl-folding-from-the-left">foldl: Folding from the Left</h3>
<p><code>foldl</code> stands for <strong>fold-left</strong>, and it processes the list from <strong>left to right</strong>. Unlike <code>foldr</code>, which starts with the last element, <code>foldl</code> begins with the <strong>first element</strong> and works its way to the right.</p>
<h4 id="syntax-of-foldl">Syntax of foldl:</h4>
<div class="source-code"><pre><code class="language-haskell"><span class="va">foldl</span><span> </span><span class="sy">::</span><span> </span><span class="sy">(</span><span class="va">b</span><span> </span><span class="sy">-&gt;</span><span> </span><span class="va">a</span><span> </span><span class="sy">-&gt;</span><span> </span><span class="va">b</span><span class="sy">)</span><span> </span><span class="sy">-&gt;</span><span> </span><span class="va">b</span><span> </span><span class="sy">-&gt;</span><span> </span><span class="sy">[</span><span class="va">a</span><span class="sy">]</span><span> </span><span class="sy">-&gt;</span><span> </span><span class="va">b</span><span>
</span></code></pre></div>
<p>The main difference here is that the binary function’s arguments are flipped—<code>foldl</code> first applies the function to the <strong>accumulator</strong> and then to the list element.</p>
<h4 id="example-1-summing-a-list-with-foldl">Example 1: Summing a List with foldl</h4>
<div class="source-code"><pre><code class="language-haskell"><span class="va">sumListLeft</span><span> </span><span class="sy">::</span><span> </span><span class="sy">[</span><span class="cr">Int</span><span class="sy">]</span><span> </span><span class="sy">-&gt;</span><span> </span><span class="cr">Int</span><span>
</span><span class="va">sumListLeft</span><span> </span><span class="sy">=</span><span> </span><span class="va">foldl</span><span> </span><span class="sy">(</span><span class="op">+</span><span class="sy">)</span><span> </span><span class="it">0</span><span>
</span></code></pre></div>
<p>For the list <code>[1, 2, 3]</code>, the process looks like this:</p>
<div class="source-code"><pre><code class="language-haskell"><span class="va">foldl</span><span> </span><span class="sy">(</span><span class="op">+</span><span class="sy">)</span><span> </span><span class="it">0</span><span> </span><span class="sy">[</span><span class="it">1</span><span class="sy">,</span><span> </span><span class="it">2</span><span class="sy">,</span><span> </span><span class="it">3</span><span class="sy">]</span><span>
</span><span class="co">-- becomes: ((0 + 1) + 2) + 3</span><span>
</span><span class="co">-- result: 6</span><span>
</span></code></pre></div>
<h4 id="why-choose-foldr-or-foldl">Why Choose foldr or foldl?</h4>
<p>The main difference between <code>foldr</code> and <code>foldl</code> comes down to:</p>
<ul>
<li>
<strong>Direction</strong>: <code>foldr</code> processes from right to left, while <code>foldl</code> processes from left to right.
</li>
<li>
<strong>Lazy Evaluation</strong>: <code>foldr</code> works better with Haskell’s lazy evaluation model because it can handle infinite lists, whereas <code>foldl</code> requires the entire list to be evaluated before folding begins.
</li>
</ul>
<p>In most cases, you’ll prefer <code>foldr</code> due to its compatibility with laziness, but there are times when <code>foldl</code> is more efficient (especially with large lists and strict evaluation).</p>
<h3 id="realworld-examples-of-folds">Real-World Examples of Folds</h3>
<p>Now that we understand the mechanics of folds, let’s look at some real-world examples of how they can be applied in practice.</p>
<h4 id="example-1-finding-the-maximum-element">Example 1: Finding the Maximum Element</h4>
<p>Let’s use <code>foldr</code> to find the maximum element in a list of integers.</p>
<div class="source-code"><pre><code class="language-haskell"><span class="va">maxElement</span><span> </span><span class="sy">::</span><span> </span><span class="sy">[</span><span class="cr">Int</span><span class="sy">]</span><span> </span><span class="sy">-&gt;</span><span> </span><span class="cr">Int</span><span>
</span><span class="va">maxElement</span><span> </span><span class="sy">=</span><span> </span><span class="va">foldr1</span><span> </span><span class="va">max</span><span>
</span></code></pre></div>
<p>Here, <code>foldr1</code> is a variant of <code>foldr</code> that doesn’t require an explicit starting value. It simply uses the first element of the list as the initial accumulator.</p>
<h4 id="example-2-concatenating-strings">Example 2: Concatenating Strings</h4>
<p>We can use <code>foldr</code> to concatenate a list of strings into a single string:</p>
<div class="source-code"><pre><code class="language-haskell"><span class="va">concatStrings</span><span> </span><span class="sy">::</span><span> </span><span class="sy">[</span><span class="cr">String</span><span class="sy">]</span><span> </span><span class="sy">-&gt;</span><span> </span><span class="cr">String</span><span>
</span><span class="va">concatStrings</span><span> </span><span class="sy">=</span><span> </span><span class="va">foldr</span><span> </span><span class="sy">(</span><span class="op">++</span><span class="sy">)</span><span> </span><span class="st">&quot;&quot;</span><span>
</span></code></pre></div>
<p>This folds the list of strings using the concatenation operator (++) and an initial empty string &quot;&quot;.</p>
<h4 id="example-3-reversing-a-list">Example 3: Reversing a List</h4>
<p>Finally, let’s use <code>foldl</code> to reverse a list:</p>
<div class="source-code"><pre><code class="language-haskell"><span class="va">reverseList</span><span> </span><span class="sy">::</span><span> </span><span class="sy">[</span><span class="va">a</span><span class="sy">]</span><span> </span><span class="sy">-&gt;</span><span> </span><span class="sy">[</span><span class="va">a</span><span class="sy">]</span><span>
</span><span class="va">reverseList</span><span> </span><span class="sy">=</span><span> </span><span class="va">foldl</span><span> </span><span class="sy">(</span><span class="va">acc</span><span> </span><span class="va">x</span><span> </span><span class="sy">-&gt;</span><span> </span><span class="va">x</span><span> </span><span class="sy">:</span><span> </span><span class="va">acc</span><span class="sy">)</span><span> </span><span class="sy">[</span><span class="sy">]</span><span>
</span></code></pre></div>
<p>This works by prepending each element to the accumulator as we move from left to right, effectively reversing the order of the list.</p>
<h2 id="4-spines-understanding-the-structure-of-lists">4. Spines: Understanding the Structure of Lists</h2>
<p>One thing that makes lists in Haskell different from lists in many other languages is the concept of spines. The spine is the structure that holds the elements of a list together, and understanding how it works can help you write more efficient programs.</p>
<h3 id="what-is-the-spine-of-a-list">What is the Spine of a List?</h3>
<p>A spine in Haskell represents the structure of the list—specifically, the &quot;links&quot; between elements. A list in Haskell is either:</p>
<ul>
<li>
Empty (<code>[]</code>), or
</li>
<li>
A cons cell (<code>:</code>) that contains a head element and a reference to the next element (which can be either another cons cell or an empty list).
</li>
</ul>
<p>You can think of the spine as the &quot;skeleton&quot; of the list. The elements are like &quot;flesh&quot; attached to the spine.</p>
<h4 id="example-visualizing-the-spine">Example: Visualizing the Spine</h4>
<p>Consider the list <code>[1, 2, 3]</code>. Its structure is:</p>
<div class="source-code"><pre><code class="language-haskell"><span class="it">1</span><span> </span><span class="sy">:</span><span> </span><span class="sy">(</span><span class="it">2</span><span> </span><span class="sy">:</span><span> </span><span class="sy">(</span><span class="it">3</span><span> </span><span class="sy">:</span><span> </span><span class="sy">[</span><span class="sy">]</span><span class="sy">)</span><span class="sy">)</span><span>
</span></code></pre></div>
<p>Here, the spine is made up of the <code>:</code> (cons) operators linking the elements together, ending in the empty list <code>[]</code>.</p>
<h3 id="why-do-spines-matter">Why Do Spines Matter?</h3>
<p>In Haskell, because of lazy evaluation, the elements of a list and the spine are evaluated separately. This means you can partially evaluate a list—perhaps you’ve calculated the spine but haven’t yet evaluated the elements. This is a powerful feature, but it can also introduce inefficiencies if you’re not careful.</p>
<p>For example, if you traverse a list just to calculate its length, you’ll traverse the entire spine, but you won’t need to evaluate the elements:</p>
<div class="source-code"><pre><code class="language-haskell"><span class="va">length</span><span> </span><span class="sy">::</span><span> </span><span class="sy">[</span><span class="va">a</span><span class="sy">]</span><span> </span><span class="sy">-&gt;</span><span> </span><span class="cr">Int</span><span>
</span><span class="va">length</span><span> </span><span class="sy">[</span><span class="sy">]</span><span> </span><span class="sy">=</span><span> </span><span class="it">0</span><span>
</span><span class="va">length</span><span> </span><span class="sy">(</span><span class="sy">_</span><span class="sy">:</span><span class="va">xs</span><span class="sy">)</span><span> </span><span class="sy">=</span><span> </span><span class="it">1</span><span> </span><span class="op">+</span><span> </span><span class="va">length</span><span> </span><span class="va">xs</span><span>
</span></code></pre></div>
<p>In this example, the length function only traverses the spine—it doesn’t care about the values in the list.</p>
<p>Understanding this distinction is key when you start working with large lists or performing partial evaluations. It helps you optimize your code by deciding when it makes sense to evaluate the spine or the elements of the list.</p>
<h3 id="efficient-use-of-spines">Efficient Use of Spines</h3>
<p>When working with lists, understanding how Haskell evaluates the spine can help you write more efficient code. Since Haskell lists are linked lists (not arrays), operations that require traversing the spine will have a time complexity proportional to the length of the list. Some operations only need to touch the spine, while others need to evaluate both the spine and the elements.</p>
<h4 id="example-efficient-operations">Example: Efficient Operations</h4>
<p>Certain operations are efficient because they only need to traverse the spine, without caring about the elements:</p>
<ul>
<li>
<code>length</code>: Traverses the spine to count the number of elements, but never evaluates the elements themselves.
</li>
<li>
<code>null</code>: Checks whether the spine is empty by looking at the first constructor (<code>[]</code> or <code>:</code>). It doesn’t care about the elements.
</li>
<li>
<code>tail</code>: Returns the rest of the list, which means discarding the first <code>:</code> in the spine. It doesn’t need to evaluate the elements.
</li>
</ul>
<p>These operations are efficient because they only operate on the structure, without needing to evaluate the values inside the list.</p>
<h3 id="potential-inefficiencies-of-spines">Potential Inefficiencies of Spines</h3>
<p>While lazy evaluation and separate evaluation of spines and elements can make certain operations efficient, it can also lead to inefficiencies if not handled carefully.</p>
<h4 id="1-spine-traversal-and-deep-structures">1. Spine Traversal and Deep Structures</h4>
<p>Because Haskell lists are linked lists, any operation that requires traversing the entire spine of the list will take <strong>O(n)</strong> time, where <code>n</code> is the length of the list. This means that some operations, like appending to the end of a list, are inherently inefficient because they require traversing the entire spine first.</p>
<p>For example, consider this operation:</p>
<div class="source-code"><pre><code class="language-haskell"><span class="va">appendToList</span><span> </span><span class="sy">::</span><span> </span><span class="sy">[</span><span class="cr">Int</span><span class="sy">]</span><span> </span><span class="sy">-&gt;</span><span> </span><span class="sy">[</span><span class="cr">Int</span><span class="sy">]</span><span>
</span><span class="va">appendToList</span><span> </span><span class="va">xs</span><span> </span><span class="sy">=</span><span> </span><span class="va">xs</span><span> </span><span class="op">++</span><span> </span><span class="sy">[</span><span class="it">4</span><span class="sy">]</span><span>
</span></code></pre></div>
<p>The operator <code>(++)</code> works by traversing the entire spine of the first list to find the end, where the second list is then appended. So, if <code>xs</code> is long, this operation becomes increasingly expensive, as it has to traverse the entire spine before adding <code>4</code>.</p>
<h4 id="2-spineheavy-operations-and-memory-leaks">2. Spine-Heavy Operations and Memory Leaks</h4>
<p>Another potential inefficiency arises when you partially evaluate lists, leading to a phenomenon known as <strong>space leaks</strong>. In certain situations, the spine can be built up in memory without fully evaluating the elements, leading to unnecessary memory usage. This is particularly problematic in long-running programs that repeatedly construct large lists without evaluating them.</p>
<p>For example, take this code:</p>
<div class="source-code"><pre><code class="language-haskell"><span class="va">buildList</span><span> </span><span class="sy">::</span><span> </span><span class="cr">Int</span><span> </span><span class="sy">-&gt;</span><span> </span><span class="sy">[</span><span class="cr">Int</span><span class="sy">]</span><span>
</span><span class="va">buildList</span><span> </span><span class="va">n</span><span> </span><span class="sy">=</span><span> </span><span class="sy">[</span><span class="it">1</span><span class="sy">..</span><span class="va">n</span><span class="sy">]</span><span> </span><span class="op">++</span><span> </span><span class="sy">[</span><span class="it">100</span><span class="sy">]</span><span>
</span></code></pre></div>
<p>If <code>buildList</code> is used in a context where the result is not immediately evaluated, Haskell might leave the spine unevaluated in memory, consuming space until it’s finally needed. This is called <strong>thunking</strong> — Haskell delays computation by storing &quot;thunks&quot; (deferred computations), which can accumulate and lead to memory bloat if left unchecked.</p>
<h4 id="3-repeated-spine-traversals">3. Repeated Spine Traversals</h4>
<p>Repeatedly traversing the spine of a list can also lead to inefficiency. For example, calling <code>length</code> multiple times on the same list will result in multiple traversals of the spine:</p>
<div class="source-code"><pre><code class="language-haskell"><span class="va">list</span><span> </span><span class="sy">=</span><span> </span><span class="sy">[</span><span class="it">1</span><span class="sy">..</span><span class="it">1000000</span><span class="sy">]</span><span>

</span><span class="va">main</span><span> </span><span class="sy">=</span><span> </span><span class="kw">do</span><span>
    </span><span class="va">print</span><span> </span><span class="op">$</span><span> </span><span class="va">length</span><span> </span><span class="va">list</span><span>   </span><span class="co">-- First traversal of the spine</span><span>
    </span><span class="va">print</span><span> </span><span class="op">$</span><span> </span><span class="va">length</span><span> </span><span class="va">list</span><span>   </span><span class="co">-- Second traversal of the spine</span><span>
</span></code></pre></div>
<p>In this case, both <code>length</code> operations traverse the entire spine of the list separately, even though the result is the same. If you need to reuse results that involve traversing the spine, it’s better to cache the result (using a variable or memoization) to avoid repeated traversals.</p>
<h3 id="optimizing-for-spine-efficiency">Optimizing for Spine Efficiency</h3>
<p>Understanding spines allows you to make informed decisions about how to work with lists efficiently in Haskell. Here are some ways to optimize performance when working with spines:</p>
<h4 id="1-use-foldr-instead-of-foldl">1. Use <code>foldr</code> Instead of <code>foldl</code></h4>
<p>When folding lists, prefer right folds (<code>foldr</code>) over left folds (<code>foldl</code>), especially when working with large or infinite lists. Since <code>foldr</code> works with lazy evaluation, it can stop processing once it reaches a base case, whereas <code>foldl</code> must traverse the entire spine first before returning a result.</p>
<p>For example:</p>
<div class="source-code"><pre><code class="language-haskell"><span class="va">sumListRight</span><span> </span><span class="sy">::</span><span> </span><span class="sy">[</span><span class="cr">Int</span><span class="sy">]</span><span> </span><span class="sy">-&gt;</span><span> </span><span class="cr">Int</span><span>
</span><span class="va">sumListRight</span><span> </span><span class="sy">=</span><span> </span><span class="va">foldr</span><span> </span><span class="sy">(</span><span class="op">+</span><span class="sy">)</span><span> </span><span class="it">0</span><span>   </span><span class="co">-- Efficient with laziness</span><span>
</span></code></pre></div>
<p>In contrast, <code>foldl</code> must evaluate the entire spine, which can lead to inefficiency:</p>
<div class="source-code"><pre><code class="language-haskell"><span class="va">sumListLeft</span><span> </span><span class="sy">::</span><span> </span><span class="sy">[</span><span class="cr">Int</span><span class="sy">]</span><span> </span><span class="sy">-&gt;</span><span> </span><span class="cr">Int</span><span>
</span><span class="va">sumListLeft</span><span> </span><span class="sy">=</span><span> </span><span class="va">foldl</span><span> </span><span class="sy">(</span><span class="op">+</span><span class="sy">)</span><span> </span><span class="it">0</span><span>    </span><span class="co">-- Requires full spine evaluation</span><span>
</span></code></pre></div>
<h4 id="2-avoid-appending-with">2. Avoid Appending with <code>(++)</code></h4>
<p>When building lists, avoid appending elements to the end using the <code>(++)</code> operator, as this requires traversing the entire spine. Instead, prefer prepending (<code>:</code>), which only requires modifying the first link in the spine.</p>
<div class="source-code"><pre><code class="language-haskell"><span class="co">-- Inefficient: Traverses the whole spine</span><span>
</span><span class="va">appendEnd</span><span> </span><span class="sy">::</span><span> </span><span class="sy">[</span><span class="cr">Int</span><span class="sy">]</span><span> </span><span class="sy">-&gt;</span><span> </span><span class="sy">[</span><span class="cr">Int</span><span class="sy">]</span><span>
</span><span class="va">appendEnd</span><span> </span><span class="va">xs</span><span> </span><span class="sy">=</span><span> </span><span class="va">xs</span><span> </span><span class="op">++</span><span> </span><span class="sy">[</span><span class="it">4</span><span class="sy">]</span><span>

</span><span class="co">-- Efficient: Prepend to the start</span><span>
</span><span class="va">prependStart</span><span> </span><span class="sy">::</span><span> </span><span class="sy">[</span><span class="cr">Int</span><span class="sy">]</span><span> </span><span class="sy">-&gt;</span><span> </span><span class="sy">[</span><span class="cr">Int</span><span class="sy">]</span><span>
</span><span class="va">prependStart</span><span> </span><span class="va">xs</span><span> </span><span class="sy">=</span><span> </span><span class="it">4</span><span> </span><span class="sy">:</span><span> </span><span class="va">xs</span><span>
</span></code></pre></div>
<h4 id="3-force-evaluation-when-necessary">3. Force Evaluation When Necessary</h4>
<p>In cases where laziness might lead to memory bloat (space leaks), you can use functions like <code>seq</code> or <code>deepseq</code> to <strong>force evaluation</strong> of the list’s elements and spine. This ensures that thunks don’t accumulate in memory.</p>
<div class="source-code"><pre><code class="language-haskell"><span class="kw">import</span><span> </span><span class="cr">Control.DeepSeq</span><span>

</span><span class="va">evaluateList</span><span> </span><span class="sy">::</span><span> </span><span class="sy">[</span><span class="cr">Int</span><span class="sy">]</span><span> </span><span class="sy">-&gt;</span><span> </span><span class="cr">Int</span><span>
</span><span class="va">evaluateList</span><span> </span><span class="va">xs</span><span> </span><span class="sy">=</span><span> </span><span class="va">xs</span><span> </span><span class="sy">`</span><span class="va">deepseq</span><span class="sy">`</span><span> </span><span class="va">length</span><span> </span><span class="va">xs</span><span>
</span></code></pre></div>
<p>Here, <code>deepseq</code> forces the evaluation of both the spine and the elements, preventing memory leaks.</p>
<h2 id="5-recap-exercises">5. Recap &amp; Exercises</h2>
<h3 id="recap">Recap</h3>
<ul>
<li>
<strong>Folds are foundational</strong>: They allow us to <strong>reduce</strong> lists into single values and are used for a wide range of operations, from summing numbers to building complex data structures.
</li>
<li>
<strong>Direction matters</strong>: <code>foldr</code> processes lists from <strong>right to left</strong> and is often more compatible with lazy evaluation, while <code>foldl</code> processes from <strong>left to right</strong> and can be more efficient with strict evaluation.
</li>
<li>
<strong>Flexibility</strong>: With folds, you can implement nearly any list-processing function, whether it’s summing, finding a maximum, reversing, or even mimicking higher-level functions like <code>map</code> and <code>filter</code>.
</li>
</ul>
<h3 id="exercises">Exercises</h3>
<p>Here are some exercises to help you practice working with list comprehensions, spines, and folds:</p>
<h4 id="exercise-1-list-comprehensions">Exercise 1: List Comprehensions</h4>
<p>Write a list comprehension that generates a list of all odd squares from 1 to 100.</p>
<div class="source-code"><pre><code class="language-haskell"><span class="va">oddSquares</span><span> </span><span class="sy">::</span><span> </span><span class="sy">[</span><span class="cr">Int</span><span class="sy">]</span><span>
</span><span class="co">-- Your implementation here</span><span>
</span></code></pre></div>
<h4 id="exercise-2-custom-fold">Exercise 2: Custom Fold</h4>
<p>Using <code>foldr</code>, write a function that counts the number of odd numbers in a list of integers.</p>
<div class="source-code"><pre><code class="language-haskell"><span class="va">countOdd</span><span> </span><span class="sy">::</span><span> </span><span class="sy">[</span><span class="cr">Int</span><span class="sy">]</span><span> </span><span class="sy">-&gt;</span><span> </span><span class="cr">Int</span><span>
</span><span class="co">-- Your implementation here</span><span>
</span></code></pre></div>
<h4 id="exercise-3-reverse-a-list">Exercise 3: Reverse a List</h4>
<p>Using <code>foldr</code>, write a function reverses a list.</p>
<div class="source-code"><pre><code class="language-haskell"><span class="va">reverseFoldr</span><span> </span><span class="sy">::</span><span> </span><span class="sy">[</span><span class="va">a</span><span class="sy">]</span><span> </span><span class="sy">-&gt;</span><span> </span><span class="sy">[</span><span class="va">a</span><span class="sy">]</span><span>
</span><span class="co">-- Your implementation here</span><span>
</span></code></pre></div>
<p><a href="/landing/Blog/Chapter3">Previous Chapter</a> |
<a href="/landing/Blog/Chapter5">Next Chapter</a></p>
</div></div></body></html>