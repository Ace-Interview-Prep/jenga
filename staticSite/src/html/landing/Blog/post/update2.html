<html lang="en"><head><style>
/* Markdown Shell */
.containerBlog {
   padding: 200px;
   background-color: black;
   color: white;
   font-size: 20px;
   font-family: Georgia, serif;
}

.containerBlog ol {
   list-style-type: decimal;
   padding-left: 2.5rem;
}
.containerBlog ul {
   list-style-type: disc;
   padding-left: 2.5rem;
}

.containerBlog td {
   padding: 3px;
   border-color: #888;
}

.containerBlog li {
   padding: 5px 10px;
}

.containerBlog p {
   padding: 10px 0px;
}

.containerBlog a {
   color: #00B9DA;
   text-decoration: none;
}

.containerBlog p code {
  background-color: #D3D3D3;
  padding: 0px 3px;
  border-radius: 0.5rem;
}

.containerBlog h1 {
  padding: 25px 0px;
  font-weight: bold;
  font-size: 2em;
  color: #fff4f4;
  text-decoration: underline;
}
.containerBlog h2 {
  padding: 25px 0px;
  font-weight: bold;
  font-size: 1.5em;
  color: #fff4f4;
  text-decoration: underline;
}
.containerBlog h3 {
  padding: 25px 0px;
  font-weight: bold;
  font-size:1.17em;
  color: #fff4f4;
  text-decoration: underline;
}
.containerBlog h4 {
  padding: 25px 0px;
  font-weight: bold;
  font-size: 1em;
  color: #fff4f4;
  text-decoration: underline;
}
.containerBlog h5 {
  padding: 25px 0px;
  font-weight: bold;
  font-size: 0.83em;
  color: #fff4f4;
  text-decoration: underline;
}



/* Otherwise comments can go on into infinity */
span.co {
  word-break: break-word;        /* Safe wrap on words */
  overflow-wrap: anywhere;       /* Force wrap anywhere if needed */
  white-space: normal;           /* Allow wrapping */
}


code:not([class]) {
  /* your styles here */
  background-color: white;
  padding: 4px;
  border-radius: 5px;
}

code span {
  display: inline;
  white-space: pre;
}

.source-code {
  padding: 8px;
  border-color: white;
  background-color: black;
}

}
/* One off haskell constructs */
code {
  color: #154dcb;
  font-weight: bold;
}

div.source-code {
  overflow-x:auto;
  max-width:100%;
}

code.language-haskell {
  overflow-x:auto;
  max-width:100%;
}

/* Haskell Syntax */
.pr {
   color: #F8E473;
}
.op {
   color: gold;
}
.sy {
   color: #FADA5E;
}
.co {
   color: green;
}
.cr {
   color: #af64ff;
}
.va {
   color: #6693F5; 
}
.kw {
    color: #f0883e;
}

/* Haskell Syntax - Literals */
.st {
  color: #a5d6ff;
}
.ch {
  color: #2E3A59;
}
.it {}
.ra {}


/* Other Languages Via Skylighting Tokenizer */

.pp {
  color: blue;
}
.im {
  color: green;
}
.dt {
  color: green;
}
.cf {
  color: orange;
}
/*Like char */
.sc {
  color: orange;
}
/* java func */
.fu {
  color: #6693F5;
}

/* base color C lang */
.language-c {
  color: #6693F5;
}

.language-bash {
  color: #154dcb;
  font-weight: bold;
}

.language-nix {
  color: grey;
  font-weight: bold;
}

.language-java {
  color: #6693F5;
}
.language-csharp {
  color: #E3B778;
}
.language-python {
  color: #E3B778;
}
</style><style>a { color: #00B9DA; text-decoration: none; }</style></head><body><div class="fixed top-0 left-0 w-full h-full overflow-auto z-10 scroll-smooth"><div class="containerBlog"><h1 id="atc-monthly-status-update-september-7th-2025">ATC Monthly Status Update - September 7th 2025</h1>
<p>by lazyLambda</p>
<p>As its now the 7th its time for the second Ace Haskell Talent update. In case you have not read the first post, we are a community that teaches and mentors students using Haskell as a tool to learn proper fundamentals of coding. We write these posts as we are sure we aren&#39;t the only ones in the greater Haskell community that are interested in sustainability growing the number of haskell contributors.</p>
<h1 id="weekly-saturday-learning-sessions">Weekly Saturday Learning Sessions</h1>
<p>This month in our weekly sessions with apprentices, we have been experimenting with changing from beginner/novice friendly problems in our Saturday sessions to the very challenging problem of building a video game in haskell.</p>
<p>In our last session it was quite interesting as the discussion was much more focused on the domain of physics than it was about &quot;how to code&quot;. This was because we had reached a point where we could discuss collision handling of two objects, in particular two balls with some mass at a given angle. While this is work that Kyle has done in the past, it has been years since that point and all a relatively new problem to our apprentices. This was actually quite desirable as it was something that caused a pen and paper discussion about how to understand dot product and/or that this problem is known in physics as the conservation of momentum. Where possible we want to naturally facilitate discussions like this where we teach our students to visually represent a problem, because I personally believe this is a vital step in abstract learning (like the use of diagrams in category theory) and arguably this is also why we are doing something like a video game which is full of visual feedback. Pulling on my knowledge of neuroscience it seems to reason that the concepts of logic and the mental framework I implicitly operate out in, are mere summaries of visual learning I have done. For instance diagrams in general being a way to understand case statements and flow of data.As its now the 7th its time for the second Ace Haskell Talent update. In case you have not read the first post, we are a community that teaches and mentors students using Haskell as a tool to learn proper fundamentals of coding. We write these posts as we are sure we aren&#39;t the only ones in the greater Haskell community that are interested in sustainability growing the number of haskell contributors.</p>
<p>In previous sessions, we did all the necessary work to visually collide two balls on screen, ie window creation through Haskell SDL library and the OpenGL lib. In that case it also led to a number of rich discussions on operating systems, as through chance and debugging, the apprentices saw the project in question compile completely fine on my NixOS setup, and struggle on Kyle&#39;s WSL (Ubuntu).</p>
<p>Over these past few weeks, game development, much like haskell has been a perfect canvas to teach correctly on. Psychology-wise it stands to reason that &quot;play&quot; is an effective way to strengthen learning so all the more reason to continue on with game dev, and it&#39;s not like there aren&#39;t ample opportunities for demonstrating the fundamentals for those who are recently joining the community.</p>
<h1 id="infrastructure">Infrastructure</h1>
<p>We recently completed a massive update to our infrastructure, where we needed to switch from how we previously operated as an Interview Prep helper to being a learning community. It&#39;s worth mentioning here as we think it&#39;s both worth teaching to our devs so that they can achieve amazing projects, but also so that we can have a landing point... a realistic landing point for beginners. This may be controversial, but in my opinion we need the quote-un-quote &quot;bad&quot; developers. I will be the first to say there are objectively weak developers, but we should differentiate between someone who will be weak and someone who is only currently weak. As a self-taught developer, this is important to me. So how do we differentiate? the answer is we cannot possibly tell in the first week, but we can after a month. So we should provide a toolset that gives a noob (like how I was a noob) confidence they are on the right path, and then just see if they can grow.</p>
<p>So what does this have to do with infrastructure? Well it arguably has more to do with prejudices of Haskell. I had a recent reddit encounter in r/learnprogramming with a top 1% commenter, who ultimately said</p>
<p>&quot;really? you are recommending Haskell? What if I need a web app, a video game, or ...&quot;</p>
<p>To which any expert should simply reply &quot;They (python, haskell, C#, etc) are called a general purpose language for a reason, language choice is a way of expressing and not tied to a domain, that is a DSL&quot;</p>
<p>Unfortunately, there are many such top 1% commenters who are surely trusted by newbies when they say &quot;use the [most popular programming language] its great for [some domain]&quot;. So the reason this has anything to do with Haskell is that there are select cases where a critic can make a correct-sounding point. For instance, MicroHs to the best of my knowledge is still early.</p>
<p>I also think the average skill level of the Haskell developer being so ridiculously high means that there is less agreement on &quot;what is best&quot; for a junior to learn. For instance, I love Obelisk <em>and specifically how opinionated</em> it is. Other&#39;s hate that and would rather write directly on top of WAI + WARP. I think both options are great and definitively better than using Node.js (.... i think we all agree on that)</p>
<p>SO therefore, I am excited to be releasing the stack I have built for my startup, which is truthfully just a thin layer on top of a collection of awesome Haskell projects, that no developer can argue is better to learn for a web developer (seems the most common path for newbies) than to learn this stack.</p>
<p>Most notably, it will work on top of Obelisk and uses some trickery to optimize SEO page speed + uses the MMark package for markdown. I plan to shill the heck out of it. I&#39;m gonna call it Jenga for fun, as that is my Dogs name, and in Jenga, <em>you start with a full stack</em></p>
<h1 id="community-changes">Community Changes</h1>
<p>We have started to open up our weekly sessions for anyone who wants to join in on the fun, whether the session is a theory-focused lesson or all of us collaborating on some pair programmed application. If you are interested, feel free to ask me for a link via my email: galen.sprout@gmail.com . It is of course expected that you are respectful of everyone and even extra-respectful: no question is too noob, because a question being asked means someone is willing to learn. We also use the Jitsi platform so its easy to be anonymous for all participants.</p>
<p>Thank you, anonymous stranger, and bye for now :)</p>
</div></div></body></html>