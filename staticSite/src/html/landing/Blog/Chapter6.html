<html lang="en"><head><style>
/* Markdown Shell */
.containerBlog {
   padding: 200px;
   background-color: black;
   color: white;
   font-size: 20px;
   font-family: Georgia, serif;
}

.containerBlog ol {
   list-style-type: decimal;
   padding-left: 2.5rem;
}
.containerBlog ul {
   list-style-type: disc;
   padding-left: 2.5rem;
}

.containerBlog td {
   padding: 3px;
   border-color: #888;
}

.containerBlog li {
   padding: 5px 10px;
}

.containerBlog p {
   padding: 10px 0px;
}

.containerBlog a {
   color: #00B9DA;
   text-decoration: none;
}

.containerBlog p code {
  background-color: #D3D3D3;
  padding: 0px 3px;
  border-radius: 0.5rem;
}

.containerBlog h1 {
  padding: 25px 0px;
  font-weight: bold;
  font-size: 2em;
  color: #fff4f4;
  text-decoration: underline;
}
.containerBlog h2 {
  padding: 25px 0px;
  font-weight: bold;
  font-size: 1.5em;
  color: #fff4f4;
  text-decoration: underline;
}
.containerBlog h3 {
  padding: 25px 0px;
  font-weight: bold;
  font-size:1.17em;
  color: #fff4f4;
  text-decoration: underline;
}
.containerBlog h4 {
  padding: 25px 0px;
  font-weight: bold;
  font-size: 1em;
  color: #fff4f4;
  text-decoration: underline;
}
.containerBlog h5 {
  padding: 25px 0px;
  font-weight: bold;
  font-size: 0.83em;
  color: #fff4f4;
  text-decoration: underline;
}



/* Otherwise comments can go on into infinity */
span.co {
  word-break: break-word;        /* Safe wrap on words */
  overflow-wrap: anywhere;       /* Force wrap anywhere if needed */
  white-space: normal;           /* Allow wrapping */
}


code:not([class]) {
  /* your styles here */
  background-color: white;
  padding: 4px;
  border-radius: 5px;
}

code span {
  display: inline;
  white-space: pre;
}

.source-code {
  padding: 8px;
  border-color: white;
  background-color: black;
}

}
/* One off haskell constructs */
code {
  color: #154dcb;
  font-weight: bold;
}

div.source-code {
  overflow-x:auto;
  max-width:100%;
}

code.language-haskell {
  overflow-x:auto;
  max-width:100%;
}

/* Haskell Syntax */
.pr {
   color: #F8E473;
}
.op {
   color: gold;
}
.sy {
   color: #FADA5E;
}
.co {
   color: green;
}
.cr {
   color: #af64ff;
}
.va {
   color: #6693F5; 
}
.kw {
    color: #f0883e;
}

/* Haskell Syntax - Literals */
.st {
  color: #a5d6ff;
}
.ch {
  color: #2E3A59;
}
.it {}
.ra {}


/* Other Languages Via Skylighting Tokenizer */

.pp {
  color: blue;
}
.im {
  color: green;
}
.dt {
  color: green;
}
.cf {
  color: orange;
}
/*Like char */
.sc {
  color: orange;
}
/* java func */
.fu {
  color: #6693F5;
}

/* base color C lang */
.language-c {
  color: #6693F5;
}

.language-bash {
  color: #154dcb;
  font-weight: bold;
}

.language-nix {
  color: grey;
  font-weight: bold;
}

.language-java {
  color: #6693F5;
}
.language-csharp {
  color: #E3B778;
}
.language-python {
  color: #E3B778;
}
</style><style>a { color: #00B9DA; text-decoration: none; }</style></head><body><div class="fixed top-0 left-0 w-full h-full overflow-auto z-10 scroll-smooth"><div class="containerBlog"><h1 id="chapter-6-combine-your-functions">Chapter 6: Combine your Functions</h1>
<ol>
<li>
<a href="/landing/Blog/Chapter6#1-introduction">Introduction</a>
</li>
<li>
<a href="/landing/Blog/Chapter6#2-what-is-function-composition">What is Function Composition?</a>
</li>
<li>
<a href="/landing/Blog/Chapter6#3-functors-mapping-over-contexts">Functors: Mapping Over Contexts</a>
</li>
<li>
<a href="/landing/Blog/Chapter6#4-monoids-combining-values-consistently">Monoids: Combining Values Consistently</a>
</li>
<li>
<a href="/landing/Blog/Chapter6#5-semigroups-combining-values-without-an-identity">Semigroups: Combining Values Without an Identity</a>
</li>
<li>
<a href="/landing/Blog/Chapter6#6-applicatives-combining-independent-effects">Applicatives: Combining Independent Effects</a>
</li>
<li>
<a href="/landing/Blog/Chapter6#7-monads-chaining-dependent-effects">Monads: Chaining Dependent Effects</a>
</li>
<li>
<a href="/landing/Blog/Chapter6#recap">Recap &amp; Exercises</a>
</li>
</ol>
<h2 id="1-introduction">1. Introduction</h2>
<p>Haskell is often described as a language that thrives on <strong>function composition</strong>. This concept is one of the most powerful principles of functional programming, enabling us to build complex logic by combining small, reusable, and pure functions. Before diving into Functors, Monoids, Applicatives, and Monads, let’s lay the groundwork by understanding <strong>function composition</strong> and why it’s so critical.</p>
<h2 id="2-what-is-function-composition">2. What is Function Composition?</h2>
<p>In mathematics, <strong>function composition</strong> is the process of applying one function to the result of another. If we have two functions, <code>f</code> and <code>g</code>, their composition <code>f ∘ g</code> applies <code>g</code> first and then applies <code>f</code> to the result.</p>
<p>In Haskell, function composition is represented by the <code>(.)</code> operator:</p>
<div class="source-code"><pre><code class="language-haskell"><span class="sy">(</span><span class="op">.</span><span class="sy">)</span><span> </span><span class="sy">::</span><span> </span><span class="sy">(</span><span class="va">b</span><span> </span><span class="sy">-&gt;</span><span> </span><span class="va">c</span><span class="sy">)</span><span> </span><span class="sy">-&gt;</span><span> </span><span class="sy">(</span><span class="va">a</span><span> </span><span class="sy">-&gt;</span><span> </span><span class="va">b</span><span class="sy">)</span><span> </span><span class="sy">-&gt;</span><span> </span><span class="va">a</span><span> </span><span class="sy">-&gt;</span><span> </span><span class="va">c</span><span>
</span></code></pre></div>
<p>This means:</p>
<ul>
<li>
Take a function <code>f</code> of type <code>(b -&gt; c)</code> and a function <code>g</code> of type <code>(a -&gt; b)</code>.
</li>
<li>
Combine them into a new function of type <code>(a -&gt; c)</code>.
</li>
</ul>
<p>Here’s a simple example:</p>
<div class="source-code"><pre><code class="language-haskell"><span class="va">addOne</span><span> </span><span class="sy">::</span><span> </span><span class="cr">Int</span><span> </span><span class="sy">-&gt;</span><span> </span><span class="cr">Int</span><span>
</span><span class="va">addOne</span><span> </span><span class="va">x</span><span> </span><span class="sy">=</span><span> </span><span class="va">x</span><span> </span><span class="op">+</span><span> </span><span class="it">1</span><span>

</span><span class="va">double</span><span> </span><span class="sy">::</span><span> </span><span class="cr">Int</span><span> </span><span class="sy">-&gt;</span><span> </span><span class="cr">Int</span><span>
</span><span class="va">double</span><span> </span><span class="va">x</span><span> </span><span class="sy">=</span><span> </span><span class="va">x</span><span> </span><span class="sy">*</span><span> </span><span class="it">2</span><span>

</span><span class="va">combined</span><span> </span><span class="sy">::</span><span> </span><span class="cr">Int</span><span> </span><span class="sy">-&gt;</span><span> </span><span class="cr">Int</span><span>
</span><span class="va">combined</span><span> </span><span class="sy">=</span><span> </span><span class="va">addOne</span><span> </span><span class="op">.</span><span> </span><span class="va">double</span><span>

</span><span class="va">main</span><span> </span><span class="sy">::</span><span> </span><span class="cr">IO</span><span> </span><span class="sy">(</span><span class="sy">)</span><span>
</span><span class="va">main</span><span> </span><span class="sy">=</span><span> </span><span class="va">print</span><span> </span><span class="sy">(</span><span class="va">combined</span><span> </span><span class="it">3</span><span class="sy">)</span><span> </span><span class="co">-- Output: 7</span><span>
</span></code></pre></div>
<p>In this example:</p>
<ul>
<li>
<code>double</code> is applied first to give <code>6</code> (<code>3 * 2</code>).
</li>
<li>
addOne is then applied to 6 to produce <code>7</code>.
</li>
</ul>
<h3 id="functional-composition-vs-object-modularity">Functional Composition vs Object Modularity</h3>
<p>Object-oriented languages often emphasize <strong>modularity</strong>, where we create independent pieces of code (functions, classes, modules) and integrate them. While modularity allows for separation of concerns, it lacks the <strong>seamless composability</strong> of functional programming.</p>
<h4 id="modularity-vs-composability">Modularity vs. Composability</h4>
<ul>
<li>
<strong>Modular Functions in OO</strong>: Functions are often independent but don’t naturally &quot;chain&quot; together. To combine them, you often write glue code or manage shared state explicitly.
</li>
<li>
<strong>Composable Functions in FP</strong>: Functions in Haskell are pure, meaning they have no side effects and always produce the same output for the same input. This makes them inherently composable—no glue code or state management is needed.
</li>
</ul>
<h4 id="example-combining-functions-in-oo-vs-fp">Example: Combining Functions in OO vs. FP</h4>
<p><strong>In an OO language</strong> (e.g., Python or Java):</p>
<div class="source-code"><pre><code class="language-python"><span class="kw">def</span><span> double(x):</span>
<span>    </span><span class="cf">return</span><span> x </span><span class="op">*</span><span> </span><span class="dv">2</span>

<span class="kw">def</span><span> add_one(x):</span>
<span>    </span><span class="cf">return</span><span> x </span><span class="op">+</span><span> </span><span class="dv">1</span>

<span class="kw">def</span><span> combined(x):</span>
<span>    temp </span><span class="op">=</span><span> double(x)</span>
<span>    </span><span class="cf">return</span><span> add_one(temp)</span>

<span class="bu">print</span><span>(combined(</span><span class="dv">3</span><span>)) </span><span class="co"># Output: 7</span>
</code></pre></div>
<p>Here, you have to manually &quot;wire&quot; the functions together using intermediate variables like <code>temp</code>.</p>
<p><strong>In Haskell</strong>:</p>
<div class="source-code"><pre><code class="language-haskell"><span class="va">combined</span><span> </span><span class="sy">=</span><span> </span><span class="va">addOne</span><span> </span><span class="op">.</span><span> </span><span class="va">double</span><span>
</span></code></pre></div>
<p>No intermediate variables, no manual wiring—just composition.</p>
<p>Notice how we didn&#39;t need to handle the arguments on these functions. We&#39;ve composed these functions together to give us a new function with the type signature <code>Int -&gt; Int</code>. This is a fairly simple example, but this concept applies to even the most complex of functions, making it much easier to combine functionality of multiple functions together in a type-safe manner.</p>
<h3 id="why-composability-matters">Why Composability Matters</h3>
<ol>
<li>
<strong>Safety</strong>: In Haskell, function composition works seamlessly because of the type system. The compiler ensures that the output type of one function matches the input type of the next. If there’s a mismatch, you’ll get a compile-time error.
</li>
<li>
<strong>Efficiency</strong>: Composability allows you to express complex logic succinctly, without introducing boilerplate code or intermediate state.
</li>
<li>
<strong>Team Collaboration</strong>: When working in teams, composable functions are easier to reason about and reuse. Each developer can focus on building small, pure functions that integrate seamlessly into the larger codebase.
</li>
<li>
<strong>Scalability</strong>: As projects grow, the ability to compose functions reduces complexity and encourages code reuse.
</li>
</ol>
<h3 id="the-operator-composition-reversed">The <code>(&gt;&gt;&gt;)</code> Operator: Composition Reversed</h3>
<p>Haskell also provides the <code>(&gt;&gt;&gt;)</code> operator for function composition, which is the reverse of <code>(.)</code>. Instead of reading functions from right to left, <code>(&gt;&gt;&gt;)</code> reads them from left to right.</p>
<div class="source-code"><pre><code class="language-haskell"><span class="sy">(</span><span class="op">&gt;&gt;&gt;</span><span class="sy">)</span><span> </span><span class="sy">::</span><span> </span><span class="sy">(</span><span class="va">a</span><span> </span><span class="sy">-&gt;</span><span> </span><span class="va">b</span><span class="sy">)</span><span> </span><span class="sy">-&gt;</span><span> </span><span class="sy">(</span><span class="va">b</span><span> </span><span class="sy">-&gt;</span><span> </span><span class="va">c</span><span class="sy">)</span><span> </span><span class="sy">-&gt;</span><span> </span><span class="va">a</span><span> </span><span class="sy">-&gt;</span><span> </span><span class="va">c</span><span>
</span></code></pre></div>
<p>Example:</p>
<div class="source-code"><pre><code class="language-haskell"><span class="kw">import</span><span> </span><span class="cr">Control.Arrow</span><span> </span><span class="sy">(</span><span class="op">&gt;&gt;&gt;</span><span class="sy">)</span><span>

</span><span class="va">combined</span><span> </span><span class="sy">=</span><span> </span><span class="va">double</span><span> </span><span class="op">&gt;&gt;&gt;</span><span> </span><span class="va">addOne</span><span>
</span><span class="va">main</span><span> </span><span class="sy">=</span><span> </span><span class="va">print</span><span> </span><span class="sy">(</span><span class="va">combined</span><span> </span><span class="it">3</span><span class="sy">)</span><span> </span><span class="co">-- Output: 7</span><span>
</span></code></pre></div>
<p>This is useful when you want to express a series of transformations in the same order they’re applied.</p>
<h3 id="realworld-example-processing-a-pipeline-of-transformations">Real-World Example: Processing a Pipeline of Transformations</h3>
<p>Imagine you’re building a data pipeline to process user inputs. The inputs must:</p>
<ol>
<li>
Be converted to lowercase.
</li>
<li>
Have whitespace trimmed.
</li>
<li>
Be validated for a specific pattern.
</li>
</ol>
<p>Instead of writing procedural code, you can compose the transformations:</p>
<div class="source-code"><pre><code class="language-haskell"><span class="kw">import</span><span> </span><span class="cr">Data.Char</span><span> </span><span class="sy">(</span><span class="va">toLower</span><span class="sy">)</span><span>
</span><span class="kw">import</span><span> </span><span class="cr">Data.List</span><span> </span><span class="sy">(</span><span class="va">isPrefixOf</span><span class="sy">)</span><span>

</span><span class="va">toLowerCase</span><span> </span><span class="sy">::</span><span> </span><span class="cr">String</span><span> </span><span class="sy">-&gt;</span><span> </span><span class="cr">String</span><span>
</span><span class="va">toLowerCase</span><span> </span><span class="sy">=</span><span> </span><span class="va">map</span><span> </span><span class="va">toLower</span><span>

</span><span class="va">trim</span><span> </span><span class="sy">::</span><span> </span><span class="cr">String</span><span> </span><span class="sy">-&gt;</span><span> </span><span class="cr">String</span><span>
</span><span class="va">trim</span><span> </span><span class="sy">=</span><span> </span><span class="va">unwords</span><span> </span><span class="op">.</span><span> </span><span class="va">words</span><span>

</span><span class="va">isValid</span><span> </span><span class="sy">::</span><span> </span><span class="cr">String</span><span> </span><span class="sy">-&gt;</span><span> </span><span class="cr">Bool</span><span>
</span><span class="va">isValid</span><span> </span><span class="va">input</span><span> </span><span class="sy">=</span><span> </span><span class="st">&quot;valid:&quot;</span><span> </span><span class="sy">`</span><span class="va">isPrefixOf</span><span class="sy">`</span><span> </span><span class="va">input</span><span>

</span><span class="va">process</span><span> </span><span class="sy">::</span><span> </span><span class="cr">String</span><span> </span><span class="sy">-&gt;</span><span> </span><span class="cr">Bool</span><span>
</span><span class="va">process</span><span> </span><span class="sy">=</span><span> </span><span class="va">isValid</span><span> </span><span class="op">.</span><span> </span><span class="va">trim</span><span> </span><span class="op">.</span><span> </span><span class="va">toLowerCase</span><span>

</span><span class="va">main</span><span> </span><span class="sy">::</span><span> </span><span class="cr">IO</span><span> </span><span class="sy">(</span><span class="sy">)</span><span>
</span><span class="va">main</span><span> </span><span class="sy">=</span><span> </span><span class="va">print</span><span> </span><span class="sy">(</span><span class="va">process</span><span> </span><span class="st">&quot;  VALID:example   &quot;</span><span class="sy">)</span><span> </span><span class="co">-- Output: True</span><span>
</span></code></pre></div>
<p>Here:</p>
<ul>
<li>
Each function performs a single task.
</li>
<li>
The <code>process</code> function composes them into a pipeline that’s easy to read and test.
</li>
</ul>
<h2 id="3-functors-mapping-over-contexts">3. Functors: Mapping Over Contexts</h2>
<p>Now that we understand function composition, let’s explore how we can combine functions when working with <strong>values in a context</strong>. This is where <strong>Functors</strong> come into play.</p>
<h3 id="what-is-a-functor">What is a Functor?</h3>
<p>At its core, a <strong>Functor</strong> is a type class that defines how to apply a function to a value that is &quot;wrapped&quot; in a context. The context could be a list, a <code>Maybe</code> value, or any other data structure.</p>
<p>To be a Functor, a type must implement the <code>fmap</code> function:</p>
<div class="source-code"><pre><code class="language-haskell"><span class="kw">class</span><span> </span><span class="cr">Functor</span><span> </span><span class="va">f</span><span> </span><span class="kw">where</span><span>
    </span><span class="va">fmap</span><span> </span><span class="sy">::</span><span> </span><span class="sy">(</span><span class="va">a</span><span> </span><span class="sy">-&gt;</span><span> </span><span class="va">b</span><span class="sy">)</span><span> </span><span class="sy">-&gt;</span><span> </span><span class="va">f</span><span> </span><span class="va">a</span><span> </span><span class="sy">-&gt;</span><span> </span><span class="va">f</span><span> </span><span class="va">b</span><span>
</span></code></pre></div>
<ul>
<li>
<code>(a -&gt; b)</code> is a function that transforms a value of type <code>a</code> into type <code>b</code>.
</li>
<li>
<code>f a</code> is the context (e.g., a list, <code>Maybe</code>, etc.) containing the value.
</li>
<li>
<code>f b</code> is the result of applying the function <code>(a -&gt; b)</code> to the value inside the context.
</li>
</ul>
<h4 id="demystifying-the-concept">Demystifying the Concept</h4>
<ul>
<li>
<strong>Mathematical Term</strong>: The word &quot;Functor&quot; comes from category theory. It’s just a formal way of describing how functions can be applied to values in a context.
</li>
<li>
<strong>Programming Insight</strong>: Think of <code>fmap</code> as a way to <strong>&quot;map&quot; a function over a value inside a container</strong>.
</li>
</ul>
<h3 id="examples-of-functors">Examples of Functors</h3>
<h4 id="example-1-lists-as-functors">Example 1: Lists as Functors</h4>
<p>A list is a classic example of a Functor. Let’s see how <code>fmap</code> works with lists:</p>
<div class="source-code"><pre><code class="language-haskell"><span class="va">fmap</span><span> </span><span class="sy">(</span><span class="sy">*</span><span class="it">2</span><span class="sy">)</span><span> </span><span class="sy">[</span><span class="it">1</span><span class="sy">,</span><span> </span><span class="it">2</span><span class="sy">,</span><span> </span><span class="it">3</span><span class="sy">]</span><span> </span><span class="co">-- Output: [2, 4, 6]</span><span>
</span></code></pre></div>
<p>Here:</p>
<ul>
<li>
The function <code>(*2)</code> is applied to each element of the list.
</li>
<li>
The result is a new list with the function applied to every element.
</li>
</ul>
<p>This is equivalent to using the map function in Haskell:</p>
<div class="source-code"><pre><code class="language-haskell"><span class="va">map</span><span> </span><span class="sy">(</span><span class="sy">*</span><span class="it">2</span><span class="sy">)</span><span> </span><span class="sy">[</span><span class="it">1</span><span class="sy">,</span><span> </span><span class="it">2</span><span class="sy">,</span><span> </span><span class="it">3</span><span class="sy">]</span><span> </span><span class="co">-- Output: [2, 4, 6]</span><span>
</span></code></pre></div>
<p>In fact, for lists, fmap and map are interchangeable because lists are an instance of the Functor type class.</p>
<blockquote>
<p>NOTE: <code>[]</code> is the <code>Functor</code> in this example, because it contains our values. If we observe the definition of <code>List</code> on Hoogle, we can see that it is <code>data List a</code> where <code>a</code> is polymorphic. <code>List</code> has an instance of the <code>Functor</code> type class, and so it inherits the <code>fmap</code> capability.</p>
</blockquote>
<h4 id="example-2-maybe-as-a-functor">Example 2: <code>Maybe</code> as a Functor</h4>
<p>The <code>Maybe</code> type is another common Functor. Let’s see how <code>fmap</code> works with <code>Maybe</code> values:</p>
<div class="source-code"><pre><code class="language-haskell"><span class="va">fmap</span><span> </span><span class="sy">(</span><span class="op">+</span><span class="it">1</span><span class="sy">)</span><span> </span><span class="sy">(</span><span class="cr">Just</span><span> </span><span class="it">5</span><span class="sy">)</span><span> </span><span class="co">-- Output: Just 6</span><span>
</span><span class="va">fmap</span><span> </span><span class="sy">(</span><span class="op">+</span><span class="it">1</span><span class="sy">)</span><span> </span><span class="cr">Nothing</span><span>  </span><span class="co">-- Output: Nothing</span><span>
</span></code></pre></div>
<p>Here:</p>
<ul>
<li>
The function <code>(+1)</code> is applied to the value <code>5</code> inside the <code>Just</code> context, producing <code>Just 6</code>.
</li>
<li>
If the context is <code>Nothing</code>, the function is not applied, and the result is still <code>Nothing</code>.
</li>
</ul>
<p>This ensures that we can work with optional values safely without manually checking for <code>Nothing</code> every time.</p>
<h4 id="example-3-combining-functions-with-fmap">Example 3: Combining Functions with <code>fmap</code></h4>
<p>Since functions themselves are Functors, we can compose functions within a context using <code>fmap</code>.</p>
<div class="source-code"><pre><code class="language-haskell"><span class="va">fmap</span><span> </span><span class="sy">(</span><span class="sy">*</span><span class="it">2</span><span class="sy">)</span><span> </span><span class="sy">(</span><span class="op">+</span><span class="it">3</span><span class="sy">)</span><span> </span><span class="it">5</span><span> </span><span class="co">-- Output: 16</span><span>
</span></code></pre></div>
<p>Here’s what’s happening:</p>
<ol>
<li>
<code>(+3)</code> is applied to <code>5</code>, resulting in <code>8</code>.
</li>
<li>
<code>(*2)</code> is applied to <code>8</code>, resulting in <code>16</code>.
</li>
</ol>
<h3 id="why-functors-are-important">Why Functors Are Important</h3>
<ol>
<li>
<strong>Abstracting Contexts</strong>: Functors allow us to write generic code that works with any context. Whether it’s a list, a <code>Maybe</code>, or something more complex, we can apply functions without worrying about the details of the context.
</li>
<li>
<strong>Composability</strong>: Functors enable function composition even when values are wrapped in a context. For example, you can chain operations on <code>Maybe</code> values without unwrapping and re-wrapping them.
</li>
<li>
<strong>Safety</strong>: Functors ensure that functions are applied safely within their contexts. For example, when working with <code>Maybe</code>, you don’t need to check for <code>Nothing</code> explicitly—<code>fmap</code> handles it for you.
</li>
</ol>
<h3 id="realworld-example-processing-user-input">Real-World Example: Processing User Input</h3>
<p>Imagine you’re working on a system that processes user input, which might be missing (<code>Nothing</code>). You want to:</p>
<ol>
<li>
Add a prefix (<code>&quot;User: &quot;</code>).
</li>
<li>
Convert the string to uppercase.
</li>
</ol>
<p>Here’s how you can do it with Functors:</p>
<div class="source-code"><pre><code class="language-haskell"><span class="kw">import</span><span> </span><span class="cr">Data.Char</span><span> </span><span class="sy">(</span><span class="va">toUpper</span><span class="sy">)</span><span>

</span><span class="va">addPrefix</span><span> </span><span class="sy">::</span><span> </span><span class="cr">String</span><span> </span><span class="sy">-&gt;</span><span> </span><span class="cr">String</span><span>
</span><span class="va">addPrefix</span><span> </span><span class="va">input</span><span> </span><span class="sy">=</span><span> </span><span class="st">&quot;User: &quot;</span><span> </span><span class="op">++</span><span> </span><span class="va">input</span><span>

</span><span class="va">toUpperCase</span><span> </span><span class="sy">::</span><span> </span><span class="cr">String</span><span> </span><span class="sy">-&gt;</span><span> </span><span class="cr">String</span><span>
</span><span class="va">toUpperCase</span><span> </span><span class="sy">=</span><span> </span><span class="va">map</span><span> </span><span class="va">toUpper</span><span>

</span><span class="va">processInput</span><span> </span><span class="sy">::</span><span> </span><span class="cr">Maybe</span><span> </span><span class="cr">String</span><span> </span><span class="sy">-&gt;</span><span> </span><span class="cr">Maybe</span><span> </span><span class="cr">String</span><span>
</span><span class="va">processInput</span><span> </span><span class="sy">=</span><span> </span><span class="va">fmap</span><span> </span><span class="va">toUpperCase</span><span> </span><span class="op">.</span><span> </span><span class="va">fmap</span><span> </span><span class="va">addPrefix</span><span>

</span><span class="va">main</span><span> </span><span class="sy">::</span><span> </span><span class="cr">IO</span><span> </span><span class="sy">(</span><span class="sy">)</span><span>
</span><span class="va">main</span><span> </span><span class="sy">=</span><span> </span><span class="kw">do</span><span>
    </span><span class="va">print</span><span> </span><span class="op">$</span><span> </span><span class="va">processInput</span><span> </span><span class="sy">(</span><span class="cr">Just</span><span> </span><span class="st">&quot;john&quot;</span><span class="sy">)</span><span>  </span><span class="co">-- Output: Just &quot;USER: JOHN&quot;</span><span>
    </span><span class="va">print</span><span> </span><span class="op">$</span><span> </span><span class="va">processInput</span><span> </span><span class="cr">Nothing</span><span>       </span><span class="co">-- Output: Nothing</span><span>
</span></code></pre></div>
<p>Key points:</p>
<ul>
<li>
Each transformation (<code>addPrefix</code> and <code>toUpperCase</code>) is composed using <code>fmap</code>.
</li>
<li>
The context (<code>Maybe</code>) ensures that no transformations are applied if the input is <code>Nothing</code>.
</li>
</ul>
<h3 id="functor-laws">Functor Laws</h3>
<p>To qualify as a Functor, a type must satisfy two laws. These laws ensure that Functors behave consistently and predictably.</p>
<ol>
<li>
<strong>Identity:</strong>
</li>
</ol>
<div class="source-code"><pre><code class="language-haskell"><span class="va">fmap</span><span> </span><span class="va">id</span><span> </span><span class="va">x</span><span> </span><span class="op">==</span><span> </span><span class="va">x</span><span>
</span></code></pre></div>
<p>Applying the identity function id with fmap should not change the Functor.</p>
<p>Example with lists:</p>
<div class="source-code"><pre><code class="language-haskell"><span class="va">fmap</span><span> </span><span class="va">id</span><span> </span><span class="sy">[</span><span class="it">1</span><span class="sy">,</span><span> </span><span class="it">2</span><span class="sy">,</span><span> </span><span class="it">3</span><span class="sy">]</span><span> </span><span class="op">==</span><span> </span><span class="sy">[</span><span class="it">1</span><span class="sy">,</span><span> </span><span class="it">2</span><span class="sy">,</span><span> </span><span class="it">3</span><span class="sy">]</span><span>
</span></code></pre></div>
<ol start="2">
<li>
<strong>Composition:</strong>
</li>
</ol>
<div class="source-code"><pre><code class="language-haskell"><span class="va">fmap</span><span> </span><span class="sy">(</span><span class="va">f</span><span> </span><span class="op">.</span><span> </span><span class="va">g</span><span class="sy">)</span><span> </span><span class="va">x</span><span> </span><span class="op">==</span><span> </span><span class="va">fmap</span><span> </span><span class="va">f</span><span> </span><span class="sy">(</span><span class="va">fmap</span><span> </span><span class="va">g</span><span> </span><span class="va">x</span><span class="sy">)</span><span>
</span></code></pre></div>
<p>Mapping the composition of two functions is the same as mapping them one after the other.</p>
<p>Example with <code>Maybe</code>:</p>
<div class="source-code"><pre><code class="language-haskell"><span class="va">fmap</span><span> </span><span class="sy">(</span><span class="sy">(</span><span class="sy">*</span><span class="it">2</span><span class="sy">)</span><span> </span><span class="op">.</span><span> </span><span class="sy">(</span><span class="op">+</span><span class="it">3</span><span class="sy">)</span><span class="sy">)</span><span> </span><span class="sy">(</span><span class="cr">Just</span><span> </span><span class="it">5</span><span class="sy">)</span><span> </span><span class="op">==</span><span> </span><span class="va">fmap</span><span> </span><span class="sy">(</span><span class="sy">*</span><span class="it">2</span><span class="sy">)</span><span> </span><span class="sy">(</span><span class="va">fmap</span><span> </span><span class="sy">(</span><span class="op">+</span><span class="it">3</span><span class="sy">)</span><span> </span><span class="sy">(</span><span class="cr">Just</span><span> </span><span class="it">5</span><span class="sy">)</span><span class="sy">)</span><span>
</span></code></pre></div>
<h2 id="4-monoids-combining-values-consistently">4. Monoids: Combining Values Consistently</h2>
<p>Now that we’ve explored Functors and how they enable function composition over contexts, let’s look at <strong>Monoids</strong>, which help us combine values in a consistent, predictable way.
Monoids are another fundamental concept in functional programming and mathematics. They provide a framework for combining values using a binary operation (like addition or concatenation) while ensuring the operation behaves consistently across all values.</p>
<h3 id="what-is-a-monoid">What is a Monoid?</h3>
<p>A <strong>Monoid</strong> is a type class that defines:</p>
<ol>
<li>
A <strong>binary operation</strong> (<code>mappend</code> or <code>&lt;&gt;</code> in Haskell) to combine two values.
</li>
<li>
An <strong>identity element</strong> (<code>mempty</code>) that acts as a neutral value for the operation.
</li>
</ol>
<p>Here’s how Haskell defines the Monoid type class:</p>
<div class="source-code"><pre><code class="language-haskell"><span class="kw">class</span><span> </span><span class="cr">Monoid</span><span> </span><span class="va">m</span><span> </span><span class="kw">where</span><span>
    </span><span class="va">mempty</span><span>  </span><span class="sy">::</span><span> </span><span class="va">m</span><span>
    </span><span class="va">mappend</span><span> </span><span class="sy">::</span><span> </span><span class="va">m</span><span> </span><span class="sy">-&gt;</span><span> </span><span class="va">m</span><span> </span><span class="sy">-&gt;</span><span> </span><span class="va">m</span><span>
    </span><span class="co">-- In modern Haskell, (&lt;&gt;) is preferred over mappend</span><span>
    </span><span class="sy">(</span><span class="op">&lt;&gt;</span><span class="sy">)</span><span>    </span><span class="sy">::</span><span> </span><span class="va">m</span><span> </span><span class="sy">-&gt;</span><span> </span><span class="va">m</span><span> </span><span class="sy">-&gt;</span><span> </span><span class="va">m</span><span>
    </span><span class="sy">(</span><span class="op">&lt;&gt;</span><span class="sy">)</span><span> </span><span class="sy">=</span><span> </span><span class="va">mappend</span><span>
</span></code></pre></div>
<h3 id="key-properties-of-monoids">Key Properties of Monoids</h3>
<p>To qualify as a Monoid, a type must satisfy the following laws:</p>
<ol>
<li>
<strong>Identity Law:</strong>
</li>
</ol>
<div class="source-code"><pre><code class="language-haskell"><span class="va">x</span><span> </span><span class="op">&lt;&gt;</span><span> </span><span class="va">mempty</span><span> </span><span class="op">==</span><span> </span><span class="va">x</span><span>
</span><span class="va">mempty</span><span> </span><span class="op">&lt;&gt;</span><span> </span><span class="va">x</span><span> </span><span class="op">==</span><span> </span><span class="va">x</span><span>
</span></code></pre></div>
<p>Combining any value with mempty must return the original value.</p>
<ol>
<li>
<strong>Associativity Law:</strong>
</li>
</ol>
<div class="source-code"><pre><code class="language-haskell"><span class="sy">(</span><span class="va">x</span><span> </span><span class="op">&lt;&gt;</span><span> </span><span class="va">y</span><span class="sy">)</span><span> </span><span class="op">&lt;&gt;</span><span> </span><span class="va">z</span><span> </span><span class="op">==</span><span> </span><span class="va">x</span><span> </span><span class="op">&lt;&gt;</span><span> </span><span class="sy">(</span><span class="va">y</span><span> </span><span class="op">&lt;&gt;</span><span> </span><span class="va">z</span><span class="sy">)</span><span>
</span></code></pre></div>
<p>The order in which you group operations doesn’t matter.</p>
<h3 id="examples-of-monoids">Examples of Monoids</h3>
<h4 id="example-1-lists">Example 1: Lists</h4>
<p>Lists are the most basic example of a Monoid. For lists:</p>
<ul>
<li>
<code>mempty</code> is the empty list <code>[]</code>.
</li>
<li>
<code>&lt;&gt;</code> is list concatenation (<code>++</code>).
</li>
</ul>
<div class="source-code"><pre><code class="language-haskell"><span class="va">mempty</span><span> </span><span class="sy">::</span><span> </span><span class="sy">[</span><span class="va">a</span><span class="sy">]</span><span>
</span><span class="va">mempty</span><span> </span><span class="sy">=</span><span> </span><span class="sy">[</span><span class="sy">]</span><span>

</span><span class="sy">(</span><span class="op">&lt;&gt;</span><span class="sy">)</span><span> </span><span class="sy">::</span><span> </span><span class="sy">[</span><span class="va">a</span><span class="sy">]</span><span> </span><span class="sy">-&gt;</span><span> </span><span class="sy">[</span><span class="va">a</span><span class="sy">]</span><span> </span><span class="sy">-&gt;</span><span> </span><span class="sy">[</span><span class="va">a</span><span class="sy">]</span><span>
</span><span class="va">xs</span><span> </span><span class="op">&lt;&gt;</span><span> </span><span class="va">ys</span><span> </span><span class="sy">=</span><span> </span><span class="va">xs</span><span> </span><span class="op">++</span><span> </span><span class="va">ys</span><span>
</span></code></pre></div>
<p>Example:</p>
<div class="source-code"><pre><code class="language-haskell"><span class="sy">[</span><span class="it">1</span><span class="sy">,</span><span> </span><span class="it">2</span><span class="sy">]</span><span> </span><span class="op">&lt;&gt;</span><span> </span><span class="sy">[</span><span class="it">3</span><span class="sy">,</span><span> </span><span class="it">4</span><span class="sy">]</span><span> </span><span class="co">-- Output: [1, 2, 3, 4]</span><span>
</span><span class="va">mempty</span><span> </span><span class="op">&lt;&gt;</span><span> </span><span class="sy">[</span><span class="it">1</span><span class="sy">,</span><span> </span><span class="it">2</span><span class="sy">]</span><span> </span><span class="co">-- Output: [1, 2]</span><span>
</span><span class="sy">[</span><span class="it">1</span><span class="sy">,</span><span> </span><span class="it">2</span><span class="sy">]</span><span> </span><span class="op">&lt;&gt;</span><span> </span><span class="va">mempty</span><span> </span><span class="co">-- Output: [1, 2]</span><span>
</span></code></pre></div>
<p>The identity and associativity laws hold naturally:</p>
<ul>
<li>
Combining any list with <code>[]</code> leaves it unchanged.
</li>
<li>
Grouping doesn’t matter for concatenation.
</li>
</ul>
<h4 id="example-2-numbers-with-addition">Example 2: Numbers with Addition</h4>
<p>Numbers can also form a Monoid under addition:</p>
<ul>
<li>
<code>mempty</code> is <code>0</code>.
</li>
<li>
<code>&lt;&gt;</code> is <code>(+)</code>.
</li>
</ul>
<div class="source-code"><pre><code class="language-haskell"><span class="va">mempty</span><span> </span><span class="sy">::</span><span> </span><span class="cr">Int</span><span>
</span><span class="va">mempty</span><span> </span><span class="sy">=</span><span> </span><span class="it">0</span><span>

</span><span class="sy">(</span><span class="op">&lt;&gt;</span><span class="sy">)</span><span> </span><span class="sy">::</span><span> </span><span class="cr">Int</span><span> </span><span class="sy">-&gt;</span><span> </span><span class="cr">Int</span><span> </span><span class="sy">-&gt;</span><span> </span><span class="cr">Int</span><span>
</span><span class="va">x</span><span> </span><span class="op">&lt;&gt;</span><span> </span><span class="va">y</span><span> </span><span class="sy">=</span><span> </span><span class="va">x</span><span> </span><span class="op">+</span><span> </span><span class="va">y</span><span>
</span></code></pre></div>
<p>Example:</p>
<div class="source-code"><pre><code class="language-haskell"><span class="it">5</span><span> </span><span class="op">&lt;&gt;</span><span> </span><span class="it">10</span><span> </span><span class="co">-- Output: 15</span><span>
</span><span class="va">mempty</span><span> </span><span class="op">&lt;&gt;</span><span> </span><span class="it">5</span><span> </span><span class="co">-- Output: 5</span><span>
</span></code></pre></div>
<p>The laws hold:</p>
<ul>
<li>
Adding <code>0</code> to any number doesn’t change it.
</li>
<li>
Grouping doesn’t affect the result of addition.
</li>
</ul>
<h4 id="example-3-numbers-with-multiplication">Example 3: Numbers with Multiplication</h4>
<p>Numbers can also form a Monoid under multiplication:</p>
<ul>
<li>
<code>mempty</code> is <code>1</code>.
</li>
<li>
<code>&lt;&gt;</code> is <code>(*)</code>.
</li>
</ul>
<div class="source-code"><pre><code class="language-haskell"><span class="va">mempty</span><span> </span><span class="sy">::</span><span> </span><span class="cr">Int</span><span>
</span><span class="va">mempty</span><span> </span><span class="sy">=</span><span> </span><span class="it">1</span><span>

</span><span class="sy">(</span><span class="op">&lt;&gt;</span><span class="sy">)</span><span> </span><span class="sy">::</span><span> </span><span class="cr">Int</span><span> </span><span class="sy">-&gt;</span><span> </span><span class="cr">Int</span><span> </span><span class="sy">-&gt;</span><span> </span><span class="cr">Int</span><span>
</span><span class="va">x</span><span> </span><span class="op">&lt;&gt;</span><span> </span><span class="va">y</span><span> </span><span class="sy">=</span><span> </span><span class="va">x</span><span> </span><span class="sy">*</span><span> </span><span class="va">y</span><span>
</span></code></pre></div>
<p>Example:</p>
<div class="source-code"><pre><code class="language-haskell"><span class="it">5</span><span> </span><span class="op">&lt;&gt;</span><span> </span><span class="it">10</span><span> </span><span class="co">-- Output: 50</span><span>
</span><span class="va">mempty</span><span> </span><span class="op">&lt;&gt;</span><span> </span><span class="it">5</span><span> </span><span class="co">-- Output: 5</span><span>
</span></code></pre></div>
<h4 id="example-4-combining-boolean-values">Example 4: Combining Boolean Values</h4>
<p>Booleans can form Monoids under different operations, such as <strong>AND</strong> and <strong>OR</strong>.</p>
<ul>
<li>
For <strong>AND</strong>:
<ul>
<li>
<code>mempty</code> is <code>True</code>.
</li>
<li>
<code>&lt;&gt;</code> is <code>(&amp;&amp;)</code>.
</li>
</ul>
</li>
<li>
For <strong>OR</strong>:
<ul>
<li>
<code>mempty</code> is <code>False</code>.
</li>
<li>
<code>&lt;&gt;</code> is <code>(||)</code>.
</li>
</ul>
</li>
</ul>
<p>Examples:</p>
<div class="source-code"><pre><code class="language-haskell"><span class="co">-- AND Monoid</span><span>
</span><span class="cr">True</span><span> </span><span class="op">&lt;&gt;</span><span> </span><span class="cr">False</span><span> </span><span class="co">-- Output: False</span><span>
</span><span class="cr">True</span><span> </span><span class="op">&lt;&gt;</span><span> </span><span class="cr">True</span><span>  </span><span class="co">-- Output: True</span><span>

</span><span class="co">-- OR Monoid</span><span>
</span><span class="cr">False</span><span> </span><span class="op">&lt;&gt;</span><span> </span><span class="cr">True</span><span>  </span><span class="co">-- Output: True</span><span>
</span><span class="cr">False</span><span> </span><span class="op">&lt;&gt;</span><span> </span><span class="cr">False</span><span> </span><span class="co">-- Output: False</span><span>
</span></code></pre></div>
<h3 id="why-monoids-matter">Why Monoids Matter</h3>
<ol>
<li>
<strong>Consistency in Combining Values:</strong> Monoids provide a consistent way to combine values, whether they’re lists, numbers, or custom data types.
</li>
<li>
<strong>Generality:</strong> Monoids are abstract, meaning you can write code that works with any Monoid, regardless of the specific type.
</li>
<li>
<strong>Composability:</strong> Monoids enable composition at a higher level. You can combine multiple values, or even collections of values, using the same interface (<code>mempty</code> and <code>&lt;&gt;</code>).
</li>
<li>
<strong>Parallelism:</strong> The associativity law makes Monoids particularly useful in parallel processing, where operations can be grouped and computed independently.
</li>
</ol>
<h3 id="realworld-example-combining-logs">Real-World Example: Combining Logs</h3>
<p>Imagine you’re building a logging system where logs are represented as lists of strings. You want to combine multiple logs into a single log.</p>
<div class="source-code"><pre><code class="language-haskell"><span class="va">combineLogs</span><span> </span><span class="sy">::</span><span> </span><span class="sy">[</span><span class="cr">String</span><span class="sy">]</span><span> </span><span class="sy">-&gt;</span><span> </span><span class="sy">[</span><span class="cr">String</span><span class="sy">]</span><span> </span><span class="sy">-&gt;</span><span> </span><span class="sy">[</span><span class="cr">String</span><span class="sy">]</span><span>
</span><span class="va">combineLogs</span><span> </span><span class="sy">=</span><span> </span><span class="sy">(</span><span class="op">&lt;&gt;</span><span class="sy">)</span><span>

</span><span class="va">main</span><span> </span><span class="sy">::</span><span> </span><span class="cr">IO</span><span> </span><span class="sy">(</span><span class="sy">)</span><span>
</span><span class="va">main</span><span> </span><span class="sy">=</span><span> </span><span class="kw">do</span><span>
    </span><span class="kw">let</span><span> </span><span class="va">log1</span><span> </span><span class="sy">=</span><span> </span><span class="sy">[</span><span class="st">&quot;Started application&quot;</span><span class="sy">]</span><span>
    </span><span class="kw">let</span><span> </span><span class="va">log2</span><span> </span><span class="sy">=</span><span> </span><span class="sy">[</span><span class="st">&quot;User logged in&quot;</span><span class="sy">]</span><span>
    </span><span class="kw">let</span><span> </span><span class="va">log3</span><span> </span><span class="sy">=</span><span> </span><span class="sy">[</span><span class="st">&quot;Error: Database unavailable&quot;</span><span class="sy">]</span><span>

    </span><span class="va">print</span><span> </span><span class="op">$</span><span> </span><span class="va">log1</span><span> </span><span class="op">&lt;&gt;</span><span> </span><span class="va">log2</span><span> </span><span class="op">&lt;&gt;</span><span> </span><span class="va">log3</span><span>
    </span><span class="co">-- Output: [&quot;Started application&quot;, &quot;User logged in&quot;, &quot;Error: Database unavailable&quot;]</span><span>
</span></code></pre></div>
<p>Here:</p>
<ul>
<li>
The <code>&lt;&gt;</code> operator combines logs seamlessly.
</li>
<li>
The empty log (<code>mempty</code>) doesn’t affect the result.
</li>
</ul>
<h3 id="using-monoids-with-fold">Using Monoids with <code>fold</code></h3>
<p>Monoids are incredibly powerful when used with folds, allowing you to reduce collections of values in a consistent way.</p>
<h4 id="example-summing-a-list">Example: Summing a List</h4>
<div class="source-code"><pre><code class="language-haskell"><span class="va">sumList</span><span> </span><span class="sy">::</span><span> </span><span class="sy">[</span><span class="cr">Int</span><span class="sy">]</span><span> </span><span class="sy">-&gt;</span><span> </span><span class="cr">Int</span><span>
</span><span class="va">sumList</span><span> </span><span class="sy">=</span><span> </span><span class="va">foldr</span><span> </span><span class="sy">(</span><span class="op">&lt;&gt;</span><span class="sy">)</span><span> </span><span class="va">mempty</span><span>
</span></code></pre></div>
<p>This works because <code>Int</code> is a Monoid under addition.</p>
<h4 id="example-concatenating-logs">Example: Concatenating Logs</h4>
<div class="source-code"><pre><code class="language-haskell"><span class="va">concatLogs</span><span> </span><span class="sy">::</span><span> </span><span class="sy">[</span><span class="sy">[</span><span class="cr">String</span><span class="sy">]</span><span class="sy">]</span><span> </span><span class="sy">-&gt;</span><span> </span><span class="sy">[</span><span class="cr">String</span><span class="sy">]</span><span>
</span><span class="va">concatLogs</span><span> </span><span class="sy">=</span><span> </span><span class="va">foldr</span><span> </span><span class="sy">(</span><span class="op">&lt;&gt;</span><span class="sy">)</span><span> </span><span class="va">mempty</span><span>
</span></code></pre></div>
<h4 id="example-aggregating-financial-transactions">Example: Aggregating Financial Transactions</h4>
<ol>
<li>
Define a data type for a transaction.
</li>
</ol>
<div class="source-code"><pre><code class="language-haskell"><span class="kw">data</span><span> </span><span class="cr">Transaction</span><span> </span><span class="sy">=</span><span> </span><span class="cr">Transaction</span><span>
    </span><span class="sy">{</span><span> </span><span class="va">totalAmount</span><span> </span><span class="sy">::</span><span> </span><span class="cr">Double</span><span>
    </span><span class="sy">,</span><span> </span><span class="va">itemCount</span><span>   </span><span class="sy">::</span><span> </span><span class="cr">Int</span><span>
    </span><span class="sy">,</span><span> </span><span class="va">comments</span><span>    </span><span class="sy">::</span><span> </span><span class="sy">[</span><span class="cr">String</span><span class="sy">]</span><span>
    </span><span class="sy">}</span><span> </span><span class="kw">deriving</span><span> </span><span class="sy">(</span><span class="cr">Show</span><span class="sy">)</span><span>
</span></code></pre></div>
<ol start="2">
<li>
Define a custom instance of <code>Monoid</code> for <code>Transaction</code>
</li>
</ol>
<div class="source-code"><pre><code class="language-haskell"><span class="kw">import</span><span> </span><span class="cr">Data.Monoid</span><span> </span><span class="sy">(</span><span class="cr">Monoid</span><span class="sy">(</span><span class="sy">..</span><span class="sy">)</span><span class="sy">)</span><span>

</span><span class="kw">instance</span><span> </span><span class="cr">Semigroup</span><span> </span><span class="cr">Transaction</span><span> </span><span class="kw">where</span><span>
    </span><span class="sy">(</span><span class="op">&lt;&gt;</span><span class="sy">)</span><span> </span><span class="sy">(</span><span class="cr">Transaction</span><span> </span><span class="va">amt1</span><span> </span><span class="va">count1</span><span> </span><span class="va">comms1</span><span class="sy">)</span><span> </span><span class="sy">(</span><span class="cr">Transaction</span><span> </span><span class="va">amt2</span><span> </span><span class="va">count2</span><span> </span><span class="va">comms2</span><span class="sy">)</span><span> </span><span class="sy">=</span><span>
        </span><span class="cr">Transaction</span><span> </span><span class="sy">(</span><span class="va">amt1</span><span> </span><span class="op">+</span><span> </span><span class="va">amt2</span><span class="sy">)</span><span> </span><span class="sy">(</span><span class="va">count1</span><span> </span><span class="op">+</span><span> </span><span class="va">count2</span><span class="sy">)</span><span> </span><span class="sy">(</span><span class="va">comms1</span><span> </span><span class="op">&lt;&gt;</span><span> </span><span class="va">comms2</span><span class="sy">)</span><span>

</span><span class="kw">instance</span><span> </span><span class="cr">Monoid</span><span> </span><span class="cr">Transaction</span><span> </span><span class="kw">where</span><span>
    </span><span class="va">mempty</span><span> </span><span class="sy">=</span><span> </span><span class="cr">Transaction</span><span> </span><span class="it">0</span><span> </span><span class="it">0</span><span> </span><span class="sy">[</span><span class="sy">]</span><span>
</span></code></pre></div>
<ol start="3">
<li>
Combine the transactions
</li>
</ol>
<div class="source-code"><pre><code class="language-haskell"><span class="va">transactions</span><span> </span><span class="sy">::</span><span> </span><span class="sy">[</span><span class="cr">Transaction</span><span class="sy">]</span><span>
</span><span class="va">transactions</span><span> </span><span class="sy">=</span><span>
    </span><span class="sy">[</span><span> </span><span class="cr">Transaction</span><span> </span><span class="ra">100.0</span><span> </span><span class="it">2</span><span> </span><span class="sy">[</span><span class="st">&quot;Purchase: Electronics&quot;</span><span class="sy">]</span><span>
    </span><span class="sy">,</span><span> </span><span class="cr">Transaction</span><span> </span><span class="ra">200.0</span><span> </span><span class="it">3</span><span> </span><span class="sy">[</span><span class="st">&quot;Purchase: Furniture&quot;</span><span class="sy">]</span><span>
    </span><span class="sy">,</span><span> </span><span class="cr">Transaction</span><span> </span><span class="ra">50.0</span><span> </span><span class="it">1</span><span> </span><span class="sy">[</span><span class="st">&quot;Purchase: Groceries&quot;</span><span class="sy">]</span><span>
    </span><span class="sy">]</span><span>

</span><span class="va">aggregateTransactions</span><span> </span><span class="sy">::</span><span> </span><span class="sy">[</span><span class="cr">Transaction</span><span class="sy">]</span><span> </span><span class="sy">-&gt;</span><span> </span><span class="cr">Transaction</span><span>
</span><span class="va">aggregateTransactions</span><span> </span><span class="sy">=</span><span> </span><span class="va">mconcat</span><span>

</span><span class="va">main</span><span> </span><span class="sy">::</span><span> </span><span class="cr">IO</span><span> </span><span class="sy">(</span><span class="sy">)</span><span>
</span><span class="va">main</span><span> </span><span class="sy">=</span><span> </span><span class="va">print</span><span> </span><span class="op">$</span><span> </span><span class="va">aggregateTransactions</span><span> </span><span class="va">transactions</span><span>

</span><span class="co">-- output:</span><span>
</span><span class="co">-- Transaction</span><span>
</span><span class="co">--     { totalAmount = 350.0</span><span>
</span><span class="co">--     , itemCount = 6</span><span>
</span><span class="co">--     , comments = [&quot;Purchase: Electronics&quot;, &quot;Purchase: Furniture&quot;, &quot;Purchase: Groceries&quot;]</span><span>
</span><span class="co">--     }</span><span>
</span></code></pre></div>
<ol start="4">
<li>
You can reduce the list using <code>fold</code> with <code>(&lt;&gt;)</code>
</li>
</ol>
<div class="source-code"><pre><code class="language-haskell"><span class="va">aggregateTransactions</span><span> </span><span class="sy">::</span><span> </span><span class="sy">[</span><span class="cr">Transaction</span><span class="sy">]</span><span> </span><span class="sy">-&gt;</span><span> </span><span class="cr">Transaction</span><span>
</span><span class="va">aggregateTransactions</span><span> </span><span class="va">txs</span><span> </span><span class="sy">=</span><span> </span><span class="va">foldr</span><span> </span><span class="sy">(</span><span class="op">&lt;&gt;</span><span class="sy">)</span><span> </span><span class="va">mempty</span><span> </span><span class="va">txs</span><span>
</span></code></pre></div>
<h2 id="5-semigroups-combining-values-without-an-identity">5. Semigroups: Combining Values Without an Identity</h2>
<p>Before diving into Monads, let’s explore <strong>Semigroups</strong> — a simpler abstraction that focuses on combining values. Semigroups are closely related to Monoids, but with a key difference: they don’t require an <strong>identity element</strong>. This makes them useful in scenarios where combining values is important, but an &quot;empty&quot; value doesn’t make sense or isn’t needed.</p>
<h3 id="what-is-a-semigroup">What is a Semigroup?</h3>
<p>A <strong>Semigroup</strong> is a type class that defines a single operation, <code>(&lt;&gt;):</code></p>
<div class="source-code"><pre><code class="language-haskell"><span class="kw">class</span><span> </span><span class="cr">Semigroup</span><span> </span><span class="va">a</span><span> </span><span class="kw">where</span><span>
    </span><span class="sy">(</span><span class="op">&lt;&gt;</span><span class="sy">)</span><span> </span><span class="sy">::</span><span> </span><span class="va">a</span><span> </span><span class="sy">-&gt;</span><span> </span><span class="va">a</span><span> </span><span class="sy">-&gt;</span><span> </span><span class="va">a</span><span>
</span></code></pre></div>
<p>This operation takes two values of the same type and combines them into one. To qualify as a Semigroup, the operation must satisfy the associativity law:</p>
<ul>
<li>
<strong>Associativity</strong>:
</li>
</ul>
<div class="source-code"><pre><code class="language-haskell"><span class="sy">(</span><span class="va">x</span><span> </span><span class="op">&lt;&gt;</span><span> </span><span class="va">y</span><span class="sy">)</span><span> </span><span class="op">&lt;&gt;</span><span> </span><span class="va">z</span><span> </span><span class="op">==</span><span> </span><span class="va">x</span><span> </span><span class="op">&lt;&gt;</span><span> </span><span class="sy">(</span><span class="va">y</span><span> </span><span class="op">&lt;&gt;</span><span> </span><span class="va">z</span><span class="sy">)</span><span>
</span></code></pre></div>
<p>The order in which operations are grouped doesn’t matter.</p>
<h3 id="how-semigroups-relate-to-monoids">How Semigroups Relate to Monoids</h3>
<ul>
<li>
<strong>Semigroups</strong>: Define a combining operation but don’t require an identity (<code>mempty</code>).
</li>
<li>
<strong>Monoids</strong> Extend Semigroups by adding an identity element.
</li>
</ul>
<h3 id="examples-of-semigroups">Examples of Semigroups</h3>
<h4 id="example-1-lists">Example 1: Lists</h4>
<p>Lists are the canonical example of a Semigroup. The <code>(++)</code> operator combines two lists, and it’s associative:</p>
<div class="source-code"><pre><code class="language-haskell"><span class="sy">[</span><span class="it">1</span><span class="sy">,</span><span> </span><span class="it">2</span><span class="sy">]</span><span> </span><span class="op">&lt;&gt;</span><span> </span><span class="sy">[</span><span class="it">3</span><span class="sy">,</span><span> </span><span class="it">4</span><span class="sy">]</span><span> </span><span class="op">&lt;&gt;</span><span> </span><span class="sy">[</span><span class="it">5</span><span class="sy">]</span><span> </span><span class="op">==</span><span> </span><span class="sy">[</span><span class="it">1</span><span class="sy">,</span><span> </span><span class="it">2</span><span class="sy">]</span><span> </span><span class="op">&lt;&gt;</span><span> </span><span class="sy">(</span><span class="sy">[</span><span class="it">3</span><span class="sy">,</span><span> </span><span class="it">4</span><span class="sy">]</span><span> </span><span class="op">&lt;&gt;</span><span> </span><span class="sy">[</span><span class="it">5</span><span class="sy">]</span><span class="sy">)</span><span>
</span><span class="co">-- Output: [1, 2, 3, 4, 5]</span><span>
</span></code></pre></div>
<p>Since lists have an identity element (<code>[]</code>), they’re also Monoids, but <code>(++)</code> works perfectly as a Semigroup operation.</p>
<h4 id="example-2-numbers-with-maximum-or-minimum">Example 2: Numbers with Maximum or Minimum</h4>
<p>Numbers can form Semigroups under operations like <strong>maximum</strong> or <strong>minimum</strong>, which combine two numbers by selecting the largest or smallest value, respectively.</p>
<div class="source-code"><pre><code class="language-haskell"><span class="kw">import</span><span> </span><span class="cr">Data.Semigroup</span><span> </span><span class="sy">(</span><span class="cr">Max</span><span class="sy">(</span><span class="sy">..</span><span class="sy">)</span><span class="sy">,</span><span> </span><span class="cr">Min</span><span class="sy">(</span><span class="sy">..</span><span class="sy">)</span><span class="sy">)</span><span>

</span><span class="va">main</span><span> </span><span class="sy">::</span><span> </span><span class="cr">IO</span><span> </span><span class="sy">(</span><span class="sy">)</span><span>
</span><span class="va">main</span><span> </span><span class="sy">=</span><span> </span><span class="kw">do</span><span>
    </span><span class="va">print</span><span> </span><span class="op">$</span><span> </span><span class="cr">Max</span><span> </span><span class="it">10</span><span> </span><span class="op">&lt;&gt;</span><span> </span><span class="cr">Max</span><span> </span><span class="it">20</span><span> </span><span class="co">-- Output: Max {getMax = 20}</span><span>
    </span><span class="va">print</span><span> </span><span class="op">$</span><span> </span><span class="cr">Min</span><span> </span><span class="it">10</span><span> </span><span class="op">&lt;&gt;</span><span> </span><span class="cr">Min</span><span> </span><span class="it">20</span><span> </span><span class="co">-- Output: Min {getMin = 10}</span><span>
</span></code></pre></div>
<p>Here:</p>
<ul>
<li>
<code>Max</code> and <code>Min</code> are wrappers provided by the <code>Data.Semigroup</code> module.
</li>
<li>
<code>(&lt;&gt;)</code> combines the wrapped values by applying <code>max</code> or <code>min</code>.
</li>
</ul>
<h4 id="example-3-combining-text-with-precedence">Example 3: Combining Text with Precedence</h4>
<p>Imagine combining strings, where we only keep the <strong>first non-empty string</strong>. This can be modeled as a Semigroup:</p>
<div class="source-code"><pre><code class="language-haskell"><span class="kw">import</span><span> </span><span class="cr">Data.Semigroup</span><span> </span><span class="sy">(</span><span class="cr">First</span><span class="sy">(</span><span class="sy">..</span><span class="sy">)</span><span class="sy">)</span><span>

</span><span class="va">main</span><span> </span><span class="sy">::</span><span> </span><span class="cr">IO</span><span> </span><span class="sy">(</span><span class="sy">)</span><span>
</span><span class="va">main</span><span> </span><span class="sy">=</span><span> </span><span class="kw">do</span><span>
    </span><span class="va">print</span><span> </span><span class="op">$</span><span> </span><span class="cr">First</span><span> </span><span class="sy">(</span><span class="cr">Just</span><span> </span><span class="st">&quot;Hello&quot;</span><span class="sy">)</span><span> </span><span class="op">&lt;&gt;</span><span> </span><span class="cr">First</span><span> </span><span class="sy">(</span><span class="cr">Just</span><span> </span><span class="st">&quot;World&quot;</span><span class="sy">)</span><span> </span><span class="co">-- Output: First {getFirst = Just &quot;Hello&quot;}</span><span>
    </span><span class="va">print</span><span> </span><span class="op">$</span><span> </span><span class="cr">First</span><span> </span><span class="cr">Nothing</span><span> </span><span class="op">&lt;&gt;</span><span> </span><span class="cr">First</span><span> </span><span class="sy">(</span><span class="cr">Just</span><span> </span><span class="st">&quot;World&quot;</span><span class="sy">)</span><span>       </span><span class="co">-- Output: First {getFirst = Just &quot;World&quot;}</span><span>
</span></code></pre></div>
<p>Here:</p>
<ul>
<li>
<code>First</code> is a Semigroup that chooses the first non-<code>Nothing</code> value when combining.
</li>
</ul>
<h3 id="why-semigroups-matter">Why Semigroups Matter</h3>
<ol>
<li>
<strong>Simplicity</strong>: Semigroups provide a minimal abstraction for combining values, without the need for an identity element.
</li>
<li>
<strong>Flexibility</strong>: Many types are naturally Semigroups but not Monoids (e.g., there’s no &quot;empty&quot; value for <code>Max</code> or <code>Min</code>).
</li>
<li>
<strong>Building Blocks</strong>: Semigroups are often used as a foundation for more complex abstractions like Monoids and Applicatives.
</li>
</ol>
<h3 id="realworld-example-combining-discounts">Real-World Example: Combining Discounts</h3>
<p>Imagine you’re building a shopping cart system that applies discounts. Discounts are represented as percentages, and when combining multiple discounts, you take the larger one (e.g., between 20% and 30%, you choose 30%).</p>
<div class="source-code"><pre><code class="language-haskell"><span class="kw">import</span><span> </span><span class="cr">Data.Semigroup</span><span> </span><span class="sy">(</span><span class="cr">Max</span><span class="sy">(</span><span class="sy">..</span><span class="sy">)</span><span class="sy">)</span><span>

</span><span class="kw">data</span><span> </span><span class="cr">Discount</span><span> </span><span class="sy">=</span><span> </span><span class="cr">Discount</span><span> </span><span class="sy">{</span><span> </span><span class="va">getDiscount</span><span> </span><span class="sy">::</span><span> </span><span class="cr">Max</span><span> </span><span class="cr">Int</span><span> </span><span class="sy">}</span><span>
    </span><span class="kw">deriving</span><span> </span><span class="sy">(</span><span class="cr">Show</span><span class="sy">)</span><span>

</span><span class="va">combineDiscounts</span><span> </span><span class="sy">::</span><span> </span><span class="cr">Discount</span><span> </span><span class="sy">-&gt;</span><span> </span><span class="cr">Discount</span><span> </span><span class="sy">-&gt;</span><span> </span><span class="cr">Discount</span><span>
</span><span class="va">combineDiscounts</span><span> </span><span class="sy">(</span><span class="cr">Discount</span><span> </span><span class="va">d1</span><span class="sy">)</span><span> </span><span class="sy">(</span><span class="cr">Discount</span><span> </span><span class="va">d2</span><span class="sy">)</span><span> </span><span class="sy">=</span><span> </span><span class="cr">Discount</span><span> </span><span class="sy">(</span><span class="va">d1</span><span> </span><span class="op">&lt;&gt;</span><span> </span><span class="va">d2</span><span class="sy">)</span><span>

</span><span class="va">main</span><span> </span><span class="sy">::</span><span> </span><span class="cr">IO</span><span> </span><span class="sy">(</span><span class="sy">)</span><span>
</span><span class="va">main</span><span> </span><span class="sy">=</span><span> </span><span class="kw">do</span><span>
    </span><span class="kw">let</span><span> </span><span class="va">discount1</span><span> </span><span class="sy">=</span><span> </span><span class="cr">Discount</span><span> </span><span class="sy">(</span><span class="cr">Max</span><span> </span><span class="it">20</span><span class="sy">)</span><span>
    </span><span class="kw">let</span><span> </span><span class="va">discount2</span><span> </span><span class="sy">=</span><span> </span><span class="cr">Discount</span><span> </span><span class="sy">(</span><span class="cr">Max</span><span> </span><span class="it">30</span><span class="sy">)</span><span>
    </span><span class="va">print</span><span> </span><span class="op">$</span><span> </span><span class="va">combineDiscounts</span><span> </span><span class="va">discount1</span><span> </span><span class="va">discount2</span><span> </span><span class="co">-- Output: Discount {getDiscount = Max {getMax = 30}}</span><span>
</span></code></pre></div>
<p>Here:</p>
<ul>
<li>
Discounts are modeled as <code>Max Int</code> to ensure that the larger discount is always chosen.
</li>
<li>
The Semigroup instance for <code>Max</code> handles the combining logic seamlessly.
</li>
</ul>
<h3 id="using-semigroups-with-sconcat">Using Semigroups with sconcat</h3>
<p>The <code>sconcat</code> function is a handy tool for combining multiple Semigroup values:</p>
<div class="source-code"><pre><code class="language-haskell"><span class="va">sconcat</span><span> </span><span class="sy">::</span><span> </span><span class="cr">NonEmpty</span><span> </span><span class="va">a</span><span> </span><span class="sy">-&gt;</span><span> </span><span class="va">a</span><span>
</span></code></pre></div>
<p>It takes a <strong>non-empty list</strong> of Semigroup values and combines them using (&lt;&gt;).</p>
<p>Example:</p>
<div class="source-code"><pre><code class="language-haskell"><span class="kw">import</span><span> </span><span class="cr">Data.List.NonEmpty</span><span> </span><span class="sy">(</span><span class="cr">NonEmpty</span><span class="sy">(</span><span class="sy">..</span><span class="sy">)</span><span class="sy">)</span><span>
</span><span class="kw">import</span><span> </span><span class="cr">Data.Semigroup</span><span> </span><span class="sy">(</span><span class="va">sconcat</span><span class="sy">,</span><span> </span><span class="cr">Max</span><span class="sy">(</span><span class="sy">..</span><span class="sy">)</span><span class="sy">)</span><span>

</span><span class="va">main</span><span> </span><span class="sy">::</span><span> </span><span class="cr">IO</span><span> </span><span class="sy">(</span><span class="sy">)</span><span>
</span><span class="va">main</span><span> </span><span class="sy">=</span><span> </span><span class="kw">do</span><span>
    </span><span class="kw">let</span><span> </span><span class="va">discounts</span><span> </span><span class="sy">=</span><span> </span><span class="cr">Max</span><span> </span><span class="it">10</span><span> </span><span class="op">:|</span><span> </span><span class="sy">[</span><span class="cr">Max</span><span> </span><span class="it">20</span><span class="sy">,</span><span> </span><span class="cr">Max</span><span> </span><span class="it">15</span><span class="sy">]</span><span>
    </span><span class="va">print</span><span> </span><span class="op">$</span><span> </span><span class="va">sconcat</span><span> </span><span class="va">discounts</span><span> </span><span class="co">-- Output: Max {getMax = 20}</span><span>
</span></code></pre></div>
<h2 id="6-applicatives-combining-independent-effects">6. Applicatives: Combining Independent Effects</h2>
<p>While Functors allow us to apply a single function to values within a context, Applicatives extend this capability by letting us apply <strong>functions with multiple arguments</strong> to values in <strong>multiple independent contexts</strong>. Applicatives are a natural progression from Functors, providing more power and flexibility while still adhering to Haskell’s principles of composability and safety.</p>
<h3 id="what-is-an-applicative">What is an Applicative?</h3>
<p>An <strong>Applicative</strong> is a type class that allows you to apply functions within a context (e.g., <code>Maybe</code>, lists, or <code>Either</code>) to values also within a context. Applicatives are defined by two core functions:</p>
<ol>
<li>
<strong><code>pure</code></strong>: Embeds a value into a context.
</li>
<li>
<strong><code>&lt;*&gt;</code></strong>: Applies a function wrapped in a context to a value wrapped in a context.
</li>
</ol>
<p>Here’s the type class definition:</p>
<div class="source-code"><pre><code class="language-haskell"><span class="kw">class</span><span> </span><span class="cr">Functor</span><span> </span><span class="va">f</span><span> </span><span class="sy">=&gt;</span><span> </span><span class="cr">Applicative</span><span> </span><span class="va">f</span><span> </span><span class="kw">where</span><span>
    </span><span class="va">pure</span><span> </span><span class="sy">::</span><span> </span><span class="va">a</span><span> </span><span class="sy">-&gt;</span><span> </span><span class="va">f</span><span> </span><span class="va">a</span><span>
    </span><span class="sy">(</span><span class="op">&lt;*&gt;</span><span class="sy">)</span><span> </span><span class="sy">::</span><span> </span><span class="va">f</span><span> </span><span class="sy">(</span><span class="va">a</span><span> </span><span class="sy">-&gt;</span><span> </span><span class="va">b</span><span class="sy">)</span><span> </span><span class="sy">-&gt;</span><span> </span><span class="va">f</span><span> </span><span class="va">a</span><span> </span><span class="sy">-&gt;</span><span> </span><span class="va">f</span><span> </span><span class="va">b</span><span>
</span></code></pre></div>
<ul>
<li>
<code>pure</code> takes a value and wraps it in the Applicative context.
</li>
<li>
<code>&lt;*&gt;</code> (called &quot;apply&quot;) takes a wrapped function (<code>f (a -&gt; b)</code>) and a wrapped value (<code>f a</code>) and produces a wrapped result (<code>f b</code>).
</li>
</ul>
<h4 id="relationship-to-functors">Relationship to Functors</h4>
<p>Applicatives are more powerful than Functors because they allow functions of <strong>multiple arguments</strong> to be applied within contexts. In fact, you can define <code>fmap</code> using Applicatives:</p>
<div class="source-code"><pre><code class="language-haskell"><span class="va">fmap</span><span> </span><span class="va">f</span><span> </span><span class="va">x</span><span> </span><span class="sy">=</span><span> </span><span class="va">pure</span><span> </span><span class="va">f</span><span> </span><span class="op">&lt;*&gt;</span><span> </span><span class="va">x</span><span>
</span></code></pre></div>
<h3 id="why-are-applicatives-important">Why Are Applicatives Important?</h3>
<ol>
<li>
<strong>Combining Independent Effects</strong>: Applicatives allow you to combine computations that are independent of each other, meaning one doesn’t depend on the result of the other.
</li>
<li>
<strong>Generality</strong>: Applicatives work across many contexts, including lists, <code>Maybe</code>, and <code>Either</code>.
</li>
<li>
<strong>Safety</strong>: Like Functors, Applicatives ensure that you handle context appropriately and cannot accidentally &quot;escape&quot; it.
</li>
</ol>
<h3 id="examples-of-applicatives">Examples of Applicatives</h3>
<h4 id="example-1-working-with-maybe">Example 1: Working with <code>Maybe</code></h4>
<p>Let’s say we have two <code>Maybe</code> values and want to add their contents. With Applicatives, we can do this without unwrapping and re-wrapping the values manually:</p>
<div class="source-code"><pre><code class="language-haskell"><span class="va">addMaybes</span><span> </span><span class="sy">::</span><span> </span><span class="cr">Maybe</span><span> </span><span class="cr">Int</span><span> </span><span class="sy">-&gt;</span><span> </span><span class="cr">Maybe</span><span> </span><span class="cr">Int</span><span> </span><span class="sy">-&gt;</span><span> </span><span class="cr">Maybe</span><span> </span><span class="cr">Int</span><span>
</span><span class="va">addMaybes</span><span> </span><span class="va">x</span><span> </span><span class="va">y</span><span> </span><span class="sy">=</span><span> </span><span class="va">pure</span><span> </span><span class="sy">(</span><span class="op">+</span><span class="sy">)</span><span> </span><span class="op">&lt;*&gt;</span><span> </span><span class="va">x</span><span> </span><span class="op">&lt;*&gt;</span><span> </span><span class="va">y</span><span>

</span><span class="va">main</span><span> </span><span class="sy">::</span><span> </span><span class="cr">IO</span><span> </span><span class="sy">(</span><span class="sy">)</span><span>
</span><span class="va">main</span><span> </span><span class="sy">=</span><span> </span><span class="kw">do</span><span>
    </span><span class="va">print</span><span> </span><span class="op">$</span><span> </span><span class="va">addMaybes</span><span> </span><span class="sy">(</span><span class="cr">Just</span><span> </span><span class="it">5</span><span class="sy">)</span><span> </span><span class="sy">(</span><span class="cr">Just</span><span> </span><span class="it">3</span><span class="sy">)</span><span> </span><span class="co">-- Output: Just 8</span><span>
    </span><span class="va">print</span><span> </span><span class="op">$</span><span> </span><span class="va">addMaybes</span><span> </span><span class="sy">(</span><span class="cr">Just</span><span> </span><span class="it">5</span><span class="sy">)</span><span> </span><span class="cr">Nothing</span><span>  </span><span class="co">-- Output: Nothing</span><span>
</span></code></pre></div>
<p>Here’s what’s happening:</p>
<ol>
<li>
<code>pure (+)</code> wraps the addition function in the <code>Maybe</code> context.
</li>
<li>
<code>&lt;*&gt;</code> applies the wrapped function to the first <code>Maybe</code> value (<code>Just 5</code>).
</li>
<li>
<code>&lt;*&gt;</code> then applies the result to the second <code>Maybe</code> value (<code>Just 3</code>).
</li>
</ol>
<p>If either value is <code>Nothing</code>, the result is <code>Nothing</code>.</p>
<h4 id="example-2-combining-lists">Example 2: Combining Lists</h4>
<p>With lists, Applicatives apply functions to <strong>all possible combinations</strong> of values from the contexts:</p>
<div class="source-code"><pre><code class="language-haskell"><span class="va">combineLists</span><span> </span><span class="sy">::</span><span> </span><span class="sy">[</span><span class="cr">Int</span><span class="sy">]</span><span> </span><span class="sy">-&gt;</span><span> </span><span class="sy">[</span><span class="cr">Int</span><span class="sy">]</span><span> </span><span class="sy">-&gt;</span><span> </span><span class="sy">[</span><span class="cr">Int</span><span class="sy">]</span><span>
</span><span class="va">combineLists</span><span> </span><span class="va">xs</span><span> </span><span class="va">ys</span><span> </span><span class="sy">=</span><span> </span><span class="va">pure</span><span> </span><span class="sy">(</span><span class="op">+</span><span class="sy">)</span><span> </span><span class="op">&lt;*&gt;</span><span> </span><span class="va">xs</span><span> </span><span class="op">&lt;*&gt;</span><span> </span><span class="va">ys</span><span>

</span><span class="va">main</span><span> </span><span class="sy">::</span><span> </span><span class="cr">IO</span><span> </span><span class="sy">(</span><span class="sy">)</span><span>
</span><span class="va">main</span><span> </span><span class="sy">=</span><span> </span><span class="va">print</span><span> </span><span class="op">$</span><span> </span><span class="va">combineLists</span><span> </span><span class="sy">[</span><span class="it">1</span><span class="sy">,</span><span> </span><span class="it">2</span><span class="sy">]</span><span> </span><span class="sy">[</span><span class="it">3</span><span class="sy">,</span><span> </span><span class="it">4</span><span class="sy">]</span><span>
</span><span class="co">-- Output: [4, 5, 5, 6]</span><span>
</span></code></pre></div>
<p>This works because the <code>Applicative</code> instance for lists applies the function to every combination of elements from both lists.</p>
<h4 id="example-3-validating-inputs-with-either">Example 3: Validating Inputs with <code>Either</code></h4>
<p>Imagine you’re validating form inputs and want to combine validation results. If any validation fails, the entire result should fail:</p>
<div class="source-code"><pre><code class="language-haskell"><span class="va">validateName</span><span> </span><span class="sy">::</span><span> </span><span class="cr">String</span><span> </span><span class="sy">-&gt;</span><span> </span><span class="cr">Either</span><span> </span><span class="cr">String</span><span> </span><span class="cr">String</span><span>
</span><span class="va">validateName</span><span> </span><span class="va">name</span><span>
    </span><span class="sy">|</span><span> </span><span class="va">null</span><span> </span><span class="va">name</span><span> </span><span class="sy">=</span><span> </span><span class="cr">Left</span><span> </span><span class="st">&quot;Name cannot be empty&quot;</span><span>
    </span><span class="sy">|</span><span> </span><span class="va">otherwise</span><span> </span><span class="sy">=</span><span> </span><span class="cr">Right</span><span> </span><span class="va">name</span><span>

</span><span class="va">validateAge</span><span> </span><span class="sy">::</span><span> </span><span class="cr">Int</span><span> </span><span class="sy">-&gt;</span><span> </span><span class="cr">Either</span><span> </span><span class="cr">String</span><span> </span><span class="cr">Int</span><span>
</span><span class="va">validateAge</span><span> </span><span class="va">age</span><span>
    </span><span class="sy">|</span><span> </span><span class="va">age</span><span> </span><span class="op">&lt;</span><span> </span><span class="it">0</span><span> </span><span class="sy">=</span><span> </span><span class="cr">Left</span><span> </span><span class="st">&quot;Age cannot be negative&quot;</span><span>
    </span><span class="sy">|</span><span> </span><span class="va">otherwise</span><span> </span><span class="sy">=</span><span> </span><span class="cr">Right</span><span> </span><span class="va">age</span><span>

</span><span class="va">validatePerson</span><span> </span><span class="sy">::</span><span> </span><span class="cr">String</span><span> </span><span class="sy">-&gt;</span><span> </span><span class="cr">Int</span><span> </span><span class="sy">-&gt;</span><span> </span><span class="cr">Either</span><span> </span><span class="cr">String</span><span> </span><span class="sy">(</span><span class="cr">String</span><span class="sy">,</span><span> </span><span class="cr">Int</span><span class="sy">)</span><span>
</span><span class="va">validatePerson</span><span> </span><span class="va">name</span><span> </span><span class="va">age</span><span> </span><span class="sy">=</span><span> </span><span class="va">pure</span><span> </span><span class="sy">(</span><span class="sy">,</span><span class="sy">)</span><span> </span><span class="op">&lt;*&gt;</span><span> </span><span class="va">validateName</span><span> </span><span class="va">name</span><span> </span><span class="op">&lt;*&gt;</span><span> </span><span class="va">validateAge</span><span> </span><span class="va">age</span><span>

</span><span class="va">main</span><span> </span><span class="sy">::</span><span> </span><span class="cr">IO</span><span> </span><span class="sy">(</span><span class="sy">)</span><span>
</span><span class="va">main</span><span> </span><span class="sy">=</span><span> </span><span class="kw">do</span><span>
    </span><span class="va">print</span><span> </span><span class="op">$</span><span> </span><span class="va">validatePerson</span><span> </span><span class="st">&quot;John&quot;</span><span> </span><span class="it">25</span><span> </span><span class="co">-- Output: Right (&quot;John&quot;, 25)</span><span>
    </span><span class="va">print</span><span> </span><span class="op">$</span><span> </span><span class="va">validatePerson</span><span> </span><span class="st">&quot;&quot;</span><span> </span><span class="it">25</span><span>     </span><span class="co">-- Output: Left &quot;Name cannot be empty&quot;</span><span>
    </span><span class="va">print</span><span> </span><span class="op">$</span><span> </span><span class="va">validatePerson</span><span> </span><span class="st">&quot;John&quot;</span><span> </span><span class="sy">(</span><span class="it">-1</span><span class="sy">)</span><span> </span><span class="co">-- Output: Left &quot;Age cannot be negative&quot;</span><span>
</span></code></pre></div>
<p>Here:</p>
<ul>
<li>
<code>pure (,)</code> creates a wrapped tuple constructor.
</li>
<li>
<code>&lt;*&gt;</code> applies the constructor to the validated name and age.
</li>
<li>
The result is either a successful tuple (<code>Right</code>) or an error message (<code>Left</code>).
</li>
</ul>
<h3 id="applicative-laws">Applicative Laws</h3>
<p>Like Functors, Applicatives must obey a set of laws to ensure consistent behavior:</p>
<ol>
<li>
<strong>Identity</strong>:
</li>
</ol>
<div class="source-code"><pre><code class="language-haskell"><span class="va">pure</span><span> </span><span class="va">id</span><span> </span><span class="op">&lt;*&gt;</span><span> </span><span class="va">v</span><span> </span><span class="op">==</span><span> </span><span class="va">v</span><span>
</span></code></pre></div>
<p>Applying the identity function inside the context doesn’t change the value.</p>
<ol start="2">
<li>
<strong>Composition:</strong>
</li>
</ol>
<div class="source-code"><pre><code class="language-haskell"><span class="va">pure</span><span> </span><span class="sy">(</span><span class="op">.</span><span class="sy">)</span><span> </span><span class="op">&lt;*&gt;</span><span> </span><span class="va">u</span><span> </span><span class="op">&lt;*&gt;</span><span> </span><span class="va">v</span><span> </span><span class="op">&lt;*&gt;</span><span> </span><span class="va">w</span><span> </span><span class="op">==</span><span> </span><span class="va">u</span><span> </span><span class="op">&lt;*&gt;</span><span> </span><span class="sy">(</span><span class="va">v</span><span> </span><span class="op">&lt;*&gt;</span><span> </span><span class="va">w</span><span class="sy">)</span><span>
</span></code></pre></div>
<p>Composition of functions inside the context behaves like normal composition.</p>
<ol start="3">
<li>
<strong>Homomorphism:</strong>
</li>
</ol>
<div class="source-code"><pre><code class="language-haskell"><span class="va">pure</span><span> </span><span class="va">f</span><span> </span><span class="op">&lt;*&gt;</span><span> </span><span class="va">pure</span><span> </span><span class="va">x</span><span> </span><span class="op">==</span><span> </span><span class="va">pure</span><span> </span><span class="sy">(</span><span class="va">f</span><span> </span><span class="va">x</span><span class="sy">)</span><span>
</span></code></pre></div>
<p>Wrapping a function and its argument in the context is the same as applying the function and then wrapping the result.</p>
<ol start="4">
<li>
<strong>Interchange:</strong>
</li>
</ol>
<div class="source-code"><pre><code class="language-haskell"><span class="va">u</span><span> </span><span class="op">&lt;*&gt;</span><span> </span><span class="va">pure</span><span> </span><span class="va">y</span><span> </span><span class="op">==</span><span> </span><span class="va">pure</span><span> </span><span class="sy">(</span><span class="op">$</span><span> </span><span class="va">y</span><span class="sy">)</span><span> </span><span class="op">&lt;*&gt;</span><span> </span><span class="va">u</span><span>
</span></code></pre></div>
<p>Applying a wrapped function to a wrapped value is equivalent to applying the value to the function.</p>
<h3 id="realworld-example-building-a-configuration-system">Real-World Example: Building a Configuration System</h3>
<p>Suppose you’re building a system to parse configurations from the environment. Each configuration value may or may not exist (<code>Maybe</code>), and you need to combine them into a final configuration object.</p>
<div class="source-code"><pre><code class="language-haskell"><span class="kw">data</span><span> </span><span class="cr">Config</span><span> </span><span class="sy">=</span><span> </span><span class="cr">Config</span><span>
    </span><span class="sy">{</span><span> </span><span class="va">host</span><span> </span><span class="sy">::</span><span> </span><span class="cr">String</span><span>
    </span><span class="sy">,</span><span> </span><span class="va">port</span><span> </span><span class="sy">::</span><span> </span><span class="cr">Int</span><span>
    </span><span class="sy">}</span><span> </span><span class="kw">deriving</span><span> </span><span class="sy">(</span><span class="cr">Show</span><span class="sy">)</span><span>

</span><span class="va">getEnvVar</span><span> </span><span class="sy">::</span><span> </span><span class="cr">String</span><span> </span><span class="sy">-&gt;</span><span> </span><span class="cr">Maybe</span><span> </span><span class="cr">String</span><span>
</span><span class="va">getEnvVar</span><span> </span><span class="va">var</span><span>
    </span><span class="sy">|</span><span> </span><span class="va">var</span><span> </span><span class="op">==</span><span> </span><span class="st">&quot;HOST&quot;</span><span> </span><span class="sy">=</span><span> </span><span class="cr">Just</span><span> </span><span class="st">&quot;localhost&quot;</span><span>
    </span><span class="sy">|</span><span> </span><span class="va">var</span><span> </span><span class="op">==</span><span> </span><span class="st">&quot;PORT&quot;</span><span> </span><span class="sy">=</span><span> </span><span class="cr">Just</span><span> </span><span class="st">&quot;8080&quot;</span><span>
    </span><span class="sy">|</span><span> </span><span class="va">otherwise</span><span> </span><span class="sy">=</span><span> </span><span class="cr">Nothing</span><span>

</span><span class="va">readPort</span><span> </span><span class="sy">::</span><span> </span><span class="cr">String</span><span> </span><span class="sy">-&gt;</span><span> </span><span class="cr">Maybe</span><span> </span><span class="cr">Int</span><span>
</span><span class="va">readPort</span><span> </span><span class="va">str</span><span> </span><span class="sy">=</span><span> </span><span class="kw">case</span><span> </span><span class="va">reads</span><span> </span><span class="va">str</span><span> </span><span class="kw">of</span><span>
    </span><span class="sy">[</span><span class="sy">(</span><span class="va">n</span><span class="sy">,</span><span> </span><span class="st">&quot;&quot;</span><span class="sy">)</span><span class="sy">]</span><span> </span><span class="sy">-&gt;</span><span> </span><span class="cr">Just</span><span> </span><span class="va">n</span><span>
    </span><span class="sy">_</span><span>         </span><span class="sy">-&gt;</span><span> </span><span class="cr">Nothing</span><span>

</span><span class="va">getConfig</span><span> </span><span class="sy">::</span><span> </span><span class="cr">Maybe</span><span> </span><span class="cr">Config</span><span>
</span><span class="va">getConfig</span><span> </span><span class="sy">=</span><span> </span><span class="va">pure</span><span> </span><span class="cr">Config</span><span> </span><span class="op">&lt;*&gt;</span><span> </span><span class="va">getEnvVar</span><span> </span><span class="st">&quot;HOST&quot;</span><span> </span><span class="op">&lt;*&gt;</span><span> </span><span class="sy">(</span><span class="va">getEnvVar</span><span> </span><span class="st">&quot;PORT&quot;</span><span> </span><span class="op">&gt;&gt;=</span><span> </span><span class="va">readPort</span><span class="sy">)</span><span>

</span><span class="va">main</span><span> </span><span class="sy">::</span><span> </span><span class="cr">IO</span><span> </span><span class="sy">(</span><span class="sy">)</span><span>
</span><span class="va">main</span><span> </span><span class="sy">=</span><span> </span><span class="va">print</span><span> </span><span class="va">getConfig</span><span>
</span><span class="co">-- Output: Just (Config {host = &quot;localhost&quot;, port = 8080})</span><span>
</span></code></pre></div>
<p>Key points:</p>
<ol>
<li>
<code>pure Config</code> wraps the constructor for <code>Config</code> in the <code>Maybe</code> context.
</li>
<li>
<code>&lt;*&gt;</code> applies the constructor to each configuration value, ensuring that the entire process fails if any value is <code>Nothing</code>.
</li>
</ol>
<h2 id="7-monads-chaining-dependent-effects">7. Monads: Chaining Dependent Effects</h2>
<p>Monads are one of Haskell’s most powerful and versatile abstractions. They extend the functionality of Applicatives to allow <strong>chaining computations</strong> where each step may depend on the result of the previous step. Monads are essential for handling sequential effects, error propagation, and other context-sensitive operations in a safe and composable way.</p>
<hr>
<h3 id="what-is-a-monad">What is a Monad?</h3>
<p>A <strong>Monad</strong> is a type class that defines how to:</p>
<ol>
<li>
<strong>Wrap a value in a context</strong> using <code>return</code> or <code>pure</code> (inherited from Applicative).
</li>
<li>
<strong>Chain computations</strong> while managing the context using <code>&gt;&gt;=</code> (bind).
</li>
</ol>
<p>Here’s the type class definition:</p>
<div class="source-code"><pre><code class="language-haskell"><span class="kw">class</span><span> </span><span class="cr">Applicative</span><span> </span><span class="va">m</span><span> </span><span class="sy">=&gt;</span><span> </span><span class="cr">Monad</span><span> </span><span class="va">m</span><span> </span><span class="kw">where</span><span>
    </span><span class="sy">(</span><span class="op">&gt;&gt;=</span><span class="sy">)</span><span> </span><span class="sy">::</span><span> </span><span class="va">m</span><span> </span><span class="va">a</span><span> </span><span class="sy">-&gt;</span><span> </span><span class="sy">(</span><span class="va">a</span><span> </span><span class="sy">-&gt;</span><span> </span><span class="va">m</span><span> </span><span class="va">b</span><span class="sy">)</span><span> </span><span class="sy">-&gt;</span><span> </span><span class="va">m</span><span> </span><span class="va">b</span><span>
    </span><span class="sy">(</span><span class="op">&gt;&gt;</span><span class="sy">)</span><span> </span><span class="sy">::</span><span> </span><span class="va">m</span><span> </span><span class="va">a</span><span> </span><span class="sy">-&gt;</span><span> </span><span class="va">m</span><span> </span><span class="va">b</span><span> </span><span class="sy">-&gt;</span><span> </span><span class="va">m</span><span> </span><span class="va">b</span><span>
    </span><span class="va">return</span><span> </span><span class="sy">::</span><span> </span><span class="va">a</span><span> </span><span class="sy">-&gt;</span><span> </span><span class="va">m</span><span> </span><span class="va">a</span><span>
    </span><span class="va">return</span><span> </span><span class="sy">=</span><span> </span><span class="va">pure</span><span>
</span></code></pre></div>
<h3 id="breaking-it-down">Breaking It Down:</h3>
<ul>
<li>
<code>(&gt;&gt;=)</code> <strong>(bind)</strong> : Takes a value wrapped in a context (<code>m a</code>) and a function that produces a new value in the same context (<code>a -&gt; m b</code>). It chains the two, passing the inner value to the function.
</li>
<li>
<code>return</code>: Wraps a value in the Monad context. In modern Haskell, <code>return</code> is synonymous with <code>pure</code>.
</li>
</ul>
<h3 id="why-are-monads-important">Why Are Monads Important?</h3>
<ol>
<li>
<strong>Chaining Dependent Effects</strong>: Monads let you express sequential computations where the output of one step determines the input of the next.
</li>
<li>
<strong>Error Handling</strong>: Monads like <code>Maybe</code> and <code>Either</code> propagate errors automatically, avoiding the need for manual checks.
</li>
<li>
<strong>Side Effects</strong>: The IO Monad allows you to safely model side effects like reading from a file or printing to the console.
</li>
<li>
<strong>Composability</strong>: Like Functors and Applicatives, Monads allow you to work with values in a context without &quot;breaking out&quot; of that context.
</li>
</ol>
<h3 id="examples-of-monads">Examples of Monads</h3>
<h4 id="example-1-chaining-with-maybe">Example 1: Chaining with Maybe</h4>
<p>Suppose we’re working with user input that may or may not exist. Monads allow us to chain operations on <code>Maybe</code> values without manually checking for <code>Nothing</code> at every step.</p>
<div class="source-code"><pre><code class="language-haskell"><span class="va">getUserInput</span><span> </span><span class="sy">::</span><span> </span><span class="cr">Maybe</span><span> </span><span class="cr">String</span><span>
</span><span class="va">getUserInput</span><span> </span><span class="sy">=</span><span> </span><span class="cr">Just</span><span> </span><span class="st">&quot;haskell&quot;</span><span>

</span><span class="va">validateLength</span><span> </span><span class="sy">::</span><span> </span><span class="cr">String</span><span> </span><span class="sy">-&gt;</span><span> </span><span class="cr">Maybe</span><span> </span><span class="cr">String</span><span>
</span><span class="va">validateLength</span><span> </span><span class="va">str</span><span>
    </span><span class="sy">|</span><span> </span><span class="va">length</span><span> </span><span class="va">str</span><span> </span><span class="op">&gt;</span><span> </span><span class="it">5</span><span> </span><span class="sy">=</span><span> </span><span class="cr">Just</span><span> </span><span class="va">str</span><span>
    </span><span class="sy">|</span><span> </span><span class="va">otherwise</span><span>      </span><span class="sy">=</span><span> </span><span class="cr">Nothing</span><span>

</span><span class="va">toUpperCase</span><span> </span><span class="sy">::</span><span> </span><span class="cr">String</span><span> </span><span class="sy">-&gt;</span><span> </span><span class="cr">Maybe</span><span> </span><span class="cr">String</span><span>
</span><span class="va">toUpperCase</span><span> </span><span class="va">str</span><span> </span><span class="sy">=</span><span> </span><span class="cr">Just</span><span> </span><span class="sy">(</span><span class="va">map</span><span> </span><span class="va">toUpper</span><span> </span><span class="va">str</span><span class="sy">)</span><span>

</span><span class="va">processInput</span><span> </span><span class="sy">::</span><span> </span><span class="cr">Maybe</span><span> </span><span class="cr">String</span><span>
</span><span class="va">processInput</span><span> </span><span class="sy">=</span><span> </span><span class="va">getUserInput</span><span> </span><span class="op">&gt;&gt;=</span><span> </span><span class="va">validateLength</span><span> </span><span class="op">&gt;&gt;=</span><span> </span><span class="va">toUpperCase</span><span>

</span><span class="va">main</span><span> </span><span class="sy">::</span><span> </span><span class="cr">IO</span><span> </span><span class="sy">(</span><span class="sy">)</span><span>
</span><span class="va">main</span><span> </span><span class="sy">=</span><span> </span><span class="va">print</span><span> </span><span class="va">processInput</span><span>
</span><span class="co">-- Output: Just &quot;HASKELL&quot;</span><span>
</span></code></pre></div>
<p>Here:</p>
<ol>
<li>
<code>getUserInput</code> provides the input wrapped in <code>Maybe</code>.
</li>
<li>
<code>validateLength</code> and <code>toUpperCase</code> are chained using <code>&gt;&gt;=</code>.
</li>
<li>
If any step returns <code>Nothing</code>, the entire chain short-circuits, propagating the failure.
</li>
</ol>
<h4 id="example-2-error-propagation-with-either">Example 2: Error Propagation with Either</h4>
<p>With Either, Monads allow us to propagate errors alongside computations. Let’s validate user data:</p>
<div class="source-code"><pre><code class="language-haskell"><span class="va">validateName</span><span> </span><span class="sy">::</span><span> </span><span class="cr">String</span><span> </span><span class="sy">-&gt;</span><span> </span><span class="cr">Either</span><span> </span><span class="cr">String</span><span> </span><span class="cr">String</span><span>
</span><span class="va">validateName</span><span> </span><span class="va">name</span><span>
    </span><span class="sy">|</span><span> </span><span class="va">null</span><span> </span><span class="va">name</span><span> </span><span class="sy">=</span><span> </span><span class="cr">Left</span><span> </span><span class="st">&quot;Name cannot be empty&quot;</span><span>
    </span><span class="sy">|</span><span> </span><span class="va">otherwise</span><span> </span><span class="sy">=</span><span> </span><span class="cr">Right</span><span> </span><span class="va">name</span><span>

</span><span class="va">validateAge</span><span> </span><span class="sy">::</span><span> </span><span class="cr">Int</span><span> </span><span class="sy">-&gt;</span><span> </span><span class="cr">Either</span><span> </span><span class="cr">String</span><span> </span><span class="cr">Int</span><span>
</span><span class="va">validateAge</span><span> </span><span class="va">age</span><span>
    </span><span class="sy">|</span><span> </span><span class="va">age</span><span> </span><span class="op">&lt;</span><span> </span><span class="it">0</span><span> </span><span class="sy">=</span><span> </span><span class="cr">Left</span><span> </span><span class="st">&quot;Age cannot be negative&quot;</span><span>
    </span><span class="sy">|</span><span> </span><span class="va">otherwise</span><span> </span><span class="sy">=</span><span> </span><span class="cr">Right</span><span> </span><span class="va">age</span><span>

</span><span class="va">createUser</span><span> </span><span class="sy">::</span><span> </span><span class="cr">String</span><span> </span><span class="sy">-&gt;</span><span> </span><span class="cr">Int</span><span> </span><span class="sy">-&gt;</span><span> </span><span class="cr">Either</span><span> </span><span class="cr">String</span><span> </span><span class="sy">(</span><span class="cr">String</span><span class="sy">,</span><span> </span><span class="cr">Int</span><span class="sy">)</span><span>
</span><span class="va">createUser</span><span> </span><span class="va">name</span><span> </span><span class="va">age</span><span> </span><span class="sy">=</span><span> </span><span class="kw">do</span><span>
    </span><span class="va">validName</span><span> </span><span class="sy">&lt;-</span><span> </span><span class="va">validateName</span><span> </span><span class="va">name</span><span>
    </span><span class="va">validAge</span><span>  </span><span class="sy">&lt;-</span><span> </span><span class="va">validateAge</span><span> </span><span class="va">age</span><span>
    </span><span class="va">return</span><span> </span><span class="sy">(</span><span class="va">validName</span><span class="sy">,</span><span> </span><span class="va">validAge</span><span class="sy">)</span><span>

</span><span class="va">main</span><span> </span><span class="sy">::</span><span> </span><span class="cr">IO</span><span> </span><span class="sy">(</span><span class="sy">)</span><span>
</span><span class="va">main</span><span> </span><span class="sy">=</span><span> </span><span class="kw">do</span><span>
    </span><span class="va">print</span><span> </span><span class="op">$</span><span> </span><span class="va">createUser</span><span> </span><span class="st">&quot;John&quot;</span><span> </span><span class="it">25</span><span> </span><span class="co">-- Output: Right (&quot;John&quot;, 25)</span><span>
    </span><span class="va">print</span><span> </span><span class="op">$</span><span> </span><span class="va">createUser</span><span> </span><span class="st">&quot;&quot;</span><span> </span><span class="it">25</span><span>     </span><span class="co">-- Output: Left &quot;Name cannot be empty&quot;</span><span>
    </span><span class="va">print</span><span> </span><span class="op">$</span><span> </span><span class="va">createUser</span><span> </span><span class="st">&quot;John&quot;</span><span> </span><span class="sy">(</span><span class="it">-1</span><span class="sy">)</span><span> </span><span class="co">-- Output: Left &quot;Age cannot be negative&quot;</span><span>
</span></code></pre></div>
<p>Key points:</p>
<ul>
<li>
The <code>do</code> notation provides a more readable syntax for chaining operations with Monads.
</li>
<li>
Errors are propagated automatically without manual checks.
</li>
</ul>
<h4 id="example-3-sequencing-effects-with-io">Example 3: Sequencing Effects with IO</h4>
<p>The <code>IO</code> Monad allows you to sequence actions that interact with the real world (e.g., reading input, writing output).</p>
<div class="source-code"><pre><code class="language-haskell"><span class="va">main</span><span> </span><span class="sy">::</span><span> </span><span class="cr">IO</span><span> </span><span class="sy">(</span><span class="sy">)</span><span>
</span><span class="va">main</span><span> </span><span class="sy">=</span><span> </span><span class="kw">do</span><span>
    </span><span class="va">putStrLn</span><span> </span><span class="st">&quot;Enter your name:&quot;</span><span>
    </span><span class="va">name</span><span> </span><span class="sy">&lt;-</span><span> </span><span class="va">getLine</span><span>
    </span><span class="va">putStrLn</span><span> </span><span class="op">$</span><span> </span><span class="st">&quot;Hello, &quot;</span><span> </span><span class="op">++</span><span> </span><span class="va">name</span><span> </span><span class="op">++</span><span> </span><span class="st">&quot;!&quot;</span><span>
</span></code></pre></div>
<p>Here:</p>
<ul>
<li>
<code>putStrLn</code> and <code>getLine</code> are <code>IO</code> actions.
</li>
<li>
The <code>do</code> block chains them, passing the result of <code>getLine</code> into the next action.
</li>
</ul>
<h3 id="the-do-notation-syntax-sugar-for-monadic-chaining">The <code>do</code> Notation: Syntax Sugar for Monadic Chaining</h3>
<p>The <code>do</code> notation in Haskell provides a more readable and imperative-style syntax for working with Monads. It’s a convenient abstraction over the <code>&gt;&gt;=</code> (bind) operator, allowing you to chain monadic operations in a clear and sequential manner.</p>
<p>Under the hood, the <code>do</code> notation is syntactic sugar for chaining operations with <code>&gt;&gt;=</code>. Each line in a <code>do</code> block represents a step in the computation, and the results of monadic operations can be extracted and assigned to variables.</p>
<h4 id="general-structure">General Structure</h4>
<div class="source-code"><pre><code class="language-haskell"><span class="kw">do</span><span>
    </span><span class="va">value1</span><span> </span><span class="sy">&lt;-</span><span> </span><span class="va">action1</span><span>
    </span><span class="va">value2</span><span> </span><span class="sy">&lt;-</span><span> </span><span class="va">action2</span><span>
    </span><span class="va">action3</span><span> </span><span class="va">value1</span><span> </span><span class="va">value2</span><span>
</span></code></pre></div>
<p>Here:</p>
<ul>
<li>
<code>action1</code> and <code>action2</code> are monadic actions.
</li>
<li>
<code>&lt;-</code> extracts the value from the context of the Monad (e.g., <code>Maybe</code>, <code>IO</code>, etc.).
</li>
<li>
The final line typically produces the result of the <code>do</code> block.
</li>
</ul>
<p>Equivalent in terms of <code>&gt;&gt;=</code>:</p>
<div class="source-code"><pre><code class="language-haskell"><span class="va">action1</span><span> </span><span class="op">&gt;&gt;=</span><span> </span><span class="va">value1</span><span> </span><span class="sy">-&gt;</span><span>
</span><span class="va">action2</span><span> </span><span class="op">&gt;&gt;=</span><span> </span><span class="va">value2</span><span> </span><span class="sy">-&gt;</span><span>
</span><span class="va">action3</span><span> </span><span class="va">value1</span><span> </span><span class="va">value2</span><span>
</span></code></pre></div>
<h3 id="monad-laws">Monad Laws</h3>
<p>To qualify as a Monad, a type must satisfy three laws:</p>
<ol>
<li>
<strong>Left Identity</strong>:
</li>
</ol>
<div class="source-code"><pre><code class="language-haskell"><span class="va">return</span><span> </span><span class="va">a</span><span> </span><span class="op">&gt;&gt;=</span><span> </span><span class="va">f</span><span> </span><span class="op">==</span><span> </span><span class="va">f</span><span> </span><span class="va">a</span><span>
</span></code></pre></div>
<p>Wrapping a value with <code>return</code> and binding it to a function is the same as applying the function directly.</p>
<ol start="2">
<li>
<strong>Right Identity</strong>:
</li>
</ol>
<div class="source-code"><pre><code class="language-haskell"><span class="va">m</span><span> </span><span class="op">&gt;&gt;=</span><span> </span><span class="va">return</span><span> </span><span class="op">==</span><span> </span><span class="va">m</span><span>
</span></code></pre></div>
<p>Binding a Monad to return doesn’t change the Monad.</p>
<ol start="3">
<li>
<strong>Associativity</strong>:
</li>
</ol>
<div class="source-code"><pre><code class="language-haskell"><span class="sy">(</span><span class="va">m</span><span> </span><span class="op">&gt;&gt;=</span><span> </span><span class="va">f</span><span class="sy">)</span><span> </span><span class="op">&gt;&gt;=</span><span> </span><span class="va">g</span><span> </span><span class="op">==</span><span> </span><span class="va">m</span><span> </span><span class="op">&gt;&gt;=</span><span> </span><span class="sy">(</span><span class="va">x</span><span> </span><span class="sy">-&gt;</span><span> </span><span class="va">f</span><span> </span><span class="va">x</span><span> </span><span class="op">&gt;&gt;=</span><span> </span><span class="va">g</span><span class="sy">)</span><span>
</span></code></pre></div>
<p>The grouping of chained operations doesn’t affect the result.</p>
<h3 id="realworld-example-fetching-data-from-a-database">Real-World Example: Fetching Data from a Database</h3>
<p>Imagine you’re building an application that retrieves user data from a database. Each step depends on the previous one:</p>
<ol>
<li>
Fetch the user’s record by ID.
</li>
<li>
Fetch the user’s orders based on their record.
</li>
<li>
Validate the orders and calculate a summary.
</li>
</ol>
<div class="source-code"><pre><code class="language-haskell"><span class="va">fetchUser</span><span> </span><span class="sy">::</span><span> </span><span class="cr">Int</span><span> </span><span class="sy">-&gt;</span><span> </span><span class="cr">Maybe</span><span> </span><span class="cr">String</span><span>
</span><span class="va">fetchUser</span><span> </span><span class="it">1</span><span> </span><span class="sy">=</span><span> </span><span class="cr">Just</span><span> </span><span class="st">&quot;John&quot;</span><span>
</span><span class="va">fetchUser</span><span> </span><span class="sy">_</span><span> </span><span class="sy">=</span><span> </span><span class="cr">Nothing</span><span>

</span><span class="va">fetchOrders</span><span> </span><span class="sy">::</span><span> </span><span class="cr">String</span><span> </span><span class="sy">-&gt;</span><span> </span><span class="cr">Maybe</span><span> </span><span class="sy">[</span><span class="cr">Int</span><span class="sy">]</span><span>
</span><span class="va">fetchOrders</span><span> </span><span class="st">&quot;John&quot;</span><span> </span><span class="sy">=</span><span> </span><span class="cr">Just</span><span> </span><span class="sy">[</span><span class="it">1001</span><span class="sy">,</span><span> </span><span class="it">1002</span><span class="sy">,</span><span> </span><span class="it">1003</span><span class="sy">]</span><span>
</span><span class="va">fetchOrders</span><span> </span><span class="sy">_</span><span>      </span><span class="sy">=</span><span> </span><span class="cr">Nothing</span><span>

</span><span class="va">validateOrders</span><span> </span><span class="sy">::</span><span> </span><span class="sy">[</span><span class="cr">Int</span><span class="sy">]</span><span> </span><span class="sy">-&gt;</span><span> </span><span class="cr">Maybe</span><span> </span><span class="cr">Int</span><span>
</span><span class="va">validateOrders</span><span> </span><span class="va">orders</span><span> </span><span class="sy">=</span><span> </span><span class="cr">Just</span><span> </span><span class="sy">(</span><span class="va">length</span><span> </span><span class="va">orders</span><span class="sy">)</span><span>

</span><span class="va">processData</span><span> </span><span class="sy">::</span><span> </span><span class="cr">Int</span><span> </span><span class="sy">-&gt;</span><span> </span><span class="cr">Maybe</span><span> </span><span class="cr">Int</span><span>
</span><span class="va">processData</span><span> </span><span class="va">userId</span><span> </span><span class="sy">=</span><span> </span><span class="kw">do</span><span>
    </span><span class="va">user</span><span>   </span><span class="sy">&lt;-</span><span> </span><span class="va">fetchUser</span><span> </span><span class="va">userId</span><span>
    </span><span class="va">orders</span><span> </span><span class="sy">&lt;-</span><span> </span><span class="va">fetchOrders</span><span> </span><span class="va">user</span><span>
    </span><span class="va">validateOrders</span><span> </span><span class="va">orders</span><span>

</span><span class="va">main</span><span> </span><span class="sy">::</span><span> </span><span class="cr">IO</span><span> </span><span class="sy">(</span><span class="sy">)</span><span>
</span><span class="va">main</span><span> </span><span class="sy">=</span><span> </span><span class="kw">do</span><span>
    </span><span class="va">print</span><span> </span><span class="op">$</span><span> </span><span class="va">processData</span><span> </span><span class="it">1</span><span> </span><span class="co">-- Output: Just 3</span><span>
    </span><span class="va">print</span><span> </span><span class="op">$</span><span> </span><span class="va">processData</span><span> </span><span class="it">2</span><span> </span><span class="co">-- Output: Nothing</span><span>
</span></code></pre></div>
<p>Here:</p>
<ul>
<li>
Each step depends on the result of the previous one.
</li>
<li>
The <code>Maybe</code> Monad ensures that failures propagate automatically.
</li>
</ul>
<h3 id="why-monads-matter">Why Monads Matter</h3>
<ol>
<li>
<strong>Chaining Dependent Effects</strong>: Monads enable sequential computations where each step depends on the previous one.
</li>
<li>
<strong>Error Handling</strong>: Monads like <code>Maybe</code> and <code>Either</code> handle failure cases cleanly and propagate them automatically.
</li>
<li>
<strong>Abstraction</strong>: Monads abstract the underlying logic, allowing you to focus on the computation rather than the context management.
</li>
<li>
<strong>Composability</strong>: Monads, like Functors and Applicatives, allow you to build modular and reusable code.
</li>
</ol>
<h2 id="8-recap-exercises">8. Recap &amp; Exercises</h2>
<h3 id="recap">Recap</h3>
<p>In this chapter, we explored how Haskell’s abstractions — <strong>Functors</strong>, <strong>Monoids</strong>, <strong>Applicatives</strong>, <strong>Semigroups</strong>, and <strong>Monads</strong> — enable powerful and composable function combinations. Here’s a summary of what we learned:</p>
<h4 id="1-function-composition">1. Function Composition</h4>
<ul>
<li>
<strong>What It Is</strong>: Combining functions to build complex logic from simple parts.
</li>
<li>
<strong>Key Operator</strong>: <code>(.)</code>, which allows you to chain functions succinctly.
</li>
<li>
<strong>Why It Matters</strong>: Composability makes code safer, more modular, and easier to reason about.
</li>
</ul>
<h4 id="2-functors">2. Functors</h4>
<ul>
<li>
<strong>What They Do</strong>: Allow you to apply a function to a value inside a context (e.g., <code>Maybe</code>, lists).
</li>
<li>
<strong>Key Function</strong>: <code>fmap</code> or <code>&lt;$&gt;</code>.
</li>
<li>
<strong>Why They Matter</strong>: Functors abstract the process of applying functions over contexts, ensuring type safety and clarity.
</li>
</ul>
<p>Example:</p>
<div class="source-code"><pre><code class="language-haskell"><span class="va">fmap</span><span> </span><span class="sy">(</span><span class="op">+</span><span class="it">1</span><span class="sy">)</span><span> </span><span class="sy">(</span><span class="cr">Just</span><span> </span><span class="it">5</span><span class="sy">)</span><span> </span><span class="co">-- Output: Just 6</span><span>
</span><span class="va">fmap</span><span> </span><span class="sy">(</span><span class="sy">*</span><span class="it">2</span><span class="sy">)</span><span> </span><span class="sy">[</span><span class="it">1</span><span class="sy">,</span><span> </span><span class="it">2</span><span class="sy">,</span><span> </span><span class="it">3</span><span class="sy">]</span><span> </span><span class="co">-- Output: [2, 4, 6]</span><span>
</span></code></pre></div>
<h4 id="3-monoids">3. Monoids</h4>
<ul>
<li>
<strong>What They Do</strong>: Provide a way to combine values using a binary operation and an identity element.
</li>
<li>
<strong>Key Functions</strong>: <code>&lt;&gt;</code> and <code>mempty</code>.
</li>
<li>
<strong>Why They Matter</strong>: Monoids ensure consistent and predictable value combinations, enabling operations like folding lists and aggregating data.
</li>
</ul>
<p>Example:</p>
<div class="source-code"><pre><code class="language-haskell"><span class="va">mconcat</span><span> </span><span class="sy">[</span><span class="sy">[</span><span class="it">1</span><span class="sy">,</span><span> </span><span class="it">2</span><span class="sy">]</span><span class="sy">,</span><span> </span><span class="sy">[</span><span class="it">3</span><span class="sy">,</span><span> </span><span class="it">4</span><span class="sy">]</span><span class="sy">]</span><span> </span><span class="co">-- Output: [1, 2, 3, 4]</span><span>
</span><span class="va">mconcat</span><span> </span><span class="sy">[</span><span class="cr">Sum</span><span> </span><span class="it">10</span><span class="sy">,</span><span> </span><span class="cr">Sum</span><span> </span><span class="it">20</span><span class="sy">,</span><span> </span><span class="cr">Sum</span><span> </span><span class="it">30</span><span class="sy">]</span><span> </span><span class="co">-- Output: Sum 60</span><span>
</span></code></pre></div>
<h4 id="4-semigroups">4. Semigroups</h4>
<ul>
<li>
<strong>What They Do</strong>: Provide a way to combine values without requiring an identity element.
</li>
<li>
<strong>Key Function</strong>: <code>&lt;&gt;</code>.
</li>
<li>
<strong>Why They Matter</strong>: Semigroups handle combining scenarios where no natural &quot;empty&quot; value exists.
</li>
</ul>
<p>Example:</p>
<div class="source-code"><pre><code class="language-haskell"><span class="va">sconcat</span><span> </span><span class="sy">(</span><span class="it">1</span><span> </span><span class="op">:|</span><span> </span><span class="sy">[</span><span class="it">2</span><span class="sy">,</span><span> </span><span class="it">3</span><span class="sy">,</span><span> </span><span class="it">4</span><span class="sy">]</span><span class="sy">)</span><span> </span><span class="co">-- Output: 10</span><span>
</span></code></pre></div>
<h4 id="5-applicatives">5. Applicatives</h4>
<ul>
<li>
<strong>What They Do</strong>: Extend Functors by allowing functions of multiple arguments to be applied to multiple contexts.
</li>
<li>
<strong>Key Functions</strong>: <code>pure</code> and <code>&lt;*&gt;</code>.
</li>
<li>
<strong>Why They Matter</strong>: Applicatives enable independent computations to be combined effortlessly.
</li>
</ul>
<p>Example:</p>
<div class="source-code"><pre><code class="language-haskell"><span class="va">pure</span><span> </span><span class="sy">(</span><span class="op">+</span><span class="sy">)</span><span> </span><span class="op">&lt;*&gt;</span><span> </span><span class="cr">Just</span><span> </span><span class="it">5</span><span> </span><span class="op">&lt;*&gt;</span><span> </span><span class="cr">Just</span><span> </span><span class="it">3</span><span> </span><span class="co">-- Output: Just 8</span><span>
</span><span class="va">pure</span><span> </span><span class="sy">(</span><span class="op">+</span><span class="sy">)</span><span> </span><span class="op">&lt;*&gt;</span><span> </span><span class="sy">[</span><span class="it">1</span><span class="sy">,</span><span> </span><span class="it">2</span><span class="sy">]</span><span> </span><span class="op">&lt;*&gt;</span><span> </span><span class="sy">[</span><span class="it">3</span><span class="sy">,</span><span> </span><span class="it">4</span><span class="sy">]</span><span> </span><span class="co">-- Output: [4, 5, 5, 6]</span><span>
</span></code></pre></div>
<h4 id="6-monads">6. Monads</h4>
<ul>
<li>
<strong>What They Do</strong>: Extend Applicatives to allow chaining dependent computations.
</li>
<li>
<strong>Key Functions</strong>: &gt;&gt;= (bind) and return.
</li>
<li>
<strong>Why They Matter</strong>: Monads enable sequential computations, error propagation, and side-effect handling in a safe and composable way.
</li>
</ul>
<p>Example:</p>
<div class="source-code"><pre><code class="language-haskell"><span class="cr">Just</span><span> </span><span class="it">5</span><span> </span><span class="op">&gt;&gt;=</span><span> </span><span class="va">x</span><span> </span><span class="sy">-&gt;</span><span> </span><span class="cr">Just</span><span> </span><span class="sy">(</span><span class="va">x</span><span> </span><span class="sy">*</span><span> </span><span class="it">2</span><span class="sy">)</span><span> </span><span class="co">-- Output: Just 10</span><span>
</span><span class="va">processData</span><span> </span><span class="sy">=</span><span> </span><span class="kw">do</span><span>
    </span><span class="va">user</span><span> </span><span class="sy">&lt;-</span><span> </span><span class="va">fetchUser</span><span> </span><span class="va">userId</span><span>
    </span><span class="va">orders</span><span> </span><span class="sy">&lt;-</span><span> </span><span class="va">fetchOrders</span><span> </span><span class="va">user</span><span>
    </span><span class="va">validateOrders</span><span> </span><span class="va">orders</span><span>
</span></code></pre></div>
<h4 id="7-the-do-notation">7. The do Notation</h4>
<ul>
<li>
<strong>What It Is</strong>: Syntactic sugar for chaining monadic computations.
</li>
<li>
<strong>Why It Matters</strong>: Makes monadic code more readable and easier to write.
</li>
</ul>
<p>Example:</p>
<div class="source-code"><pre><code class="language-haskell"><span class="va">processInput</span><span> </span><span class="sy">=</span><span> </span><span class="kw">do</span><span>
    </span><span class="va">x</span><span> </span><span class="sy">&lt;-</span><span> </span><span class="cr">Just</span><span> </span><span class="it">5</span><span>
    </span><span class="va">y</span><span> </span><span class="sy">&lt;-</span><span> </span><span class="cr">Just</span><span> </span><span class="it">10</span><span>
    </span><span class="va">return</span><span> </span><span class="sy">(</span><span class="va">x</span><span> </span><span class="op">+</span><span> </span><span class="va">y</span><span class="sy">)</span><span>
</span></code></pre></div>
<h3 id="exercises">Exercises</h3>
<h4 id="exercise-1-functors">Exercise 1: Functors</h4>
<p>Write a function using fmap to double all numbers in a list and wrap them in the Maybe context. Ensure the result is Nothing if the list is empty.</p>
<p>Example:</p>
<div class="source-code"><pre><code class="language-haskell"><span class="va">doubleList</span><span> </span><span class="sy">::</span><span> </span><span class="sy">[</span><span class="cr">Int</span><span class="sy">]</span><span> </span><span class="sy">-&gt;</span><span> </span><span class="cr">Maybe</span><span> </span><span class="sy">[</span><span class="cr">Int</span><span class="sy">]</span><span>
</span><span class="va">doubleList</span><span> </span><span class="sy">[</span><span class="sy">]</span><span> </span><span class="sy">=</span><span> </span><span class="cr">Nothing</span><span>
</span><span class="va">doubleList</span><span> </span><span class="va">xs</span><span> </span><span class="sy">=</span><span> </span><span class="co">-- Your implementation here</span><span>
</span></code></pre></div>
<h4 id="exercise-2-monoids">Exercise 2: Monoids</h4>
<p>Combine a list of Sum values into a single Sum using mconcat.</p>
<p>Example:</p>
<div class="source-code"><pre><code class="language-haskell"><span class="va">combineSums</span><span> </span><span class="sy">::</span><span> </span><span class="sy">[</span><span class="cr">Sum</span><span> </span><span class="cr">Int</span><span class="sy">]</span><span> </span><span class="sy">-&gt;</span><span> </span><span class="cr">Sum</span><span> </span><span class="cr">Int</span><span>
</span><span class="va">combineSums</span><span> </span><span class="sy">=</span><span> </span><span class="co">-- Your implementation here</span><span>
</span></code></pre></div>
<h4 id="exercise-3-applicatives">Exercise 3: Applicatives</h4>
<p>Write a function that takes two Maybe values and applies a function to combine them. Use <code>&lt;*&gt;</code>.</p>
<p>Example:</p>
<div class="source-code"><pre><code class="language-haskell"><span class="va">combineMaybes</span><span> </span><span class="sy">::</span><span> </span><span class="cr">Maybe</span><span> </span><span class="cr">Int</span><span> </span><span class="sy">-&gt;</span><span> </span><span class="cr">Maybe</span><span> </span><span class="cr">Int</span><span> </span><span class="sy">-&gt;</span><span> </span><span class="cr">Maybe</span><span> </span><span class="cr">Int</span><span>
</span><span class="va">combineMaybes</span><span> </span><span class="va">x</span><span> </span><span class="va">y</span><span> </span><span class="sy">=</span><span> </span><span class="co">-- Your implementation here</span><span>
</span></code></pre></div>
<h4 id="exercise-4-semigroups">Exercise 4: Semigroups</h4>
<p>Use the <code>sconcat</code> function to combine a non-empty list of <code>Max</code> values and find the maximum value.</p>
<p>Example:</p>
<div class="source-code"><pre><code class="language-haskell"><span class="va">findMax</span><span> </span><span class="sy">::</span><span> </span><span class="cr">NonEmpty</span><span> </span><span class="sy">(</span><span class="cr">Max</span><span> </span><span class="cr">Int</span><span class="sy">)</span><span> </span><span class="sy">-&gt;</span><span> </span><span class="cr">Max</span><span> </span><span class="cr">Int</span><span>
</span><span class="va">findMax</span><span> </span><span class="sy">=</span><span> </span><span class="co">-- Your implementation here</span><span>
</span></code></pre></div>
<h4 id="exercise-5-monads">Exercise 5: Monads</h4>
<p>Write a <code>do</code> block to validate and process user input using the <code>Maybe</code> Monad.</p>
<p>Example:</p>
<div class="source-code"><pre><code class="language-haskell"><span class="va">processMaybe</span><span> </span><span class="sy">::</span><span> </span><span class="cr">Maybe</span><span> </span><span class="cr">Int</span><span> </span><span class="sy">-&gt;</span><span> </span><span class="cr">Maybe</span><span> </span><span class="cr">Int</span><span>
</span><span class="va">processMaybe</span><span> </span><span class="va">input</span><span> </span><span class="sy">=</span><span> </span><span class="kw">do</span><span>
    </span><span class="co">-- Your implementation here</span><span>
</span></code></pre></div>
<h4 id="exercise-6-simulating-a-shopping-cart">Exercise 6: Simulating a Shopping Cart</h4>
<p>Write a function that simulates a simple shopping cart system. The system:</p>
<ol>
<li>
<strong>Validates input quantities</strong> (using <code>Maybe</code> to handle invalid inputs).
</li>
<li>
<strong>Applies a discount</strong> if the cart total exceeds a certain amount (using Applicatives to combine independent calculations).
</li>
<li>
<strong>Logs the results</strong> (using a Monad to sequence actions and include context).
</li>
</ol>
<p>Requirements:</p>
<ul>
<li>
Use <code>fmap</code> to adjust item prices based on a fixed multiplier (e.g., tax or currency conversion).
</li>
<li>
Use <code>&lt;*&gt;</code> to calculate the total cost of items and apply a discount if necessary.
</li>
<li>
Use <code>&gt;&gt;=</code> or <code>do</code> notation to handle potential errors in item quantities and return the final cart result.
</li>
</ul>
<div class="source-code"><pre><code class="language-haskell"><span class="va">cart</span><span> </span><span class="sy">=</span><span> </span><span class="sy">[</span><span class="cr">Item</span><span> </span><span class="st">&quot;Apple&quot;</span><span> </span><span class="ra">1.5</span><span> </span><span class="it">4</span><span class="sy">,</span><span> </span><span class="cr">Item</span><span> </span><span class="st">&quot;Banana&quot;</span><span> </span><span class="ra">0.8</span><span> </span><span class="it">10</span><span class="sy">,</span><span> </span><span class="cr">Item</span><span> </span><span class="st">&quot;Orange&quot;</span><span> </span><span class="ra">2.0</span><span> </span><span class="it">3</span><span class="sy">]</span><span>

</span><span class="va">processCart</span><span> </span><span class="sy">::</span><span> </span><span class="cr">Double</span><span> </span><span class="sy">-&gt;</span><span> </span><span class="cr">Cart</span><span> </span><span class="sy">-&gt;</span><span> </span><span class="cr">Maybe</span><span> </span><span class="cr">Double</span><span>
</span><span class="va">processCart</span><span> </span><span class="va">threshold</span><span> </span><span class="va">cart</span><span> </span><span class="sy">=</span><span> </span><span class="kw">do</span><span>
    </span><span class="co">-- Your implementation here</span><span>

</span><span class="va">main</span><span> </span><span class="sy">::</span><span> </span><span class="cr">IO</span><span> </span><span class="sy">(</span><span class="sy">)</span><span>
</span><span class="va">main</span><span> </span><span class="sy">=</span><span> </span><span class="kw">do</span><span>
    </span><span class="va">print</span><span> </span><span class="op">$</span><span> </span><span class="va">processCart</span><span> </span><span class="it">20</span><span> </span><span class="va">cart</span><span>
    </span><span class="co">-- Output: Just 19.44 (after discount)</span><span>

    </span><span class="va">print</span><span> </span><span class="op">$</span><span> </span><span class="va">processCart</span><span> </span><span class="it">20</span><span> </span><span class="sy">[</span><span class="cr">Item</span><span> </span><span class="st">&quot;Apple&quot;</span><span> </span><span class="ra">1.5</span><span> </span><span class="sy">(</span><span class="it">-4</span><span class="sy">)</span><span class="sy">]</span><span>
    </span><span class="co">-- Output: Nothing (invalid quantity)</span><span>
</span></code></pre></div>
<p><a href="/landing/Blog/Chapter5">Previous Chapter</a> |
<a href="/landing/Blog/Chapter7">Next Chapter</a></p>
</div></div></body></html>