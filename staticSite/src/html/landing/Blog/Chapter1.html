<html lang="en"><head><style>
/* Markdown Shell */
.containerBlog {
   padding: 200px;
   background-color: black;
   color: white;
   font-size: 20px;
   font-family: Georgia, serif;
}

.containerBlog ol {
   list-style-type: decimal;
   padding-left: 2.5rem;
}
.containerBlog ul {
   list-style-type: disc;
   padding-left: 2.5rem;
}

.containerBlog td {
   padding: 3px;
   border-color: #888;
}

.containerBlog li {
   padding: 5px 10px;
}

.containerBlog p {
   padding: 10px 0px;
}

.containerBlog a {
   color: #00B9DA;
   text-decoration: none;
}

.containerBlog p code {
  background-color: #D3D3D3;
  padding: 0px 3px;
  border-radius: 0.5rem;
}

.containerBlog h1 {
  padding: 25px 0px;
  font-weight: bold;
  font-size: 2em;
  color: #fff4f4;
  text-decoration: underline;
}
.containerBlog h2 {
  padding: 25px 0px;
  font-weight: bold;
  font-size: 1.5em;
  color: #fff4f4;
  text-decoration: underline;
}
.containerBlog h3 {
  padding: 25px 0px;
  font-weight: bold;
  font-size:1.17em;
  color: #fff4f4;
  text-decoration: underline;
}
.containerBlog h4 {
  padding: 25px 0px;
  font-weight: bold;
  font-size: 1em;
  color: #fff4f4;
  text-decoration: underline;
}
.containerBlog h5 {
  padding: 25px 0px;
  font-weight: bold;
  font-size: 0.83em;
  color: #fff4f4;
  text-decoration: underline;
}



/* Otherwise comments can go on into infinity */
span.co {
  word-break: break-word;        /* Safe wrap on words */
  overflow-wrap: anywhere;       /* Force wrap anywhere if needed */
  white-space: normal;           /* Allow wrapping */
}


code:not([class]) {
  /* your styles here */
  background-color: white;
  padding: 4px;
  border-radius: 5px;
}

code span {
  display: inline;
  white-space: pre;
}

.source-code {
  padding: 8px;
  border-color: white;
  background-color: black;
}

}
/* One off haskell constructs */
code {
  color: #154dcb;
  font-weight: bold;
}

div.source-code {
  overflow-x:auto;
  max-width:100%;
}

code.language-haskell {
  overflow-x:auto;
  max-width:100%;
}

/* Haskell Syntax */
.pr {
   color: #F8E473;
}
.op {
   color: gold;
}
.sy {
   color: #FADA5E;
}
.co {
   color: green;
}
.cr {
   color: #af64ff;
}
.va {
   color: #6693F5; 
}
.kw {
    color: #f0883e;
}

/* Haskell Syntax - Literals */
.st {
  color: #a5d6ff;
}
.ch {
  color: #2E3A59;
}
.it {}
.ra {}


/* Other Languages Via Skylighting Tokenizer */

.pp {
  color: blue;
}
.im {
  color: green;
}
.dt {
  color: green;
}
.cf {
  color: orange;
}
/*Like char */
.sc {
  color: orange;
}
/* java func */
.fu {
  color: #6693F5;
}

/* base color C lang */
.language-c {
  color: #6693F5;
}

.language-bash {
  color: #154dcb;
  font-weight: bold;
}

.language-nix {
  color: grey;
  font-weight: bold;
}

.language-java {
  color: #6693F5;
}
.language-csharp {
  color: #E3B778;
}
.language-python {
  color: #E3B778;
}
</style><style>a { color: #00B9DA; text-decoration: none; }</style></head><body><div class="fixed top-0 left-0 w-full h-full overflow-auto z-10 scroll-smooth"><div class="containerBlog"><h1 id="chapter-1-types-functions-domain-theory">Chapter 1: Types, Functions &amp; Domain Theory</h1>
<ol>
<li>
<a href="/landing/Blog/Chapter1#introduction-to-types">Introduction to Types</a>
</li>
<li>
<a href="/landing/Blog/Chapter1#simple-types-and-type-signatures">Simple Types and Type Signatures</a>
</li>
<li>
<a href="/landing/Blog/Chapter1#domain-driven-design">Domain-Driven Design</a>
</li>
<li>
<a href="/landing/Blog/Chapter1#pairing-domain-theory-with-type-theory">Pairing Domain Theory with Type Theory</a>
</li>
<li>
<a href="/landing/Blog/Chapter1#advanced-type-concepts">Advanced Type Concepts</a>
</li>
<li>
<a href="/landing/Blog/Chapter1#recap">Recap &amp; Exercises</a>
</li>
</ol>
<h2 id="introduction-to-types">Introduction to Types</h2>
<h3 id="what-are-types">What Are Types?</h3>
<p>Types are fundamental to understanding and writing robust code in Haskell. They are not just a way to categorize data but are crucial to how we model the real world within our applications. The closer our types mirror the real world, the easier our applications become to reason about, and the more robust they become. Let’s dive deeper into what types really are:</p>
<ul>
<li>
<p><strong>Types as Categorization</strong>: Types categorize data into labelled sets with one or more variations. For instance, a <code>Bool</code> type categorizes data as either <code>True</code> or <code>False</code>, while a <code>String</code> type categorizes sequences of characters.</p>
</li>
<li>
<p><strong>Types Represent Information</strong>: They represent the kinds of information our application processes. For example, an <code>Integer</code> type represents whole numbers, which might be used to count items or represent IDs.</p>
</li>
<li>
<p><strong>Types in Functions</strong>: In Haskell, types are used in functions to ensure that functions receive and return the correct kinds of data. This is crucial because it allows us to predict and enforce the behavior of our functions. Unlike in some other languages, Haskell functions always return a value and cannot mutate state directly. This means that the internal workings of functions must also be correct, as the types will enforce valid input and output.</p>
</li>
</ul>
<h3 id="core-type-declarations-in-haskell">Core Type Declarations in Haskell</h3>
<p>Before we delve into function examples, let&#39;s explore the basic building blocks of Haskell types: data declarations, type declarations, and newtype declarations.</p>
<h4 id="1-data-declarations">1. <strong>Data Declarations</strong></h4>
<ul>
<li>
<p><strong>Purpose</strong>: A <code>data</code> declaration is used to define a new algebraic data type. This is the most common way to define new types in Haskell.</p>
</li>
<li>
<p><strong>Syntax</strong>:</p>
<div class="source-code"><pre><code class="language-haskell"><span class="kw">data</span><span> </span><span class="cr">Color</span><span> </span><span class="sy">=</span><span> </span><span class="cr">Red</span><span> </span><span class="sy">|</span><span> </span><span class="cr">Green</span><span> </span><span class="sy">|</span><span> </span><span class="cr">Blue</span><span>
</span></code></pre></div>
<p>Here, <code>Color</code> is a new type with three possible values: <code>Red</code>, <code>Green</code>, and <code>Blue</code>. These values are called constructors. The <code>data</code> keyword allows us to define a type that can have multiple forms.</p>
</li>
</ul>
<h4 id="2-type-declarations">2. <strong>Type Declarations</strong></h4>
<ul>
<li>
<p><strong>Purpose</strong>: A <code>type</code> declaration creates a type synonym, which is essentially an alias for an existing type. It doesn&#39;t create a new type but makes the code more readable.</p>
</li>
<li>
<p><strong>Syntax</strong>:</p>
<div class="source-code"><pre><code class="language-haskell"><span class="kw">type</span><span> </span><span class="cr">Name</span><span> </span><span class="sy">=</span><span> </span><span class="cr">String</span><span>
</span></code></pre></div>
<p>In this example, <code>Name</code> is a type synonym for <code>String</code>. Everywhere you see <code>Name</code> in the code, it is just a <code>String</code> underneath, but using <code>Name</code> can make your code more descriptive.</p>
</li>
</ul>
<h4 id="3-newtype-declarations">3. <strong>Newtype Declarations</strong></h4>
<ul>
<li>
<p><strong>Purpose</strong>: The <code>newtype</code> declaration creates a new type that is distinct from its underlying type but has the same runtime representation. It’s often used for type safety without runtime overhead.</p>
</li>
<li>
<p><strong>Syntax</strong>:</p>
<div class="source-code"><pre><code class="language-haskell"><span class="kw">newtype</span><span> </span><span class="cr">CustomerId</span><span> </span><span class="sy">=</span><span> </span><span class="cr">CustomerId</span><span> </span><span class="cr">Int</span><span>
</span></code></pre></div>
<p>Here, <code>CustomerId</code> is a new type that wraps an <code>Int</code>. While it’s just an <code>Int</code> at runtime, the type system treats <code>CustomerId</code> and <code>Int</code> as distinct, preventing you from accidentally mixing them up.</p>
</li>
</ul>
<h4 id="4-function-definitions">4. <strong>Function Definitions</strong></h4>
<ul>
<li>
<p><strong>Purpose</strong>: Functions in Haskell are first-class citizens, meaning they can be passed as arguments, returned from other functions, and assigned to variables. Functions also have types, and these types are crucial in ensuring that functions interact with data correctly.</p>
</li>
<li>
<p><strong>Syntax</strong>:</p>
<div class="source-code"><pre><code class="language-haskell"><span class="va">greet</span><span> </span><span class="sy">::</span><span> </span><span class="cr">Name</span><span> </span><span class="sy">-&gt;</span><span> </span><span class="cr">String</span><span>
</span><span class="va">greet</span><span> </span><span class="va">name</span><span> </span><span class="sy">=</span><span> </span><span class="st">&quot;Hello, &quot;</span><span> </span><span class="op">++</span><span> </span><span class="va">name</span><span> </span><span class="op">++</span><span> </span><span class="st">&quot;!&quot;</span><span>
</span></code></pre></div>
<p>In this example, <code>greet</code> is a function that takes a <code>Name</code> (which is a synonym for <code>String</code>) and returns a <code>String</code>. The type signature <code>Name -&gt; String</code> ensures that <code>greet</code> only accepts a <code>Name</code> as input and will always produce a <code>String</code> as output.</p>
</li>
</ul>
<h3 id="how-are-types-in-fp-different">How Are Types in FP Different?</h3>
<p>In Haskell, types are first-class citizens. This means that they are treated as values by the compiler, allowing you to encode complex logic directly into your types. This capability leads to predictable and safe code because the types themselves enforce the rules of your application.</p>
<p><strong>Comparison with Other Languages:</strong></p>
<ul>
<li>
In languages like C#, types are often tied to classes and objects, and while types are important, they don’t offer the same level of expressiveness and safety. In C#, it’s possible to misuse types, especially when dealing with inheritance and mutable state, leading to unpredictable behavior deep in the execution of a program.
</li>
<li>
Haskell’s type system, based on the Hindley-Milner type system, is much more powerful. It supports features like type inference, algebraic data types (ADTs), and pattern matching, all of which allow you to write concise yet expressive code without sacrificing safety.
</li>
</ul>
<h3 id="why-types-matter">Why Types Matter</h3>
<p>Having strict and well-thought-out types is crucial to robust system design. Let’s break down why:</p>
<ul>
<li>
<p><strong>Clarity and Predictability</strong>: Types provide a clear contract for what a function does. When you look at a Haskell type signature, you can often understand what the function does without even seeing the implementation. This clarity is invaluable, especially in large codebases where multiple developers are working together. It reduces the likelihood of bugs and makes the system easier to maintain.</p>
</li>
<li>
<p><strong>Avoiding Runtime Errors</strong>: In dynamically-typed or loosely-typed languages, many errors only appear at runtime, leading to potential crashes or unpredictable behavior. Haskell’s strong type system catches these errors at compile time, significantly reducing the risk of runtime failures.</p>
</li>
<li>
<p><strong>Reasoning About Code</strong>: In Haskell, you can often reason about what a piece of code does just by looking at its type signature. This allows you to find and apply functions that match the type signature you need, often without needing to write new code. Hoogle, a Haskell-specific search engine, lets you search for functions by their type signatures, making it incredibly easy to integrate the right function into your program.</p>
</li>
</ul>
<h3 id="example-compiler-failures-in-procedural-programming">Example: Compiler Failures in Procedural Programming</h3>
<p>Let’s explore some examples where Haskell’s type system helps prevent runtime errors that are common in procedural languages like C.</p>
<h4 id="procedural-example-in-c">Procedural Example in C:</h4>
<div class="source-code"><pre><code class="language-c"><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span>

<span class="dt">int</span><span> divide(</span><span class="dt">int</span><span> a, </span><span class="dt">int</span><span> b) {</span>
<span>    </span><span class="cf">return</span><span> a / b;</span>
<span>}</span>

<span class="dt">int</span><span> main() {</span>
<span>    </span><span class="dt">int</span><span> result = divide(</span><span class="dv">10</span><span>, </span><span class="dv">0</span><span>);</span>
<span>    printf(</span><span class="st">&quot;Result: %dn&quot;</span><span>, result);</span>
<span>    </span><span class="cf">return</span><span> </span><span class="dv">0</span><span>;</span>
<span>}</span>
</code></pre></div>
<p>Expected Error:</p>
<ul>
<li>
When you run this C code, dividing by zero will lead to undefined behavior, which can cause a crash or other unexpected results.
</li>
</ul>
<p>Typical Error Output:</p>
<ul>
<li>
Depending on the system, you might see an error like “Floating point exception: division by zero” or the program might just crash without a clear error message.
</li>
</ul>
<p>Safe Haskell Equivalent:</p>
<div class="source-code"><pre><code class="language-haskell"><span class="va">divide</span><span> </span><span class="sy">::</span><span> </span><span class="cr">Integer</span><span> </span><span class="sy">-&gt;</span><span> </span><span class="cr">Integer</span><span> </span><span class="sy">-&gt;</span><span> </span><span class="cr">Maybe</span><span> </span><span class="cr">Integer</span><span>
</span><span class="va">divide</span><span> </span><span class="sy">_</span><span> </span><span class="it">0</span><span> </span><span class="sy">=</span><span> </span><span class="cr">Nothing</span><span>
</span><span class="va">divide</span><span> </span><span class="va">a</span><span> </span><span class="va">b</span><span> </span><span class="sy">=</span><span> </span><span class="cr">Just</span><span> </span><span class="sy">(</span><span class="va">a</span><span> </span><span class="sy">`</span><span class="va">div</span><span class="sy">`</span><span> </span><span class="va">b</span><span class="sy">)</span><span>

</span><span class="va">main</span><span> </span><span class="sy">::</span><span> </span><span class="cr">IO</span><span> </span><span class="sy">(</span><span class="sy">)</span><span>
</span><span class="va">main</span><span> </span><span class="sy">=</span><span> </span><span class="kw">case</span><span> </span><span class="va">divide</span><span> </span><span class="it">10</span><span> </span><span class="it">0</span><span> </span><span class="kw">of</span><span>
    </span><span class="cr">Nothing</span><span> </span><span class="sy">-&gt;</span><span> </span><span class="va">putStrLn</span><span> </span><span class="st">&quot;Cannot divide by zero!&quot;</span><span>
    </span><span class="cr">Just</span><span> </span><span class="va">result</span><span> </span><span class="sy">-&gt;</span><span> </span><span class="va">putStrLn</span><span> </span><span class="sy">(</span><span class="st">&quot;Result: &quot;</span><span> </span><span class="op">++</span><span> </span><span class="va">show</span><span> </span><span class="va">result</span><span class="sy">)</span><span>
</span></code></pre></div>
<p>Expected Result:</p>
<ul>
<li>
This Haskell code safely handles the division by zero case, preventing a runtime error. Instead of crashing, it prints a friendly message: “Cannot divide by zero!”
</li>
</ul>
<p>Explanation:</p>
<ul>
<li>
The use of Maybe in the type signature indicates that the result of divide might be Nothing (indicating an invalid operation) or Just a value (indicating a valid division). This forces the programmer to handle both cases explicitly, preventing runtime surprises.
</li>
</ul>
<h4 id="the-magic-of-the-hindleymilner-type-system">The Magic of the Hindley-Milner Type System</h4>
<p>One of the things that makes Haskell’s type system so powerful is the Hindley-Milner type system, which supports type inference and currying:</p>
<ul>
<li>
Type Inference: The compiler can often deduce the types of expressions without explicit annotations. This reduces boilerplate and lets you write concise code while still enjoying the safety of static typing.
</li>
<li>
Currying: In Haskell, every function is curried by default, meaning that functions with multiple arguments are treated as a series of functions that each take a single argument. This allows for partial application, where a function is applied to some of its arguments, returning another function that takes the remaining arguments. The Hindley-Milner type system ensures that even partially applied functions are type-safe at every step.
</li>
</ul>
<h4 id="example-of-currying-in-haskell">Example of Currying in Haskell:</h4>
<div class="source-code"><pre><code class="language-haskell"><span class="va">add</span><span> </span><span class="sy">::</span><span> </span><span class="cr">Integer</span><span> </span><span class="sy">-&gt;</span><span> </span><span class="cr">Integer</span><span> </span><span class="sy">-&gt;</span><span> </span><span class="cr">Integer</span><span>
</span><span class="va">add</span><span> </span><span class="va">x</span><span> </span><span class="va">y</span><span> </span><span class="sy">=</span><span> </span><span class="va">x</span><span> </span><span class="op">+</span><span> </span><span class="va">y</span><span>

</span><span class="va">increment</span><span> </span><span class="sy">::</span><span> </span><span class="cr">Integer</span><span> </span><span class="sy">-&gt;</span><span> </span><span class="cr">Integer</span><span>
</span><span class="va">increment</span><span> </span><span class="sy">=</span><span> </span><span class="va">add</span><span> </span><span class="it">1</span><span>
</span></code></pre></div>
<p>Here, add is a curried function that takes two Integer arguments. By partially applying add with the value 1, we create a new function increment that only takes a single argument and adds 1 to it. The type system ensures that this transformation is valid and safe.</p>
<h2 id="simple-types-and-type-signatures">Simple Types and Type Signatures</h2>
<h3 id="how-to-read-type-signatures">How to Read Type Signatures</h3>
<p>Type signatures are an essential part of Haskell programming. They describe the types of the inputs a function takes and the type of output it produces. Understanding how to read and interpret these signatures is critical to writing and maintaining robust Haskell code.</p>
<ul>
<li>
<p><strong>Basic Type Signature</strong>: A typical type signature in Haskell looks like this:</p>
<div class="source-code"><pre><code class="language-haskell"><span class="va">functionName</span><span> </span><span class="sy">::</span><span> </span><span class="cr">InputType1</span><span> </span><span class="sy">-&gt;</span><span> </span><span class="cr">InputType2</span><span> </span><span class="sy">-&gt;</span><span> </span><span class="cr">OutputType</span><span>
</span></code></pre></div>
</li>
</ul>
<p>This means that the function functionName takes two inputs: one of type InputType1 and one of type InputType2, and it returns an output of type OutputType.</p>
<p>Example:</p>
<div class="source-code"><pre><code class="language-haskell"><span class="va">add</span><span> </span><span class="sy">::</span><span> </span><span class="cr">Int</span><span> </span><span class="sy">-&gt;</span><span> </span><span class="cr">Int</span><span> </span><span class="sy">-&gt;</span><span> </span><span class="cr">Int</span><span>
</span><span class="va">add</span><span> </span><span class="va">x</span><span> </span><span class="va">y</span><span> </span><span class="sy">=</span><span> </span><span class="va">x</span><span> </span><span class="op">+</span><span> </span><span class="va">y</span><span>
</span></code></pre></div>
<p>In this example, add takes two integers (Int -&gt; Int) and returns another integer (Int).</p>
<ul>
<li>
<strong>Complex Type Signatures</strong>: Type signatures can get more complex, especially in larger Haskell libraries like Obelisk or Reflex, where cross-platform mobile development is involved.
</li>
</ul>
<p>Example:</p>
<div class="source-code"><pre><code class="language-haskell"><span class="va">widgetHold</span><span> </span><span class="sy">::</span><span> </span><span class="kw">forall</span><span> </span><span class="va">t</span><span> </span><span class="va">m</span><span> </span><span class="va">a</span><span class="op">.</span><span> </span><span class="sy">(</span><span class="cr">MonadHold</span><span> </span><span class="va">t</span><span> </span><span class="va">m</span><span class="sy">,</span><span> </span><span class="cr">PostBuild</span><span> </span><span class="va">t</span><span> </span><span class="va">m</span><span class="sy">)</span><span> </span><span class="sy">=&gt;</span><span> </span><span class="va">m</span><span> </span><span class="va">a</span><span> </span><span class="sy">-&gt;</span><span> </span><span class="cr">Event</span><span> </span><span class="va">t</span><span> </span><span class="sy">(</span><span class="va">m</span><span> </span><span class="va">a</span><span class="sy">)</span><span> </span><span class="sy">-&gt;</span><span> </span><span class="va">m</span><span> </span><span class="sy">(</span><span class="cr">Dynamic</span><span> </span><span class="va">t</span><span> </span><span class="va">a</span><span class="sy">)</span><span>
</span></code></pre></div>
<p>Let’s break this down:</p>
<ul>
<li>
<code>forall t m a.</code>: This means the function is polymorphic over types t, m, and a.
</li>
<li>
<code>(MonadHold t m, PostBuild t m) =&gt;</code>: These are type class constraints, meaning m must be an instance of MonadHold and PostBuild.
</li>
<li>
<code>m a -&gt; Event t (m a) -&gt; m (Dynamic t a)</code>: This is the core function signature. It takes an m a, an Event t (m a), and returns an m (Dynamic t a).
</li>
</ul>
<p>Even though this looks complicated, it’s fundamentally still the same concept of specifying the flow of types through the function.</p>
<ul>
<li>
<strong>Partial Application and Currying</strong>: Haskell functions are curried by default. This means every function actually takes one argument and returns another function if more arguments are needed. It’s important to remember that partial application allows you to call a function with fewer arguments than it expects, returning a new function that waits for the remaining arguments.
</li>
</ul>
<p>Currying Example:</p>
<div class="source-code"><pre><code class="language-haskell"><span class="va">add</span><span> </span><span class="sy">::</span><span> </span><span class="cr">Int</span><span> </span><span class="sy">-&gt;</span><span> </span><span class="cr">Int</span><span> </span><span class="sy">-&gt;</span><span> </span><span class="cr">Int</span><span>
</span><span class="va">add</span><span> </span><span class="va">x</span><span> </span><span class="va">y</span><span> </span><span class="sy">=</span><span> </span><span class="va">x</span><span> </span><span class="op">+</span><span> </span><span class="va">y</span><span>

</span><span class="va">increment</span><span> </span><span class="sy">::</span><span> </span><span class="cr">Int</span><span> </span><span class="sy">-&gt;</span><span> </span><span class="cr">Int</span><span>
</span><span class="va">increment</span><span> </span><span class="sy">=</span><span> </span><span class="va">add</span><span> </span><span class="it">1</span><span>
</span></code></pre></div>
<p>In this example, add takes two integers, but by partially applying it with the argument 1, we create a new function increment that takes only one integer and adds 1 to it.</p>
<p>Haskell hides this complexity, but understanding currying is crucial when reading type signatures with multiple -&gt; symbols. You can think of Int -&gt; Int -&gt; Int as Int -&gt; (Int -&gt; Int)—a function that returns another function.</p>
<p>Explicit Currying Example:</p>
<div class="source-code"><pre><code class="language-haskell"><span class="va">addCurried</span><span> </span><span class="sy">::</span><span> </span><span class="cr">Int</span><span> </span><span class="sy">-&gt;</span><span> </span><span class="cr">Int</span><span> </span><span class="sy">-&gt;</span><span> </span><span class="cr">Int</span><span>
</span><span class="va">addCurried</span><span> </span><span class="sy">=</span><span> </span><span class="va">x</span><span> </span><span class="sy">-&gt;</span><span> </span><span class="va">y</span><span> </span><span class="sy">-&gt;</span><span> </span><span class="va">x</span><span> </span><span class="op">+</span><span> </span><span class="va">y</span><span>
</span></code></pre></div>
<p>This is equivalent to the earlier add function, but here you can explicitly see how addCurried takes one argument (x), and returns a function that takes the next argument (y), and then produces the sum of x and y.</p>
<ul>
<li>
A Quick Note on forall: You might come across forall in complex type signatures like the one shown above. forall introduces type variables that can be replaced with any type. It’s often used in polymorphic functions where the types aren’t known in advance. By default, Haskell assumes forall is present in type signatures without it being explicitly written, so you don’t need to worry about it in most cases.
</li>
</ul>
<h4 id="primitive-types">Primitive Types</h4>
<p>Primitive types in Haskell are the basic building blocks for more complex types. They represent simple values like numbers, characters, booleans, etc. These types are fundamental to every Haskell program and allow you to represent data in the most basic forms.</p>
<h4 id="common-primitive-types">Common Primitive Types</h4>
<ul>
<li>
Int: Represents a fixed-size integer. It’s faster but limited in range. Example: 42.
</li>
<li>
Integer: Represents an arbitrary-precision integer, meaning it can handle very large numbers. Example: 12345678901234567890.
</li>
<li>
Float: Represents a single-precision floating-point number. Example: 3.14.
</li>
<li>
Double: Represents a double-precision floating-point number, which is more precise than Float. Example: 2.71828.
</li>
<li>
Char: Represents a single character. Example: &#39;a&#39;.
</li>
<li>
Bool: Represents a boolean value, which can be either True or False. Example: True.
</li>
<li>
String: Represents a sequence of characters (which is actually a list of Char values). Example: &quot;Hello, world!&quot;.
</li>
</ul>
<h4 id="primitive-type-examples">Primitive Type Examples</h4>
<div class="source-code"><pre><code class="language-haskell"><span class="co">-- Integer</span><span>
</span><span class="va">age</span><span> </span><span class="sy">::</span><span> </span><span class="cr">Int</span><span>
</span><span class="va">age</span><span> </span><span class="sy">=</span><span> </span><span class="it">30</span><span>

</span><span class="co">-- Floating-point number</span><span>
</span><span class="va">piValue</span><span> </span><span class="sy">::</span><span> </span><span class="cr">Double</span><span>
</span><span class="va">piValue</span><span> </span><span class="sy">=</span><span> </span><span class="ra">3.14159</span><span>

</span><span class="co">-- Boolean</span><span>
</span><span class="va">isSunny</span><span> </span><span class="sy">::</span><span> </span><span class="cr">Bool</span><span>
</span><span class="va">isSunny</span><span> </span><span class="sy">=</span><span> </span><span class="cr">True</span><span>

</span><span class="co">-- Character</span><span>
</span><span class="va">initial</span><span> </span><span class="sy">::</span><span> </span><span class="cr">Char</span><span>
</span><span class="va">initial</span><span> </span><span class="sy">=</span><span> </span><span class="ch">&#39;H&#39;</span><span>

</span><span class="co">-- String</span><span>
</span><span class="va">greeting</span><span> </span><span class="sy">::</span><span> </span><span class="cr">String</span><span>
</span><span class="va">greeting</span><span> </span><span class="sy">=</span><span> </span><span class="st">&quot;Hello, Haskell!&quot;</span><span>
</span></code></pre></div>
<p>These types are the building blocks for more complex data structures that you’ll define using algebraic data types (ADTs), which we’ll cover shortly.</p>
<h4 id="polymorphic-types">Polymorphic Types</h4>
<p>Polymorphic types allow functions to be more flexible by operating on any type. Polymorphic functions are functions that work with type variables, rather than specific types.</p>
<p><strong>Example of Polymorphic Types:</strong></p>
<div class="source-code"><pre><code class="language-haskell"><span class="va">identity</span><span> </span><span class="sy">::</span><span> </span><span class="va">a</span><span> </span><span class="sy">-&gt;</span><span> </span><span class="va">a</span><span>
</span><span class="va">identity</span><span> </span><span class="va">x</span><span> </span><span class="sy">=</span><span> </span><span class="va">x</span><span>
</span></code></pre></div>
<p>In this example, identity is a polymorphic function. The type variable a can be replaced with any type. This function takes an input of type a and returns a value of the same type.</p>
<h4 id="type-class-constraints">Type Class Constraints</h4>
<p>You can restrict polymorphic types using type class constraints. This allows the polymorphic function to work only with types that implement a particular type class.</p>
<p><strong>Example with Type Class Constraints:</strong></p>
<div class="source-code"><pre><code class="language-haskell"><span class="va">addValues</span><span> </span><span class="sy">::</span><span> </span><span class="cr">Num</span><span> </span><span class="va">a</span><span> </span><span class="sy">=&gt;</span><span> </span><span class="va">a</span><span> </span><span class="sy">-&gt;</span><span> </span><span class="va">a</span><span> </span><span class="sy">-&gt;</span><span> </span><span class="va">a</span><span>
</span><span class="va">addValues</span><span> </span><span class="va">x</span><span> </span><span class="va">y</span><span> </span><span class="sy">=</span><span> </span><span class="va">x</span><span> </span><span class="op">+</span><span> </span><span class="va">y</span><span>
</span></code></pre></div>
<p>Here, <code>Num a =&gt;</code> is a type class constraint that restricts a to types that are instances of the Num type class (such as Int, Float, etc.). This ensures that addValues can only be used with numeric types.</p>
<h3 id="algebraic-data-types-adts">Algebraic Data Types (ADTs)</h3>
<p>Algebraic Data Types (ADTs) allow you to define custom types by combining other types. ADTs are foundational to Haskell and functional programming, allowing you to model complex data structures in a way that’s easy to reason about.</p>
<h4 id="sum-types-and-product-types">Sum Types and Product Types</h4>
<ul>
<li>
<strong>Sum Types</strong>: Represent a choice between multiple alternatives. A value of a sum type can take one of several forms.
</li>
</ul>
<p>Example of a Sum Type:</p>
<div class="source-code"><pre><code class="language-haskell"><span class="kw">data</span><span> </span><span class="cr">Color</span><span> </span><span class="sy">=</span><span> </span><span class="cr">Red</span><span> </span><span class="sy">|</span><span> </span><span class="cr">Green</span><span> </span><span class="sy">|</span><span> </span><span class="cr">Blue</span><span>
</span></code></pre></div>
<p>Here, Color is a sum type because a value of type Color can be either Red, Green, or Blue.</p>
<ul>
<li>
<strong>Product Types</strong>: Combine multiple types into a single type. A value of a product type contains values for each of the constituent types.
</li>
</ul>
<p>Example of a Product Type:</p>
<div class="source-code"><pre><code class="language-haskell"><span class="kw">data</span><span> </span><span class="cr">Point</span><span> </span><span class="sy">=</span><span> </span><span class="cr">Point</span><span> </span><span class="cr">Int</span><span> </span><span class="cr">Int</span><span>
</span></code></pre></div>
<p>Here, Point is a product type that contains two Int values representing the x and y coordinates of a point.</p>
<h4 id="defining-and-using-adts">Defining and Using ADTs</h4>
<p>You can use ADTs to model complex real-world data in your application.</p>
<p>Example:</p>
<div class="source-code"><pre><code class="language-haskell"><span class="kw">data</span><span> </span><span class="cr">Shape</span><span> </span><span class="sy">=</span><span> </span><span class="cr">Circle</span><span> </span><span class="cr">Float</span><span>
           </span><span class="sy">|</span><span> </span><span class="cr">Rectangle</span><span> </span><span class="cr">Float</span><span> </span><span class="cr">Float</span><span>
           </span><span class="sy">|</span><span> </span><span class="cr">Square</span><span> </span><span class="cr">Float</span><span>
</span></code></pre></div>
<ul>
<li>
Shape is an ADT that can be a Circle with a radius (Float), a Rectangle with a width and height (Float Float), or a Square with a side length (Float).
</li>
</ul>
<h4 id="pattern-matching-with-adts">Pattern Matching with ADTs</h4>
<p>Pattern matching allows you to deconstruct ADT values and apply different logic depending on the constructor used.</p>
<p>Example of Pattern Matching with ADTs:</p>
<div class="source-code"><pre><code class="language-haskell"><span class="va">area</span><span> </span><span class="sy">::</span><span> </span><span class="cr">Shape</span><span> </span><span class="sy">-&gt;</span><span> </span><span class="cr">Float</span><span>
</span><span class="va">area</span><span> </span><span class="sy">(</span><span class="cr">Circle</span><span> </span><span class="va">r</span><span class="sy">)</span><span> </span><span class="sy">=</span><span> </span><span class="va">pi</span><span> </span><span class="sy">*</span><span> </span><span class="va">r</span><span> </span><span class="sy">*</span><span> </span><span class="va">r</span><span>
</span><span class="va">area</span><span> </span><span class="sy">(</span><span class="cr">Rectangle</span><span> </span><span class="va">w</span><span> </span><span class="va">h</span><span class="sy">)</span><span> </span><span class="sy">=</span><span> </span><span class="va">w</span><span> </span><span class="sy">*</span><span> </span><span class="va">h</span><span>
</span><span class="va">area</span><span> </span><span class="sy">(</span><span class="cr">Square</span><span> </span><span class="va">s</span><span class="sy">)</span><span> </span><span class="sy">=</span><span> </span><span class="va">s</span><span> </span><span class="sy">*</span><span> </span><span class="va">s</span><span>
</span></code></pre></div>
<p>In this example, the area function computes the area of a Shape. It uses pattern matching to determine whether the shape is a Circle, Rectangle, or Square, and calculates the area accordingly.</p>
<h2 id="domaindriven-design">Domain-Driven Design</h2>
<h3 id="what-is-domaindriven-design">What is Domain-Driven Design?</h3>
<p>Domain-Driven Design (DDD) is a methodology for structuring software around a business domain. It’s all about creating a deep understanding of the business or system you’re building and then reflecting that understanding directly in your code. The goal is to model real-world concepts with code that mirrors the domain as closely as possible.</p>
<p>In essence:</p>
<ul>
<li>
<p><strong>Model Real-World Concepts</strong>: In DDD, the focus is on modeling the real world as accurately as possible, avoiding the use of primitive types like <code>Int</code> and <code>String</code> except at the &quot;leaf&quot; levels (e.g., values or properties that directly map to basic concepts like age or names). Instead, we create types that describe domain-specific concepts like <code>CustomerId</code>, <code>OrderId</code>, or <code>RobotArmAngle</code>. These types are meaningful and self-explanatory in the domain.</p>
</li>
<li>
<p><strong>Use Domain Language</strong>: A key principle of DDD is using the same language that the client uses to describe their domain. This means that, when you’re building a system for a specific business or project, you use terms that make sense to the client. Ideally, your client should be able to understand your code—or at least be able to provide meaningful input into the design of your domain models. When you’ve done it right, your code should read like plain English to domain experts.</p>
</li>
</ul>
<h4 id="example-of-domaindriven-design">Example of Domain-Driven Design</h4>
<p>Imagine you&#39;re tasked with building a home robot system, where one of its key functionalities is to interact with objects around the house. The robot needs to perform tasks like picking up objects, turning knobs, and pressing buttons. Your client, an engineer with expertise in robotics, describes the system using terms like “robot arm,” “actuator,” “gripper,” and “torque.”</p>
<p>If you model this system using primitives (<code>Int</code>, <code>String</code>, <code>Float</code>), your code might look something like this:</p>
<div class="source-code"><pre><code class="language-haskell"><span class="va">pickUp</span><span> </span><span class="sy">::</span><span> </span><span class="cr">Int</span><span> </span><span class="sy">-&gt;</span><span> </span><span class="cr">Float</span><span> </span><span class="sy">-&gt;</span><span> </span><span class="cr">String</span><span> </span><span class="sy">-&gt;</span><span> </span><span class="cr">Bool</span><span>
</span><span class="va">pickUp</span><span> </span><span class="va">armId</span><span> </span><span class="va">rotation</span><span> </span><span class="va">gripper</span><span> </span><span class="sy">=</span><span> </span><span class="co">-- perform task</span><span>
</span></code></pre></div>
<p>This code uses generic types like Int, Float, and String, which have no meaningful connection to the domain concepts. The client would have a hard time understanding what this function does or whether it models the domain correctly.</p>
<p>Instead, with DDD, you would model the system using types that reflect the domain:</p>
<div class="source-code"><pre><code class="language-haskell"><span class="kw">data</span><span> </span><span class="cr">RobotArm</span><span> </span><span class="sy">=</span><span> </span><span class="cr">RobotArm</span><span> </span><span class="cr">ArmId</span><span> </span><span class="cr">Rotation</span><span> </span><span class="cr">Torque</span><span>
</span><span class="kw">data</span><span> </span><span class="cr">Gripper</span><span> </span><span class="sy">=</span><span> </span><span class="cr">Gripper</span><span> </span><span class="cr">GripperType</span><span> </span><span class="cr">GripStrength</span><span>

</span><span class="va">pickUp</span><span> </span><span class="sy">::</span><span> </span><span class="cr">RobotArm</span><span> </span><span class="sy">-&gt;</span><span> </span><span class="cr">Gripper</span><span> </span><span class="sy">-&gt;</span><span> </span><span class="cr">Object</span><span> </span><span class="sy">-&gt;</span><span> </span><span class="cr">TaskResult</span><span>
</span><span class="va">pickUp</span><span> </span><span class="va">arm</span><span> </span><span class="va">gripper</span><span> </span><span class="va">object</span><span> </span><span class="sy">=</span><span> </span><span class="co">-- perform task</span><span>
</span></code></pre></div>
<p>Now the function pickUp uses domain-specific types (RobotArm, Gripper, Object, TaskResult), making it easier for your client to understand and ensuring that your code accurately models the real-world system. The types tell you a lot more about what’s going on, reducing ambiguity and making your system safer and easier to reason about.</p>
<h4 id="modelling-the-domain-with-types">Modelling the Domain with Types</h4>
<p>Let’s look at a more complex example to illustrate how types can model real-world interactions between different parts of a system.</p>
<p>Example Scenario: Robot Arm and Torso Integration</p>
<p>Imagine a robotics project where one team is responsible for building the robot’s arm, and another team is responsible for the torso. The two components need to be integrated at the shoulder joint. The arm has actuators that rotate at certain angles, and the torso needs to provide power to these actuators. Both teams are working independently, and the shoulder becomes the integration point for the two components.</p>
<p>Hypothetical Background:</p>
<ul>
<li>
The Arm Team is working with actuators that rotate between 0 and 180 degrees.
</li>
<li>
The Torso Team is responsible for delivering power, ensuring that the arm’s actuators receive enough power to function.
</li>
<li>
The Shoulder acts as the integration point where the power and rotation capabilities meet.
</li>
</ul>
<p>We need to model the interaction between these systems, ensuring that the power delivered by the torso matches the requirements of the actuators in the arm.</p>
<p>Example Code:</p>
<div class="source-code"><pre><code class="language-haskell"><span class="co">-- Define the arm&#39;s actuators and rotation</span><span>
</span><span class="kw">data</span><span> </span><span class="cr">Rotation</span><span> </span><span class="sy">=</span><span> </span><span class="cr">Rotation</span><span> </span><span class="cr">Int</span><span> </span><span class="co">-- value in degrees between 0 and 180</span><span>
</span><span class="kw">data</span><span> </span><span class="cr">Actuator</span><span> </span><span class="sy">=</span><span> </span><span class="cr">Actuator</span><span> </span><span class="cr">Rotation</span><span> </span><span class="cr">Torque</span><span>

</span><span class="co">-- Define the torso&#39;s power capabilities</span><span>
</span><span class="kw">data</span><span> </span><span class="cr">PowerSupply</span><span> </span><span class="sy">=</span><span> </span><span class="cr">PowerSupply</span><span> </span><span class="cr">Torque</span><span> </span><span class="co">-- Torque provided to the actuators</span><span>

</span><span class="co">-- Define the shoulder as the integration point</span><span>
</span><span class="kw">data</span><span> </span><span class="cr">Shoulder</span><span> </span><span class="sy">=</span><span> </span><span class="cr">Shoulder</span><span> </span><span class="cr">Actuator</span><span> </span><span class="cr">PowerSupply</span><span>

</span><span class="co">-- Function to match the power provided by the torso with the actuator&#39;s requirements</span><span>
</span><span class="va">integrateShoulder</span><span> </span><span class="sy">::</span><span> </span><span class="cr">Shoulder</span><span> </span><span class="sy">-&gt;</span><span> </span><span class="cr">Bool</span><span>
</span><span class="va">integrateShoulder</span><span> </span><span class="sy">(</span><span class="cr">Shoulder</span><span> </span><span class="sy">(</span><span class="cr">Actuator</span><span> </span><span class="sy">(</span><span class="cr">Rotation</span><span> </span><span class="va">angle</span><span class="sy">)</span><span> </span><span class="va">torque</span><span class="sy">)</span><span> </span><span class="sy">(</span><span class="cr">PowerSupply</span><span> </span><span class="va">supplyTorque</span><span class="sy">)</span><span class="sy">)</span><span>
    </span><span class="sy">|</span><span> </span><span class="va">torque</span><span> </span><span class="op">&lt;=</span><span> </span><span class="va">supplyTorque</span><span> </span><span class="sy">=</span><span> </span><span class="cr">True</span><span> </span><span class="co">-- Power matches or exceeds the actuator&#39;s requirement</span><span>
    </span><span class="sy">|</span><span> </span><span class="va">otherwise</span><span> </span><span class="sy">=</span><span> </span><span class="cr">False</span><span> </span><span class="co">-- Insufficient power</span><span>
</span></code></pre></div>
<p>In this example:</p>
<ul>
<li>
We’ve modeled Rotation, Actuator, and PowerSupply using Haskell’s type system to reflect the real-world domain.
</li>
<li>
The function integrateShoulder checks whether the power supplied by the torso is sufficient for the actuators in the arm to function properly.
</li>
</ul>
<p>This domain model allows us to precisely describe the real-world system, ensuring that the interaction between the arm and torso is modeled correctly. By using meaningful types, we avoid the pitfalls of using primitives like Int and Float, which don’t convey the intent or constraints of the system.</p>
<h4 id="defining-domain-concepts-as-types">Defining Domain Concepts as Types</h4>
<p>Haskell’s type system is incredibly powerful and can be used to model much more than just basic data structures. You can define complex concepts using types, allowing you to encode domain-specific logic directly into the type system.</p>
<p>Example: Aggregating Data from Space Agencies</p>
<p>Let’s say we’re building a system that aggregates real-time data from three different space agencies. Each agency provides slightly different data formats, and some of the data might be missing or delayed. To ensure reliability, we need to aggregate the data and serve the most accurate, up-to-date information to the end user. We’ll validate the data using a round-robin algorithm to determine which data is most trustworthy.</p>
<p>Complex Domain Model:</p>
<div class="source-code"><pre><code class="language-haskell"><span class="co">-- Define a type for data from Space Agencies</span><span>
</span><span class="kw">data</span><span> </span><span class="cr">SpaceAgency</span><span> </span><span class="sy">=</span><span> </span><span class="cr">NASA</span><span> </span><span class="sy">|</span><span> </span><span class="cr">ESA</span><span> </span><span class="sy">|</span><span> </span><span class="cr">JAXA</span><span>

</span><span class="co">-- Define a type for the data each agency provides</span><span>
</span><span class="kw">data</span><span> </span><span class="cr">SpaceData</span><span> </span><span class="sy">=</span><span> </span><span class="cr">SpaceData</span><span> </span><span class="sy">{</span><span>
    </span><span class="va">temperature</span><span> </span><span class="sy">::</span><span> </span><span class="cr">Maybe</span><span> </span><span class="cr">Float</span><span class="sy">,</span><span>
    </span><span class="va">pressure</span><span>    </span><span class="sy">::</span><span> </span><span class="cr">Maybe</span><span> </span><span class="cr">Float</span><span class="sy">,</span><span>
    </span><span class="va">velocity</span><span>    </span><span class="sy">::</span><span> </span><span class="cr">Maybe</span><span> </span><span class="cr">Float</span><span>
</span><span class="sy">}</span><span>

</span><span class="co">-- A type class to validate data from each agency</span><span>
</span><span class="kw">class</span><span> </span><span class="cr">ValidateData</span><span> </span><span class="va">a</span><span> </span><span class="kw">where</span><span>
    </span><span class="va">validate</span><span> </span><span class="sy">::</span><span> </span><span class="va">a</span><span> </span><span class="sy">-&gt;</span><span> </span><span class="cr">Bool</span><span>

</span><span class="kw">instance</span><span> </span><span class="cr">ValidateData</span><span> </span><span class="cr">SpaceData</span><span> </span><span class="kw">where</span><span>
    </span><span class="va">validate</span><span> </span><span class="sy">(</span><span class="cr">SpaceData</span><span> </span><span class="va">temp</span><span> </span><span class="va">press</span><span> </span><span class="va">vel</span><span class="sy">)</span><span> </span><span class="sy">=</span><span> </span><span class="va">all</span><span> </span><span class="va">isJust</span><span> </span><span class="sy">[</span><span class="va">temp</span><span class="sy">,</span><span> </span><span class="va">press</span><span class="sy">,</span><span> </span><span class="va">vel</span><span class="sy">]</span><span>

</span><span class="co">-- Define a type for the round-robin algorithm to choose the most accurate data</span><span>
</span><span class="kw">data</span><span> </span><span class="cr">RoundRobin</span><span> </span><span class="sy">=</span><span> </span><span class="cr">RoundRobin</span><span> </span><span class="cr">SpaceData</span><span> </span><span class="cr">SpaceData</span><span> </span><span class="cr">SpaceData</span><span>

</span><span class="co">-- Function to aggregate data from multiple agencies and serve the best one</span><span>
</span><span class="va">aggregateData</span><span> </span><span class="sy">::</span><span> </span><span class="cr">RoundRobin</span><span> </span><span class="sy">-&gt;</span><span> </span><span class="cr">SpaceData</span><span>
</span><span class="va">aggregateData</span><span> </span><span class="sy">(</span><span class="cr">RoundRobin</span><span> </span><span class="va">nasa</span><span> </span><span class="va">esa</span><span> </span><span class="va">jaxa</span><span class="sy">)</span><span>
    </span><span class="sy">|</span><span> </span><span class="va">validate</span><span> </span><span class="va">nasa</span><span> </span><span class="sy">=</span><span> </span><span class="va">nasa</span><span>
    </span><span class="sy">|</span><span> </span><span class="va">validate</span><span> </span><span class="va">esa</span><span>  </span><span class="sy">=</span><span> </span><span class="va">esa</span><span>
    </span><span class="sy">|</span><span> </span><span class="va">validate</span><span> </span><span class="va">jaxa</span><span> </span><span class="sy">=</span><span> </span><span class="va">jaxa</span><span>
    </span><span class="sy">|</span><span> </span><span class="va">otherwise</span><span>     </span><span class="sy">=</span><span> </span><span class="va">error</span><span> </span><span class="st">&quot;All data invalid&quot;</span><span>

</span><span class="co">-- Example usage</span><span>
</span><span class="va">nasaData</span><span> </span><span class="sy">=</span><span> </span><span class="cr">SpaceData</span><span> </span><span class="sy">(</span><span class="cr">Just</span><span> </span><span class="ra">20.5</span><span class="sy">)</span><span> </span><span class="sy">(</span><span class="cr">Just</span><span> </span><span class="ra">1013.25</span><span class="sy">)</span><span> </span><span class="cr">Nothing</span><span>
</span><span class="va">esaData</span><span> </span><span class="sy">=</span><span> </span><span class="cr">SpaceData</span><span> </span><span class="sy">(</span><span class="cr">Just</span><span> </span><span class="ra">20.4</span><span class="sy">)</span><span> </span><span class="sy">(</span><span class="cr">Just</span><span> </span><span class="ra">1013.30</span><span class="sy">)</span><span> </span><span class="sy">(</span><span class="cr">Just</span><span> </span><span class="it">7500</span><span class="sy">)</span><span>
</span><span class="va">jaxaData</span><span> </span><span class="sy">=</span><span> </span><span class="cr">SpaceData</span><span> </span><span class="cr">Nothing</span><span> </span><span class="sy">(</span><span class="cr">Just</span><span> </span><span class="ra">1013.20</span><span class="sy">)</span><span> </span><span class="sy">(</span><span class="cr">Just</span><span> </span><span class="it">7501</span><span class="sy">)</span><span>

</span><span class="va">main</span><span> </span><span class="sy">=</span><span> </span><span class="va">print</span><span> </span><span class="op">$</span><span> </span><span class="va">aggregateData</span><span> </span><span class="sy">(</span><span class="cr">RoundRobin</span><span> </span><span class="va">nasaData</span><span> </span><span class="va">esaData</span><span> </span><span class="va">jaxaData</span><span class="sy">)</span><span>
</span></code></pre></div>
<p>In this example:</p>
<ul>
<li>
We define the SpaceData type, which represents the real-time data from each space agency. Some fields may be missing (Maybe Float), which we handle explicitly.
</li>
<li>
The ValidateData type class allows us to check whether the data provided by each agency is complete and valid.
</li>
<li>
The RoundRobin type models the round-robin algorithm used to select the most reliable data.
</li>
<li>
The aggregateData function aggregates data from NASA, ESA, and JAXA, and returns the most accurate dataset based on the validation criteria.
</li>
</ul>
<h2 id="pairing-domain-theory-with-type-theory">Pairing Domain Theory with Type Theory</h2>
<h3 id="type-theory-in-the-context-of-domain-modeling">Type Theory in the Context of Domain Modeling</h3>
<p>In Haskell, type theory goes hand in hand with domain-driven design. Domain theory helps you model the real world by representing domain concepts in code, while type theory ensures that your code is precise, safe, and free from common runtime errors. The power of Haskell’s type system lies in its ability to <strong>perfectly describe your problem space</strong>.</p>
<h4 id="how-types-make-domains-safer">How Types Make Domains Safer</h4>
<p>When you define a domain model, you&#39;re not just giving names to concepts—you&#39;re also giving those concepts constraints and rules through types. For example:</p>
<ul>
<li>
<strong>Simple types like <code>Int</code> or <code>String</code></strong> don’t carry much meaning by themselves. They could be anything.
</li>
<li>
<strong>Custom types like <code>CustomerId</code> or <code>Temperature</code></strong> represent specific concepts in your domain and ensure that values are used in appropriate contexts. By encoding your domain logic directly into types, you prevent mistakes like accidentally passing an email address where a <code>CustomerId</code> is expected.
</li>
</ul>
<p>Let’s break this down with a simple example.</p>
<h4 id="example-defining-safe-domain-concepts">Example: Defining Safe Domain Concepts</h4>
<p>Consider an online shopping platform. You’ll have concepts like customers, orders, and products. You could model these using primitives like <code>Int</code> and <code>String</code>, but this opens the door to mistakes:</p>
<div class="source-code"><pre><code class="language-haskell"><span class="co">-- This is unsafe</span><span>
</span><span class="va">createOrder</span><span> </span><span class="sy">::</span><span> </span><span class="cr">Int</span><span> </span><span class="sy">-&gt;</span><span> </span><span class="cr">String</span><span> </span><span class="sy">-&gt;</span><span> </span><span class="cr">String</span><span> </span><span class="sy">-&gt;</span><span> </span><span class="cr">Int</span><span> </span><span class="sy">-&gt;</span><span> </span><span class="cr">Bool</span><span>
</span><span class="va">createOrder</span><span> </span><span class="va">customerId</span><span> </span><span class="va">productName</span><span> </span><span class="va">address</span><span> </span><span class="va">quantity</span><span> </span><span class="sy">=</span><span> </span><span class="co">-- Implementation</span><span>
</span></code></pre></div>
<p>In this version, we’re using Int and String everywhere, which doesn’t reflect the domain at all. It’s easy to accidentally swap parameters or use invalid values.</p>
<p>With type theory, we can give more meaning and safety to the domain:</p>
<div class="source-code"><pre><code class="language-haskell"><span class="co">-- Safe version using custom types</span><span>
</span><span class="kw">newtype</span><span> </span><span class="cr">CustomerId</span><span> </span><span class="sy">=</span><span> </span><span class="cr">CustomerId</span><span> </span><span class="cr">Int</span><span>
</span><span class="kw">newtype</span><span> </span><span class="cr">ProductName</span><span> </span><span class="sy">=</span><span> </span><span class="cr">ProductName</span><span> </span><span class="cr">String</span><span>
</span><span class="kw">newtype</span><span> </span><span class="cr">Address</span><span> </span><span class="sy">=</span><span> </span><span class="cr">Address</span><span> </span><span class="cr">String</span><span>
</span><span class="kw">newtype</span><span> </span><span class="cr">Quantity</span><span> </span><span class="sy">=</span><span> </span><span class="cr">Quantity</span><span> </span><span class="cr">Int</span><span>

</span><span class="va">createOrder</span><span> </span><span class="sy">::</span><span> </span><span class="cr">CustomerId</span><span> </span><span class="sy">-&gt;</span><span> </span><span class="cr">ProductName</span><span> </span><span class="sy">-&gt;</span><span> </span><span class="cr">Address</span><span> </span><span class="sy">-&gt;</span><span> </span><span class="cr">Quantity</span><span> </span><span class="sy">-&gt;</span><span> </span><span class="cr">Bool</span><span>
</span><span class="va">createOrder</span><span> </span><span class="sy">(</span><span class="cr">CustomerId</span><span> </span><span class="va">custId</span><span class="sy">)</span><span> </span><span class="sy">(</span><span class="cr">ProductName</span><span> </span><span class="va">prodName</span><span class="sy">)</span><span> </span><span class="sy">(</span><span class="cr">Address</span><span> </span><span class="va">addr</span><span class="sy">)</span><span> </span><span class="sy">(</span><span class="cr">Quantity</span><span> </span><span class="va">qty</span><span class="sy">)</span><span> </span><span class="sy">=</span><span> </span><span class="co">-- Implementation</span><span>
</span></code></pre></div>
<p>By defining types like CustomerId, ProductName, Address, and Quantity, we give more meaning to our code. The type signature for createOrder now clearly reflects what the function does, and we prevent mistakes like passing an address where a ProductName is expected.</p>
<h3 id="ensuring-valid-states-with-types">Ensuring Valid States with Types</h3>
<p>One of the most powerful aspects of Haskell’s type system is that it allows you to enforce valid states directly in the type system. This means you can encode business rules or constraints into your types, making it impossible to represent invalid states.</p>
<h4 id="example-preventing-invalid-orders">Example: Preventing Invalid Orders</h4>
<p>Let’s extend our Order example. In a typical e-commerce application, an order should never have a negative quantity, and it should always have a valid product. We can enforce these rules in the type system.</p>
<p>Basic Example (with risk of invalid states):</p>
<div class="source-code"><pre><code class="language-haskell"><span class="kw">data</span><span> </span><span class="cr">Order</span><span> </span><span class="sy">=</span><span> </span><span class="cr">Order</span><span> </span><span class="cr">Int</span><span> </span><span class="cr">String</span><span> </span><span class="cr">Int</span><span> </span><span class="co">-- CustomerId, ProductName, Quantity</span><span>
</span></code></pre></div>
<p>In this version, there’s nothing stopping us from creating an Order with an invalid product name or a negative quantity.</p>
<p>Improved Example (enforcing valid states):</p>
<div class="source-code"><pre><code class="language-haskell"><span class="kw">newtype</span><span> </span><span class="cr">CustomerId</span><span> </span><span class="sy">=</span><span> </span><span class="cr">CustomerId</span><span> </span><span class="cr">Int</span><span>
</span><span class="kw">newtype</span><span> </span><span class="cr">ProductName</span><span> </span><span class="sy">=</span><span> </span><span class="cr">ProductName</span><span> </span><span class="cr">String</span><span>
</span><span class="kw">newtype</span><span> </span><span class="cr">Address</span><span> </span><span class="sy">=</span><span> </span><span class="cr">Address</span><span> </span><span class="cr">String</span><span>
</span><span class="kw">newtype</span><span> </span><span class="cr">Quantity</span><span> </span><span class="sy">=</span><span> </span><span class="cr">Quantity</span><span> </span><span class="cr">Int</span><span>

</span><span class="kw">data</span><span> </span><span class="cr">ValidatedOrder</span><span> </span><span class="sy">=</span><span> </span><span class="cr">ValidatedOrder</span><span> </span><span class="cr">CustomerId</span><span> </span><span class="cr">ProductName</span><span> </span><span class="cr">Address</span><span> </span><span class="cr">Quantity</span><span>
</span></code></pre></div>
<p>But we can go even further to ensure that only valid orders can exist:</p>
<div class="source-code"><pre><code class="language-haskell"><span class="kw">newtype</span><span> </span><span class="cr">NonEmptyString</span><span> </span><span class="sy">=</span><span> </span><span class="cr">NonEmptyString</span><span> </span><span class="cr">String</span><span>
    </span><span class="kw">deriving</span><span> </span><span class="sy">(</span><span class="cr">Show</span><span class="sy">)</span><span>

</span><span class="va">mkNonEmptyString</span><span> </span><span class="sy">::</span><span> </span><span class="cr">String</span><span> </span><span class="sy">-&gt;</span><span> </span><span class="cr">Maybe</span><span> </span><span class="cr">NonEmptyString</span><span>
</span><span class="va">mkNonEmptyString</span><span> </span><span class="st">&quot;&quot;</span><span> </span><span class="sy">=</span><span> </span><span class="cr">Nothing</span><span>
</span><span class="va">mkNonEmptyString</span><span> </span><span class="va">str</span><span> </span><span class="sy">=</span><span> </span><span class="cr">Just</span><span> </span><span class="sy">(</span><span class="cr">NonEmptyString</span><span> </span><span class="va">str</span><span class="sy">)</span><span>

</span><span class="kw">newtype</span><span> </span><span class="cr">PositiveInt</span><span> </span><span class="sy">=</span><span> </span><span class="cr">PositiveInt</span><span> </span><span class="cr">Int</span><span>
    </span><span class="kw">deriving</span><span> </span><span class="sy">(</span><span class="cr">Show</span><span class="sy">)</span><span>

</span><span class="va">mkPositiveInt</span><span> </span><span class="sy">::</span><span> </span><span class="cr">Int</span><span> </span><span class="sy">-&gt;</span><span> </span><span class="cr">Maybe</span><span> </span><span class="cr">PositiveInt</span><span>
</span><span class="va">mkPositiveInt</span><span> </span><span class="va">n</span><span>
    </span><span class="sy">|</span><span> </span><span class="va">n</span><span> </span><span class="op">&gt;</span><span> </span><span class="it">0</span><span>     </span><span class="sy">=</span><span> </span><span class="cr">Just</span><span> </span><span class="sy">(</span><span class="cr">PositiveInt</span><span> </span><span class="va">n</span><span class="sy">)</span><span>
    </span><span class="sy">|</span><span> </span><span class="va">otherwise</span><span> </span><span class="sy">=</span><span> </span><span class="cr">Nothing</span><span>

</span><span class="kw">data</span><span> </span><span class="cr">Order</span><span> </span><span class="sy">=</span><span> </span><span class="cr">Order</span><span> </span><span class="sy">{</span><span>
    </span><span class="va">customerId</span><span> </span><span class="sy">::</span><span> </span><span class="cr">CustomerId</span><span class="sy">,</span><span>
    </span><span class="va">productName</span><span> </span><span class="sy">::</span><span> </span><span class="cr">NonEmptyString</span><span class="sy">,</span><span>
    </span><span class="va">address</span><span> </span><span class="sy">::</span><span> </span><span class="cr">NonEmptyString</span><span class="sy">,</span><span>
    </span><span class="va">quantity</span><span> </span><span class="sy">::</span><span> </span><span class="cr">PositiveInt</span><span>
</span><span class="sy">}</span><span>

</span><span class="va">createOrder</span><span> </span><span class="sy">::</span><span> </span><span class="cr">CustomerId</span><span> </span><span class="sy">-&gt;</span><span> </span><span class="cr">String</span><span> </span><span class="sy">-&gt;</span><span> </span><span class="cr">String</span><span> </span><span class="sy">-&gt;</span><span> </span><span class="cr">Int</span><span> </span><span class="sy">-&gt;</span><span> </span><span class="cr">Maybe</span><span> </span><span class="cr">Order</span><span>
</span><span class="va">createOrder</span><span> </span><span class="va">cid</span><span> </span><span class="va">pName</span><span> </span><span class="va">addr</span><span> </span><span class="va">qty</span><span> </span><span class="sy">=</span><span> </span><span class="kw">do</span><span>
    </span><span class="va">pName&#39;</span><span> </span><span class="sy">&lt;-</span><span> </span><span class="va">mkNonEmptyString</span><span> </span><span class="va">pName</span><span>
    </span><span class="va">addr&#39;</span><span>  </span><span class="sy">&lt;-</span><span> </span><span class="va">mkNonEmptyString</span><span> </span><span class="va">addr</span><span>
    </span><span class="va">qty&#39;</span><span>   </span><span class="sy">&lt;-</span><span> </span><span class="va">mkPositiveInt</span><span> </span><span class="va">qty</span><span>
    </span><span class="va">return</span><span> </span><span class="op">$</span><span> </span><span class="cr">Order</span><span> </span><span class="va">cid</span><span> </span><span class="va">pName&#39;</span><span> </span><span class="va">addr&#39;</span><span> </span><span class="va">qty&#39;</span><span>
</span></code></pre></div>
<p>In this version:</p>
<ul>
<li>
NonEmptyString ensures that product names and addresses can never be empty.
</li>
<li>
PositiveInt ensures that quantities are always positive.
</li>
</ul>
<p>The createOrder function now returns a Maybe Order, meaning that it will only produce a valid Order if all the inputs meet the necessary conditions. This way, you can guarantee at compile time that no invalid orders can be created.</p>
<h3 id="how-the-compiler-infers-types">How the Compiler Infers Types</h3>
<p>Haskell’s compiler is powerful enough to infer types even if you don’t explicitly annotate them. However, it’s always a good idea to include type signatures for clarity and better error checking.</p>
<h3 id="example-of-type-inference">Example of Type Inference:</h3>
<div class="source-code"><pre><code class="language-haskell"><span class="va">add</span><span> </span><span class="sy">::</span><span> </span><span class="cr">Int</span><span> </span><span class="sy">-&gt;</span><span> </span><span class="cr">Int</span><span> </span><span class="sy">-&gt;</span><span> </span><span class="cr">Int</span><span>
</span><span class="va">add</span><span> </span><span class="va">x</span><span> </span><span class="va">y</span><span> </span><span class="sy">=</span><span> </span><span class="va">x</span><span> </span><span class="op">+</span><span> </span><span class="va">y</span><span>
</span></code></pre></div>
<p>Even if you omit the type signature, Haskell can infer that add takes two Ints and returns an Int:</p>
<div class="source-code"><pre><code class="language-haskell"><span class="va">add</span><span> </span><span class="va">x</span><span> </span><span class="va">y</span><span> </span><span class="sy">=</span><span> </span><span class="va">x</span><span> </span><span class="op">+</span><span> </span><span class="va">y</span><span> </span><span class="co">-- Haskell infers: add :: Int -&gt; Int -&gt; Int</span><span>
</span></code></pre></div>
<h3 id="type-inference-with-polymorphism">Type Inference with Polymorphism:</h3>
<p>Haskell can also infer types for polymorphic functions. For example:</p>
<div class="source-code"><pre><code class="language-haskell"><span class="va">identity</span><span> </span><span class="va">x</span><span> </span><span class="sy">=</span><span> </span><span class="va">x</span><span>
</span></code></pre></div>
<p>Haskell infers that identity can work with any type, so the type signature becomes:</p>
<div class="source-code"><pre><code class="language-haskell"><span class="va">identity</span><span> </span><span class="sy">::</span><span> </span><span class="va">a</span><span> </span><span class="sy">-&gt;</span><span> </span><span class="va">a</span><span>
</span></code></pre></div>
<p>In this case, a is a type variable, meaning that identity can take and return any type.</p>
<h4 id="practical-example-modelling-a-bank-account-system">Practical Example: Modelling a Bank Account System</h4>
<p>To see how type theory and domain modeling work together in a real-world scenario, let’s model a banking system.</p>
<ol>
<li>
Domain Concepts:
</li>
</ol>
<ul>
<li>
Account: Represents a bank account.
</li>
<li>
Transaction: Represents a deposit or withdrawal.
</li>
<li>
Balance: Represents the current balance of the account.
</li>
</ul>
<ol start="2">
<li>
Domain-Specific Types:
</li>
</ol>
<ul>
<li>
We’ll define custom types for these concepts to ensure that invalid states (e.g., negative balances, invalid transactions) are impossible.
</li>
</ul>
<p>Example Code:</p>
<div class="source-code"><pre><code class="language-haskell"><span class="kw">newtype</span><span> </span><span class="cr">AccountId</span><span> </span><span class="sy">=</span><span> </span><span class="cr">AccountId</span><span> </span><span class="cr">Int</span><span>
</span><span class="kw">newtype</span><span> </span><span class="cr">Amount</span><span> </span><span class="sy">=</span><span> </span><span class="cr">Amount</span><span> </span><span class="cr">Float</span><span>
    </span><span class="kw">deriving</span><span> </span><span class="sy">(</span><span class="cr">Show</span><span class="sy">)</span><span>

</span><span class="kw">data</span><span> </span><span class="cr">TransactionType</span><span> </span><span class="sy">=</span><span> </span><span class="cr">Deposit</span><span> </span><span class="sy">|</span><span> </span><span class="cr">Withdrawal</span><span>
    </span><span class="kw">deriving</span><span> </span><span class="sy">(</span><span class="cr">Show</span><span class="sy">)</span><span>

</span><span class="kw">data</span><span> </span><span class="cr">Transaction</span><span> </span><span class="sy">=</span><span> </span><span class="cr">Transaction</span><span> </span><span class="sy">{</span><span>
    </span><span class="va">transactionType</span><span> </span><span class="sy">::</span><span> </span><span class="cr">TransactionType</span><span class="sy">,</span><span>
    </span><span class="va">amount</span><span> </span><span class="sy">::</span><span> </span><span class="cr">Amount</span><span>
</span><span class="sy">}</span><span> </span><span class="kw">deriving</span><span> </span><span class="sy">(</span><span class="cr">Show</span><span class="sy">)</span><span>

</span><span class="kw">data</span><span> </span><span class="cr">Account</span><span> </span><span class="sy">=</span><span> </span><span class="cr">Account</span><span> </span><span class="sy">{</span><span>
    </span><span class="va">accountId</span><span> </span><span class="sy">::</span><span> </span><span class="cr">AccountId</span><span class="sy">,</span><span>
    </span><span class="va">balance</span><span>   </span><span class="sy">::</span><span> </span><span class="cr">Amount</span><span>
</span><span class="sy">}</span><span> </span><span class="kw">deriving</span><span> </span><span class="sy">(</span><span class="cr">Show</span><span class="sy">)</span><span>

</span><span class="co">-- Function to apply a transaction to an account</span><span>
</span><span class="va">applyTransaction</span><span> </span><span class="sy">::</span><span> </span><span class="cr">Account</span><span> </span><span class="sy">-&gt;</span><span> </span><span class="cr">Transaction</span><span> </span><span class="sy">-&gt;</span><span> </span><span class="cr">Maybe</span><span> </span><span class="cr">Account</span><span>
</span><span class="va">applyTransaction</span><span> </span><span class="sy">(</span><span class="cr">Account</span><span> </span><span class="va">accId</span><span> </span><span class="sy">(</span><span class="cr">Amount</span><span> </span><span class="va">bal</span><span class="sy">)</span><span class="sy">)</span><span> </span><span class="sy">(</span><span class="cr">Transaction</span><span> </span><span class="cr">Deposit</span><span> </span><span class="sy">(</span><span class="cr">Amount</span><span> </span><span class="va">amt</span><span class="sy">)</span><span class="sy">)</span><span> </span><span class="sy">=</span><span>
    </span><span class="cr">Just</span><span> </span><span class="sy">(</span><span class="cr">Account</span><span> </span><span class="va">accId</span><span> </span><span class="sy">(</span><span class="cr">Amount</span><span> </span><span class="sy">(</span><span class="va">bal</span><span> </span><span class="op">+</span><span> </span><span class="va">amt</span><span class="sy">)</span><span class="sy">)</span><span class="sy">)</span><span>

</span><span class="va">applyTransaction</span><span> </span><span class="sy">(</span><span class="cr">Account</span><span> </span><span class="va">accId</span><span> </span><span class="sy">(</span><span class="cr">Amount</span><span> </span><span class="va">bal</span><span class="sy">)</span><span class="sy">)</span><span> </span><span class="sy">(</span><span class="cr">Transaction</span><span> </span><span class="cr">Withdrawal</span><span> </span><span class="sy">(</span><span class="cr">Amount</span><span> </span><span class="va">amt</span><span class="sy">)</span><span class="sy">)</span><span>
    </span><span class="sy">|</span><span> </span><span class="va">bal</span><span> </span><span class="op">&gt;=</span><span> </span><span class="va">amt</span><span> </span><span class="sy">=</span><span> </span><span class="cr">Just</span><span> </span><span class="sy">(</span><span class="cr">Account</span><span> </span><span class="va">accId</span><span> </span><span class="sy">(</span><span class="cr">Amount</span><span> </span><span class="sy">(</span><span class="va">bal</span><span> </span><span class="op">-</span><span> </span><span class="va">amt</span><span class="sy">)</span><span class="sy">)</span><span class="sy">)</span><span>
    </span><span class="sy">|</span><span> </span><span class="va">otherwise</span><span>  </span><span class="sy">=</span><span> </span><span class="cr">Nothing</span><span> </span><span class="co">-- Prevent overdraft</span><span>

</span><span class="co">-- Example usage</span><span>
</span><span class="va">main</span><span> </span><span class="sy">=</span><span> </span><span class="kw">do</span><span>
    </span><span class="kw">let</span><span> </span><span class="va">account</span><span> </span><span class="sy">=</span><span> </span><span class="cr">Account</span><span> </span><span class="sy">(</span><span class="cr">AccountId</span><span> </span><span class="it">1</span><span class="sy">)</span><span> </span><span class="sy">(</span><span class="cr">Amount</span><span> </span><span class="it">1000</span><span class="sy">)</span><span>
    </span><span class="kw">let</span><span> </span><span class="va">deposit</span><span> </span><span class="sy">=</span><span> </span><span class="cr">Transaction</span><span> </span><span class="cr">Deposit</span><span> </span><span class="sy">(</span><span class="cr">Amount</span><span> </span><span class="it">200</span><span class="sy">)</span><span>
    </span><span class="kw">let</span><span> </span><span class="va">withdrawal</span><span> </span><span class="sy">=</span><span> </span><span class="cr">Transaction</span><span> </span><span class="cr">Withdrawal</span><span> </span><span class="sy">(</span><span class="cr">Amount</span><span> </span><span class="it">1500</span><span class="sy">)</span><span>

    </span><span class="va">print</span><span> </span><span class="op">$</span><span> </span><span class="va">applyTransaction</span><span> </span><span class="va">account</span><span> </span><span class="va">deposit</span><span>      </span><span class="co">-- Valid deposit</span><span>
    </span><span class="va">print</span><span> </span><span class="op">$</span><span> </span><span class="va">applyTransaction</span><span> </span><span class="va">account</span><span> </span><span class="va">withdrawal</span><span>   </span><span class="co">-- Invalid withdrawal (overdraft)</span><span>
</span></code></pre></div>
<p>In this example:</p>
<ul>
<li>
AccountId, Amount, and Transaction are modeled using custom types.
</li>
<li>
The applyTransaction function ensures that withdrawals can only happen if there’s enough balance, preventing overdrafts.
</li>
<li>
This ensures that invalid states (e.g., negative balances) are impossible to represent.
</li>
</ul>
<h2 id="advanced-type-concepts">Advanced Type Concepts</h2>
<p>In this section, we’ll introduce some of Haskell’s more advanced type concepts, such as type classes, type families, phantom types, and type-level programming. You don’t need to learn these concepts right away, but knowing how to recognize them and having a basic understanding of how they work will help you expand your knowledge over time.</p>
<h3 id="type-classes-and-overloading">Type Classes and Overloading</h3>
<p><strong>Type classes</strong> are one of the most powerful features in Haskell. They provide a way to define generic interfaces that can be implemented by different types. Type classes allow for <strong>ad hoc polymorphism</strong>, meaning that you can write functions that work with any type as long as that type implements certain behavior (i.e., is an instance of a type class).</p>
<p>Think of type classes like interfaces in object-oriented programming. However, type classes are more flexible and allow Haskell’s type system to express a wide range of concepts while ensuring type safety.</p>
<h4 id="example-the-eq-type-class">Example: The <code>Eq</code> Type Class</h4>
<p>The <code>Eq</code> type class defines an interface for equality testing. If a type is an instance of <code>Eq</code>, you can use the <code>(==)</code> and <code>(/=)</code> operators to compare values of that type.</p>
<div class="source-code"><pre><code class="language-haskell"><span class="kw">class</span><span> </span><span class="cr">Eq</span><span> </span><span class="va">a</span><span> </span><span class="kw">where</span><span>
    </span><span class="sy">(</span><span class="op">==</span><span class="sy">)</span><span> </span><span class="sy">::</span><span> </span><span class="va">a</span><span> </span><span class="sy">-&gt;</span><span> </span><span class="va">a</span><span> </span><span class="sy">-&gt;</span><span> </span><span class="cr">Bool</span><span>
    </span><span class="sy">(</span><span class="op">/=</span><span class="sy">)</span><span> </span><span class="sy">::</span><span> </span><span class="va">a</span><span> </span><span class="sy">-&gt;</span><span> </span><span class="va">a</span><span> </span><span class="sy">-&gt;</span><span> </span><span class="cr">Bool</span><span>

</span><span class="co">-- Making a custom data type an instance of Eq</span><span>
</span><span class="kw">data</span><span> </span><span class="cr">Color</span><span> </span><span class="sy">=</span><span> </span><span class="cr">Red</span><span> </span><span class="sy">|</span><span> </span><span class="cr">Green</span><span> </span><span class="sy">|</span><span> </span><span class="cr">Blue</span><span>

</span><span class="kw">instance</span><span> </span><span class="cr">Eq</span><span> </span><span class="cr">Color</span><span> </span><span class="kw">where</span><span>
    </span><span class="cr">Red</span><span> </span><span class="op">==</span><span> </span><span class="cr">Red</span><span>     </span><span class="sy">=</span><span> </span><span class="cr">True</span><span>
    </span><span class="cr">Green</span><span> </span><span class="op">==</span><span> </span><span class="cr">Green</span><span> </span><span class="sy">=</span><span> </span><span class="cr">True</span><span>
    </span><span class="cr">Blue</span><span> </span><span class="op">==</span><span> </span><span class="cr">Blue</span><span>   </span><span class="sy">=</span><span> </span><span class="cr">True</span><span>
    </span><span class="sy">_</span><span> </span><span class="op">==</span><span> </span><span class="sy">_</span><span>         </span><span class="sy">=</span><span> </span><span class="cr">False</span><span>

</span><span class="co">-- Example usage:</span><span>
</span><span class="va">isEqual</span><span> </span><span class="sy">::</span><span> </span><span class="cr">Color</span><span> </span><span class="sy">-&gt;</span><span> </span><span class="cr">Color</span><span> </span><span class="sy">-&gt;</span><span> </span><span class="cr">Bool</span><span>
</span><span class="va">isEqual</span><span> </span><span class="cr">Red</span><span> </span><span class="cr">Green</span><span> </span><span class="sy">=</span><span> </span><span class="cr">Red</span><span> </span><span class="op">==</span><span> </span><span class="cr">Green</span><span> </span><span class="co">-- False</span><span>
</span></code></pre></div>
<p>In this example:</p>
<ul>
<li>
We define the Color data type with three possible values: Red, Green, and Blue.
</li>
<li>
We make Color an instance of the Eq type class by defining how equality works for the Color type.
</li>
<li>
Once we’ve defined this, we can compare Color values using the == operator.
</li>
</ul>
<h3 id="overloading-functions-with-type-classes">Overloading Functions with Type Classes</h3>
<p>Type classes also allow us to overload functions. A function can behave differently depending on the type of the arguments it receives, as long as the type is an instance of the relevant type class.</p>
<p>For example, the + operator is overloaded by the Num type class, which defines numeric operations:</p>
<div class="source-code"><pre><code class="language-haskell"><span class="kw">class</span><span> </span><span class="cr">Num</span><span> </span><span class="va">a</span><span> </span><span class="kw">where</span><span>
    </span><span class="sy">(</span><span class="op">+</span><span class="sy">)</span><span> </span><span class="sy">::</span><span> </span><span class="va">a</span><span> </span><span class="sy">-&gt;</span><span> </span><span class="va">a</span><span> </span><span class="sy">-&gt;</span><span> </span><span class="va">a</span><span>
    </span><span class="co">-- other numeric operations...</span><span>
</span></code></pre></div>
<p>This means that + can be used with any type that’s an instance of Num (like Int, Float, etc.).</p>
<h3 id="polymorphism-with-type-classes">Polymorphism with Type Classes</h3>
<p>You can define polymorphic functions that work with any type that’s an instance of a specific type class. Here’s an example of a polymorphic function that works with any type that implements the Show type class (which is responsible for converting values to strings):</p>
<div class="source-code"><pre><code class="language-haskell"><span class="va">printValue</span><span> </span><span class="sy">::</span><span> </span><span class="cr">Show</span><span> </span><span class="va">a</span><span> </span><span class="sy">=&gt;</span><span> </span><span class="va">a</span><span> </span><span class="sy">-&gt;</span><span> </span><span class="cr">String</span><span>
</span><span class="va">printValue</span><span> </span><span class="va">value</span><span> </span><span class="sy">=</span><span> </span><span class="st">&quot;The value is: &quot;</span><span> </span><span class="op">++</span><span> </span><span class="va">show</span><span> </span><span class="va">value</span><span>
</span></code></pre></div>
<p>Here, Show a =&gt; is a type class constraint. It means that printValue can accept any type a as long as a is an instance of the Show type class. The function then uses the show function (which converts a value to a String) to display the value.</p>
<h3 id="type-families">Type Families</h3>
<p>Type families are a more advanced feature that allows you to associate types with type classes, effectively creating a form of type-level functions. They enable more flexibility and power in type classes, allowing for more dynamic behavior based on types.</p>
<h4 id="example-type-families-for-different-container-types">Example: Type Families for Different Container Types</h4>
<p>Let’s say we want to define a type class for container-like data structures (e.g., List, Maybe, etc.), but we want to allow different types of elements in these containers. Type families can help us here.</p>
<div class="source-code"><pre><code class="language-haskell"><span class="pr">{-# LANGUAGE TypeFamilies #-}</span><span>

</span><span class="kw">class</span><span> </span><span class="cr">Container</span><span> </span><span class="va">c</span><span> </span><span class="kw">where</span><span>
    </span><span class="kw">type</span><span> </span><span class="cr">Element</span><span> </span><span class="va">c</span><span>
    </span><span class="va">empty</span><span> </span><span class="sy">::</span><span> </span><span class="va">c</span><span>
    </span><span class="va">insert</span><span> </span><span class="sy">::</span><span> </span><span class="cr">Element</span><span> </span><span class="va">c</span><span> </span><span class="sy">-&gt;</span><span> </span><span class="va">c</span><span> </span><span class="sy">-&gt;</span><span> </span><span class="va">c</span><span>

</span><span class="co">-- List instance of Container</span><span>
</span><span class="kw">instance</span><span> </span><span class="cr">Container</span><span> </span><span class="sy">[</span><span class="va">a</span><span class="sy">]</span><span> </span><span class="kw">where</span><span>
    </span><span class="kw">type</span><span> </span><span class="cr">Element</span><span> </span><span class="sy">[</span><span class="va">a</span><span class="sy">]</span><span> </span><span class="sy">=</span><span> </span><span class="va">a</span><span>
    </span><span class="va">empty</span><span> </span><span class="sy">=</span><span> </span><span class="sy">[</span><span class="sy">]</span><span>
    </span><span class="va">insert</span><span> </span><span class="va">x</span><span> </span><span class="va">xs</span><span> </span><span class="sy">=</span><span> </span><span class="va">x</span><span> </span><span class="sy">:</span><span> </span><span class="va">xs</span><span>

</span><span class="co">-- Maybe instance of Container</span><span>
</span><span class="kw">instance</span><span> </span><span class="cr">Container</span><span> </span><span class="sy">(</span><span class="cr">Maybe</span><span> </span><span class="va">a</span><span class="sy">)</span><span> </span><span class="kw">where</span><span>
    </span><span class="kw">type</span><span> </span><span class="cr">Element</span><span> </span><span class="sy">(</span><span class="cr">Maybe</span><span> </span><span class="va">a</span><span class="sy">)</span><span> </span><span class="sy">=</span><span> </span><span class="va">a</span><span>
    </span><span class="va">empty</span><span> </span><span class="sy">=</span><span> </span><span class="cr">Nothing</span><span>
    </span><span class="va">insert</span><span> </span><span class="va">x</span><span> </span><span class="sy">_</span><span> </span><span class="sy">=</span><span> </span><span class="cr">Just</span><span> </span><span class="va">x</span><span>
</span></code></pre></div>
<p>In this example:</p>
<ul>
<li>
We define a Container type class with a type family Element c, which represents the type of elements that can be stored in the container.
</li>
<li>
We then provide two instances: one for lists <code>([a])</code> and one for <code>Maybe a</code>. Each instance defines what kind of elements can be inserted and how to handle insertion and the “empty” state.
</li>
</ul>
<h3 id="phantom-types-for-extra-type-safety">Phantom Types for Extra Type Safety</h3>
<p>Phantom types are an advanced feature in Haskell where a type parameter is included in the type definition but is not used in the actual data. They are useful for adding extra type safety to your programs, especially when you want to encode additional constraints or metadata into the types.</p>
<h4 id="example-phantom-types-for-unit-safety">Example: Phantom Types for Unit Safety</h4>
<p>Let’s say we want to create a system that tracks distances, but we want to make sure that we never accidentally mix up meters and kilometers.</p>
<div class="source-code"><pre><code class="language-haskell"><span class="pr">{-# LANGUAGE GADTs #-}</span><span>

</span><span class="kw">data</span><span> </span><span class="cr">Meters</span><span>
</span><span class="kw">data</span><span> </span><span class="cr">Kilometers</span><span>

</span><span class="kw">data</span><span> </span><span class="cr">Distance</span><span> </span><span class="va">a</span><span> </span><span class="kw">where</span><span>
    </span><span class="cr">MkDistance</span><span> </span><span class="sy">::</span><span> </span><span class="cr">Double</span><span> </span><span class="sy">-&gt;</span><span> </span><span class="cr">Distance</span><span> </span><span class="va">a</span><span>

</span><span class="va">convertToKilometers</span><span> </span><span class="sy">::</span><span> </span><span class="cr">Distance</span><span> </span><span class="cr">Meters</span><span> </span><span class="sy">-&gt;</span><span> </span><span class="cr">Distance</span><span> </span><span class="cr">Kilometers</span><span>
</span><span class="va">convertToKilometers</span><span> </span><span class="sy">(</span><span class="cr">MkDistance</span><span> </span><span class="va">d</span><span class="sy">)</span><span> </span><span class="sy">=</span><span> </span><span class="cr">MkDistance</span><span> </span><span class="sy">(</span><span class="va">d</span><span> </span><span class="op">/</span><span> </span><span class="it">1000</span><span class="sy">)</span><span>

</span><span class="co">-- Example usage</span><span>
</span><span class="va">distanceInMeters</span><span> </span><span class="sy">::</span><span> </span><span class="cr">Distance</span><span> </span><span class="cr">Meters</span><span>
</span><span class="va">distanceInMeters</span><span> </span><span class="sy">=</span><span> </span><span class="cr">MkDistance</span><span> </span><span class="it">5000</span><span>

</span><span class="va">distanceInKilometers</span><span> </span><span class="sy">::</span><span> </span><span class="cr">Distance</span><span> </span><span class="cr">Kilometers</span><span>
</span><span class="va">distanceInKilometers</span><span> </span><span class="sy">=</span><span> </span><span class="va">convertToKilometers</span><span> </span><span class="va">distanceInMeters</span><span>
</span></code></pre></div>
<p>In this example:</p>
<ul>
<li>
We define two phantom types, Meters and Kilometers, which represent the units of distance.
</li>
<li>
The Distance a type takes a phantom type a, which is either Meters or Kilometers. This ensures that distances are always associated with a specific unit.
</li>
<li>
We define a convertToKilometers function that safely converts a distance in meters to kilometers.
</li>
</ul>
<p>With phantom types, you can ensure that your code is type-safe at compile time, preventing errors like mixing up units of measurement.</p>
<h3 id="typelevel-programming">Type-Level Programming</h3>
<p>Haskell allows for type-level programming, where types can be manipulated much like values. This opens the door to highly expressive and type-safe code. You can perform computations and enforce constraints at the type level, reducing the need for runtime checks.</p>
<h4 id="example-typelevel-natural-numbers">Example: Type-Level Natural Numbers</h4>
<p>We can use type-level programming to represent physical dimensions (e.g., length, mass, time) and ensure that our units are consistent in mathematical operations.</p>
<div class="source-code"><pre><code class="language-haskell"><span class="pr">{-# LANGUAGE DataKinds #-}</span><span>
</span><span class="pr">{-# LANGUAGE KindSignatures #-}</span><span>
</span><span class="pr">{-# LANGUAGE TypeOperators #-}</span><span>

</span><span class="kw">data</span><span> </span><span class="cr">Meter</span><span>
</span><span class="kw">data</span><span> </span><span class="cr">Second</span><span>

</span><span class="kw">data</span><span> </span><span class="cr">Quantity</span><span> </span><span class="sy">(</span><span class="kw">unit</span><span> </span><span class="sy">::</span><span> </span><span class="sy">*</span><span class="sy">)</span><span> </span><span class="kw">where</span><span>
    </span><span class="cr">MkQuantity</span><span> </span><span class="sy">::</span><span> </span><span class="cr">Double</span><span> </span><span class="sy">-&gt;</span><span> </span><span class="cr">Quantity</span><span> </span><span class="kw">unit</span><span>

</span><span class="co">-- Adding two quantities of the same unit</span><span>
</span><span class="va">addQuantities</span><span> </span><span class="sy">::</span><span> </span><span class="cr">Quantity</span><span> </span><span class="kw">unit</span><span> </span><span class="sy">-&gt;</span><span> </span><span class="cr">Quantity</span><span> </span><span class="kw">unit</span><span> </span><span class="sy">-&gt;</span><span> </span><span class="cr">Quantity</span><span> </span><span class="kw">unit</span><span>
</span><span class="va">addQuantities</span><span> </span><span class="sy">(</span><span class="cr">MkQuantity</span><span> </span><span class="va">x</span><span class="sy">)</span><span> </span><span class="sy">(</span><span class="cr">MkQuantity</span><span> </span><span class="va">y</span><span class="sy">)</span><span> </span><span class="sy">=</span><span> </span><span class="cr">MkQuantity</span><span> </span><span class="sy">(</span><span class="va">x</span><span> </span><span class="op">+</span><span> </span><span class="va">y</span><span class="sy">)</span><span>

</span><span class="co">-- Example usage</span><span>
</span><span class="va">distance</span><span> </span><span class="sy">::</span><span> </span><span class="cr">Quantity</span><span> </span><span class="cr">Meter</span><span>
</span><span class="va">distance</span><span> </span><span class="sy">=</span><span> </span><span class="cr">MkQuantity</span><span> </span><span class="it">100</span><span>

</span><span class="va">time</span><span> </span><span class="sy">::</span><span> </span><span class="cr">Quantity</span><span> </span><span class="cr">Second</span><span>
</span><span class="va">time</span><span> </span><span class="sy">=</span><span> </span><span class="cr">MkQuantity</span><span> </span><span class="ra">9.58</span><span>

</span><span class="co">-- This works:</span><span>
</span><span class="va">sumDistance</span><span> </span><span class="sy">=</span><span> </span><span class="va">addQuantities</span><span> </span><span class="va">distance</span><span> </span><span class="va">distance</span><span>

</span><span class="co">-- This would fail to compile if uncommented (mismatched units):</span><span>
</span><span class="co">-- sumTimeDistance = addQuantities distance time</span><span>
</span></code></pre></div>
<p>In this example:</p>
<ul>
<li>
We define a Quantity type that takes a unit (e.g., Meter or Second) as a type parameter.
</li>
<li>
The addQuantities function ensures that we can only add quantities of the same unit.
</li>
<li>
If we try to add a distance to a time, Haskell’s type system will catch this error at compile time.
</li>
</ul>
<h2 id="recap-exercises">Recap &amp; Exercises</h2>
<h3 id="recap">Recap</h3>
<p>In this lesson, we’ve explored the foundational concepts of types and domain theory in Haskell. By understanding how types work in Haskell and how to apply domain-driven design, you’re now equipped with the tools to model real-world domains accurately and safely. Let’s review the key takeaways from this lesson:</p>
<ul>
<li>
<strong>Simple Types and Type Signatures</strong>:
<ul>
<li>
Type signatures describe the inputs and outputs of functions, providing a clear contract for what a function does.
</li>
<li>
Primitive types like <code>Int</code>, <code>Float</code>, <code>Bool</code>, and <code>String</code> are the basic building blocks for more complex data structures.
</li>
<li>
Haskell’s type system is based on currying, meaning that every function takes one argument and returns a new function if more arguments are required.
</li>
<li>
Polymorphic types allow functions to work with any type, providing flexibility and reuse.
</li>
</ul>
</li>
<li>
<strong>Domain-Driven Design</strong>:
<ul>
<li>
Domain-driven design (DDD) is a methodology for structuring software around real-world business domains, using types to model the domain in code.
</li>
<li>
Avoid using primitive types like <code>Int</code> or <code>String</code> for domain concepts. Instead, define domain-specific types like <code>CustomerId</code>, <code>OrderId</code>, or <code>ProductName</code> to make your code more meaningful and safe.
</li>
<li>
Use the language of the business domain when modeling in code, ensuring that the types and structures reflect real-world concepts accurately.
</li>
</ul>
</li>
<li>
<strong>Pairing Domain Theory with Type Theory</strong>:
<ul>
<li>
Haskell’s type system allows you to enforce valid states in your domain model by encoding business rules directly into the type system.
</li>
<li>
Type safety prevents invalid states, such as negative quantities or empty product names, from existing in your system, reducing runtime errors.
</li>
<li>
The Haskell compiler works with you to infer types, but explicit type annotations provide clarity and enforce constraints.
</li>
</ul>
</li>
<li>
<strong>Advanced Type Concepts</strong>:
<ul>
<li>
<strong>Type Classes</strong>: Haskell’s type classes allow for ad hoc polymorphism, providing a way to define generic interfaces that can be implemented by different types.
</li>
<li>
<strong>Type Families</strong>: Type families let you associate types with type classes, allowing for more flexible and dynamic behavior based on types.
</li>
<li>
<strong>Phantom Types</strong>: Phantom types allow you to add extra type safety without affecting runtime behavior. They’re especially useful for encoding additional constraints or metadata into the type system.
</li>
<li>
<strong>Type-Level Programming</strong>: Haskell allows for type-level programming, enabling you to enforce constraints at the type level and reducing the need for runtime checks.
</li>
</ul>
</li>
</ul>
<p>These are the building blocks of functional programming in Haskell and the key to creating robust, type-safe applications. By mastering types and domain modeling, you’re well on your way to becoming a proficient Haskell developer.</p>
<h3 id="exercises">Exercises</h3>
<p>Now it’s time to put what you’ve learned into practice. The following exercises will help reinforce the concepts from this lesson by challenging you to think through real-world domain problems and apply Haskell’s type system effectively.</p>
<h4 id="exercise-1-modeling-a-banking-system">Exercise 1: Modeling a Banking System</h4>
<p><strong>Objective</strong>: Create a simple banking system using domain-driven design principles.</p>
<ul>
<li>
Define the following types:
<ul>
<li>
<code>AccountId</code>: A unique identifier for a bank account.
</li>
<li>
<code>Balance</code>: The current balance in the account (use a custom type to prevent negative balances).
</li>
<li>
<code>TransactionType</code>: An algebraic data type representing deposits and withdrawals.
</li>
<li>
<code>Transaction</code>: A record type representing a transaction (including the type and the amount).
</li>
</ul>
</li>
<li>
Write a function <code>applyTransaction :: Balance -&gt; Transaction -&gt; Maybe Balance</code> that updates the balance based on the transaction. Ensure that withdrawals cannot exceed the balance.
</li>
</ul>
<p><strong>Hint</strong>: Use a custom type to ensure that <code>Balance</code> can never be negative.</p>
<div class="source-code"><pre><code class="language-haskell"><span class="co">-- Example skeleton</span><span>
</span><span class="kw">newtype</span><span> </span><span class="cr">Balance</span><span> </span><span class="sy">=</span><span> </span><span class="cr">Balance</span><span> </span><span class="cr">Float</span><span>
</span><span class="kw">data</span><span> </span><span class="cr">TransactionType</span><span> </span><span class="sy">=</span><span> </span><span class="cr">Deposit</span><span> </span><span class="sy">|</span><span> </span><span class="cr">Withdrawal</span><span>
</span><span class="kw">data</span><span> </span><span class="cr">Transaction</span><span> </span><span class="sy">=</span><span> </span><span class="cr">Transaction</span><span> </span><span class="sy">{</span><span> </span><span class="va">tType</span><span> </span><span class="sy">::</span><span> </span><span class="cr">TransactionType</span><span class="sy">,</span><span> </span><span class="va">amount</span><span> </span><span class="sy">::</span><span> </span><span class="cr">Float</span><span> </span><span class="sy">}</span><span>

</span><span class="va">applyTransaction</span><span> </span><span class="sy">::</span><span> </span><span class="cr">Balance</span><span> </span><span class="sy">-&gt;</span><span> </span><span class="cr">Transaction</span><span> </span><span class="sy">-&gt;</span><span> </span><span class="cr">Maybe</span><span> </span><span class="cr">Balance</span><span>
</span><span class="co">-- Implement your function here</span><span>
</span></code></pre></div>
<h4 id="exercise-2-aggregating-data-from-multiple-vendors">Exercise 2: Aggregating Data from Multiple Vendors</h4>
<p><strong>Objective:</strong> Model a system that aggregates data from three different vendors.</p>
<ul>
<li>
Define a custom type Vendor with constructors VendorA, VendorB, and VendorC.
</li>
<li>
Create a type DataFeed to represent real-time data from each vendor (e.g., temperature, humidity, and pressure).
</li>
<li>
Write a function aggregateFeeds :: DataFeed -&gt; DataFeed -&gt; DataFeed -&gt; DataFeed that combines the data from each vendor, selecting the most recent valid data for each field.
</li>
</ul>
<p><strong>Hint:</strong> Use Maybe types for fields that might be missing, and use pattern matching to choose valid data.</p>
<div class="source-code"><pre><code class="language-haskell"><span class="co">-- Example skeleton</span><span>
</span><span class="kw">data</span><span> </span><span class="cr">Vendor</span><span> </span><span class="sy">=</span><span> </span><span class="cr">VendorA</span><span> </span><span class="sy">|</span><span> </span><span class="cr">VendorB</span><span> </span><span class="sy">|</span><span> </span><span class="cr">VendorC</span><span>
</span><span class="kw">data</span><span> </span><span class="cr">DataFeed</span><span> </span><span class="sy">=</span><span> </span><span class="cr">DataFeed</span><span> </span><span class="sy">{</span><span> </span><span class="va">temperature</span><span> </span><span class="sy">::</span><span> </span><span class="cr">Maybe</span><span> </span><span class="cr">Float</span><span class="sy">,</span><span> </span><span class="va">humidity</span><span> </span><span class="sy">::</span><span> </span><span class="cr">Maybe</span><span> </span><span class="cr">Float</span><span class="sy">,</span><span> </span><span class="va">pressure</span><span> </span><span class="sy">::</span><span> </span><span class="cr">Maybe</span><span> </span><span class="cr">Float</span><span> </span><span class="sy">}</span><span>

</span><span class="va">aggregateFeeds</span><span> </span><span class="sy">::</span><span> </span><span class="cr">DataFeed</span><span> </span><span class="sy">-&gt;</span><span> </span><span class="cr">DataFeed</span><span> </span><span class="sy">-&gt;</span><span> </span><span class="cr">DataFeed</span><span> </span><span class="sy">-&gt;</span><span> </span><span class="cr">DataFeed</span><span>
</span><span class="co">-- Implement your function here</span><span>
</span></code></pre></div>
<h4 id="exercise-3-using-phantom-types-for-unit-safety">Exercise 3: Using Phantom Types for Unit Safety</h4>
<p><strong>Objective:</strong> Prevent unit mix-ups using phantom types.</p>
<ul>
<li>
Define two phantom types Meters and Kilometers.
</li>
<li>
Create a Distance type that uses phantom types to represent distances in meters or kilometers.
</li>
<li>
Write a function convertToKilometers :: Distance Meters -&gt; Distance Kilometers that converts a distance in meters to kilometers.
</li>
<li>
Try to add distances in meters and kilometers together, and make sure the compiler prevents it!
</li>
</ul>
<div class="source-code"><pre><code class="language-haskell"><span class="co">-- Example skeleton</span><span>
</span><span class="kw">data</span><span> </span><span class="cr">Meters</span><span>
</span><span class="kw">data</span><span> </span><span class="cr">Kilometers</span><span>

</span><span class="kw">data</span><span> </span><span class="cr">Distance</span><span> </span><span class="va">a</span><span> </span><span class="sy">=</span><span> </span><span class="cr">MkDistance</span><span> </span><span class="cr">Double</span><span>

</span><span class="va">convertToKilometers</span><span> </span><span class="sy">::</span><span> </span><span class="cr">Distance</span><span> </span><span class="cr">Meters</span><span> </span><span class="sy">-&gt;</span><span> </span><span class="cr">Distance</span><span> </span><span class="cr">Kilometers</span><span>
</span><span class="co">-- Implement your function here</span><span>
</span></code></pre></div>
<p><a href="/landing/Blog/SetupInstructions">Previous Chapter</a> |
<a href="/landing/Blog/Chapter2">Next Chapter</a></p>
</div></div></body></html>