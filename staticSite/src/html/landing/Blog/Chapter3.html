<html lang="en"><head><style>
/* Markdown Shell */
.containerBlog {
   padding: 200px;
   background-color: black;
   color: white;
   font-size: 20px;
   font-family: Georgia, serif;
}

.containerBlog ol {
   list-style-type: decimal;
   padding-left: 2.5rem;
}
.containerBlog ul {
   list-style-type: disc;
   padding-left: 2.5rem;
}

.containerBlog td {
   padding: 3px;
   border-color: #888;
}

.containerBlog li {
   padding: 5px 10px;
}

.containerBlog p {
   padding: 10px 0px;
}

.containerBlog a {
   color: #00B9DA;
   text-decoration: none;
}

.containerBlog p code {
  background-color: #D3D3D3;
  padding: 0px 3px;
  border-radius: 0.5rem;
}

.containerBlog h1 {
  padding: 25px 0px;
  font-weight: bold;
  font-size: 2em;
  color: #fff4f4;
  text-decoration: underline;
}
.containerBlog h2 {
  padding: 25px 0px;
  font-weight: bold;
  font-size: 1.5em;
  color: #fff4f4;
  text-decoration: underline;
}
.containerBlog h3 {
  padding: 25px 0px;
  font-weight: bold;
  font-size:1.17em;
  color: #fff4f4;
  text-decoration: underline;
}
.containerBlog h4 {
  padding: 25px 0px;
  font-weight: bold;
  font-size: 1em;
  color: #fff4f4;
  text-decoration: underline;
}
.containerBlog h5 {
  padding: 25px 0px;
  font-weight: bold;
  font-size: 0.83em;
  color: #fff4f4;
  text-decoration: underline;
}



/* Otherwise comments can go on into infinity */
span.co {
  word-break: break-word;        /* Safe wrap on words */
  overflow-wrap: anywhere;       /* Force wrap anywhere if needed */
  white-space: normal;           /* Allow wrapping */
}


code:not([class]) {
  /* your styles here */
  background-color: white;
  padding: 4px;
  border-radius: 5px;
}

code span {
  display: inline;
  white-space: pre;
}

.source-code {
  padding: 8px;
  border-color: white;
  background-color: black;
}

}
/* One off haskell constructs */
code {
  color: #154dcb;
  font-weight: bold;
}

div.source-code {
  overflow-x:auto;
  max-width:100%;
}

code.language-haskell {
  overflow-x:auto;
  max-width:100%;
}

/* Haskell Syntax */
.pr {
   color: #F8E473;
}
.op {
   color: gold;
}
.sy {
   color: #FADA5E;
}
.co {
   color: green;
}
.cr {
   color: #af64ff;
}
.va {
   color: #6693F5; 
}
.kw {
    color: #f0883e;
}

/* Haskell Syntax - Literals */
.st {
  color: #a5d6ff;
}
.ch {
  color: #2E3A59;
}
.it {}
.ra {}


/* Other Languages Via Skylighting Tokenizer */

.pp {
  color: blue;
}
.im {
  color: green;
}
.dt {
  color: green;
}
.cf {
  color: orange;
}
/*Like char */
.sc {
  color: orange;
}
/* java func */
.fu {
  color: #6693F5;
}

/* base color C lang */
.language-c {
  color: #6693F5;
}

.language-bash {
  color: #154dcb;
  font-weight: bold;
}

.language-nix {
  color: grey;
  font-weight: bold;
}

.language-java {
  color: #6693F5;
}
.language-csharp {
  color: #E3B778;
}
.language-python {
  color: #E3B778;
}
</style><style>a { color: #00B9DA; text-decoration: none; }</style></head><body><div class="fixed top-0 left-0 w-full h-full overflow-auto z-10 scroll-smooth"><div class="containerBlog"><h1 id="lesson-3-its-all-patterns">Lesson 3 - It&#39;s All Patterns</h1>
<ol>
<li>
<a href="/landing/Blog/Chapter3#introduction">Introduction</a>
</li>
<li>
<a href="/landing/Blog/Chapter3#what-is-pattern-matching">What is Pattern Matching?</a>
</li>
<li>
<a href="/landing/Blog/Chapter3#guards-finetuning-your-patterns">Guards: Fine-Tuning Your Patterns</a>
</li>
<li>
<a href="/landing/Blog/Chapter3#ifelse">If-Else</a>
</li>
<li>
<a href="/landing/Blog/Chapter3#realworld-example">Real-World Example</a>
</li>
<li>
<a href="/landing/Blog/Chapter3#recap">Recap &amp; Exercises</a>
</li>
</ol>
<h2 id="introduction">Introduction</h2>
<p>In Haskell, <strong>pattern matching</strong> is one of the most powerful tools at your disposal. It allows you to deconstruct and inspect data in a concise, readable way, handling different cases with ease. Pattern matching goes beyond simple conditional logic—Haskell’s strong type system allows us to match patterns across a wide range of data types, ensuring we handle all possible cases safely.</p>
<p>In this lesson, we’ll dive deep into <strong>pattern matching</strong>, <strong>guards</strong>, and <strong>if-else</strong> expressions, and we’ll see how these tools allow us to express complex logic elegantly and concisely. We will also explore why pattern matching is far superior to similar approaches in imperative or object-oriented languages, and how it allows for mathematical guarantees in our code.</p>
<h2 id="what-is-pattern-matching">What is Pattern Matching?</h2>
<p>Pattern matching in Haskell is an integral part of the language’s type system that provides guarantees no other paradigm offers. In languages like Java or Python, handling multiple cases usually involves complex <strong>if-else</strong> trees or switch statements, which can easily become unwieldy and miss edge cases. Haskell’s pattern matching, combined with its strong typing and exhaustive checking, ensures that all possible cases are handled and nothing is missed.</p>
<h3 id="why-pattern-matching-is-so-powerful">Why Pattern Matching is So Powerful</h3>
<h4 id="exhaustiveness-checking">Exhaustiveness Checking</h4>
<p>One of the most powerful aspects of pattern matching in Haskell is that the compiler will <strong>warn you</strong> (by not compiling) if you haven’t covered all possible cases of a data type. This feature eliminates a common source of bugs in imperative and object-oriented languages, where missing a single branch in a chain of conditionals could lead to unpredictable behavior.</p>
<p><strong>Example</strong>:</p>
<div class="source-code"><pre><code class="language-haskell"><span class="kw">data</span><span> </span><span class="cr">TrafficLight</span><span> </span><span class="sy">=</span><span> </span><span class="cr">Red</span><span> </span><span class="sy">|</span><span> </span><span class="cr">Yellow</span><span> </span><span class="sy">|</span><span> </span><span class="cr">Green</span><span>

</span><span class="co">-- If we omit a case, the compiler will warn us.</span><span>
</span><span class="va">trafficAction</span><span> </span><span class="sy">::</span><span> </span><span class="cr">TrafficLight</span><span> </span><span class="sy">-&gt;</span><span> </span><span class="cr">String</span><span>
</span><span class="va">trafficAction</span><span> </span><span class="cr">Red</span><span> </span><span class="sy">=</span><span> </span><span class="st">&quot;Stop&quot;</span><span>
</span><span class="va">trafficAction</span><span> </span><span class="cr">Yellow</span><span> </span><span class="sy">=</span><span> </span><span class="st">&quot;Slow down&quot;</span><span>
</span><span class="co">-- We forgot Green!</span><span>
</span></code></pre></div>
<p><strong>Safe Division Example with Maybe</strong></p>
<p>In Haskell, Maybe is an algebraic data type that represents a computation that might fail or return nothing. It has two constructors:</p>
<ul>
<li>
Just a (representing a value of type a)
</li>
<li>
Nothing (representing the absence of a value)
</li>
</ul>
<p>When you pattern match on a Maybe type, the Haskell compiler ensures that you handle both the Just and Nothing cases. If you miss one of these cases, the compiler will warn you, ensuring you don’t accidentally leave out an edge case.</p>
<p>Here’s an example of safely performing division, where we return Nothing if there’s an attempt to divide by zero:</p>
<div class="source-code"><pre><code class="language-haskell"><span class="va">safeDiv</span><span> </span><span class="sy">::</span><span> </span><span class="cr">Int</span><span> </span><span class="sy">-&gt;</span><span> </span><span class="cr">Int</span><span> </span><span class="sy">-&gt;</span><span> </span><span class="cr">Maybe</span><span> </span><span class="cr">Int</span><span>
</span><span class="va">safeDiv</span><span> </span><span class="sy">_</span><span> </span><span class="it">0</span><span> </span><span class="sy">=</span><span> </span><span class="cr">Nothing</span><span>      </span><span class="co">-- Handle division by zero</span><span>
</span><span class="va">safeDiv</span><span> </span><span class="va">x</span><span> </span><span class="va">y</span><span> </span><span class="sy">=</span><span> </span><span class="cr">Just</span><span> </span><span class="sy">(</span><span class="va">x</span><span> </span><span class="sy">`</span><span class="va">div</span><span class="sy">`</span><span> </span><span class="va">y</span><span class="sy">)</span><span>
</span></code></pre></div>
<p>In this case:</p>
<ul>
<li>
The first pattern <code>safeDiv _ 0 = Nothing</code> explicitly handles the edge case where the divisor is 0.
</li>
<li>
The second pattern <code>safeDiv x y = Just (x div y)</code> handles all other cases, wrapping the result in Just to indicate success.
</li>
</ul>
<p>By forcing us to handle both Just and Nothing, the Haskell compiler ensures we’ve considered all possibilities and haven’t missed an edge case. If you accidentally forget to account for Nothing, the compiler will throw a warning or error.</p>
<p><strong>Using Pattern Matching on Maybe</strong></p>
<p>When you use a Maybe result in another function, pattern matching ensures that both possible cases (Just and Nothing) are addressed:</p>
<div class="source-code"><pre><code class="language-haskell"><span class="va">describeResult</span><span> </span><span class="sy">::</span><span> </span><span class="cr">Maybe</span><span> </span><span class="cr">Int</span><span> </span><span class="sy">-&gt;</span><span> </span><span class="cr">String</span><span>
</span><span class="va">describeResult</span><span> </span><span class="cr">Nothing</span><span> </span><span class="sy">=</span><span> </span><span class="st">&quot;No result&quot;</span><span>  </span><span class="co">-- Handle Nothing</span><span>
</span><span class="va">describeResult</span><span> </span><span class="sy">(</span><span class="cr">Just</span><span> </span><span class="va">n</span><span class="sy">)</span><span> </span><span class="sy">=</span><span> </span><span class="st">&quot;The result is &quot;</span><span> </span><span class="op">++</span><span> </span><span class="va">show</span><span> </span><span class="va">n</span><span>
</span></code></pre></div>
<p>In this function:</p>
<ul>
<li>
We handle the Nothing case by returning “No result”.
</li>
<li>
We handle the Just case by extracting the value n and printing it.
</li>
</ul>
<h4 id="guarantee-against-missed-edge-cases">Guarantee Against Missed Edge Cases</h4>
<p>If we forget to handle one of these cases, Haskell’s compiler will warn us:</p>
<div class="source-code"><pre><code class="language-haskell"><span class="va">describeResult</span><span> </span><span class="sy">(</span><span class="cr">Just</span><span> </span><span class="va">n</span><span class="sy">)</span><span> </span><span class="sy">=</span><span> </span><span class="st">&quot;The result is &quot;</span><span> </span><span class="op">++</span><span> </span><span class="va">show</span><span> </span><span class="va">n</span><span>
</span></code></pre></div>
<p>The above code would produce a warning like:</p>
<pre><code>Warning: Pattern match(es) are non-exhaustive
</code></pre>
<p>This warning indicates that we’ve missed a case (Nothing), ensuring we handle all possible outcomes of Maybe.</p>
<h4 id="mathematical-guarantees">Mathematical Guarantees</h4>
<p>Haskell’s pattern matching is rooted in mathematical proofs and logic. Thanks to algebraic data types, the set of possible patterns for any given input is finite and well-defined, meaning the compiler can mathematically prove that your function is total (i.e., defined for all possible inputs). This gives you the confidence that your function will never fail due to a missing case, which is a massive benefit in industries like finance, healthcare, and aerospace, where correctness is paramount.</p>
<h4 id="integration-with-propertybased-testing">Integration with Property-Based Testing</h4>
<p>Pattern matching is of vital importance when it comes to property testing, especially in Haskell. Since we know we’ve covered all possible cases of our data types, we can use tools like QuickCheck to automatically generate test cases that ensure our code behaves correctly for all possible inputs. This is a massive advantage over manually writing test cases, where it’s easy to miss certain edge cases.</p>
<p><strong>Example</strong>:</p>
<div class="source-code"><pre><code class="language-haskell"><span class="va">prop_trafficLight</span><span> </span><span class="sy">::</span><span> </span><span class="cr">TrafficLight</span><span> </span><span class="sy">-&gt;</span><span> </span><span class="cr">Bool</span><span>
</span><span class="va">prop_trafficLight</span><span> </span><span class="va">light</span><span> </span><span class="sy">=</span><span> </span><span class="kw">case</span><span> </span><span class="va">trafficAction</span><span> </span><span class="va">light</span><span> </span><span class="kw">of</span><span>
    </span><span class="st">&quot;Stop&quot;</span><span>       </span><span class="sy">-&gt;</span><span> </span><span class="va">light</span><span> </span><span class="op">==</span><span> </span><span class="cr">Red</span><span>
    </span><span class="st">&quot;Slow down&quot;</span><span>  </span><span class="sy">-&gt;</span><span> </span><span class="va">light</span><span> </span><span class="op">==</span><span> </span><span class="cr">Yellow</span><span>
    </span><span class="st">&quot;Go&quot;</span><span>         </span><span class="sy">-&gt;</span><span> </span><span class="va">light</span><span> </span><span class="op">==</span><span> </span><span class="cr">Green</span><span>
</span></code></pre></div>
<h4 id="cleaner-more-declarative-code">Cleaner, More Declarative Code</h4>
<p>Traditional if-else chains in object-oriented or imperative languages tend to become unwieldy as complexity grows. They are often verbose and harder to reason about. Pattern matching, by contrast, provides a declarative way to handle different cases. Each case is explicitly defined in a way that mirrors how we naturally think about different possibilities for a given problem.</p>
<p><strong>Example (Java-style logic with switch statements):</strong></p>
<div class="source-code"><pre><code class="language-java"><span class="cf">switch</span><span> </span><span class="op">(</span><span>trafficLight</span><span class="op">)</span><span> </span><span class="op">{</span>
<span>    </span><span class="cf">case</span><span> RED</span><span class="op">:</span>
<span>        </span><span class="cf">return</span><span> </span><span class="st">&quot;Stop&quot;</span><span class="op">;</span>
<span>    </span><span class="cf">case</span><span> YELLOW</span><span class="op">:</span>
<span>        </span><span class="cf">return</span><span> </span><span class="st">&quot;Slow down&quot;</span><span class="op">;</span>
<span>    </span><span class="cf">case</span><span> GREEN</span><span class="op">:</span>
<span>        </span><span class="cf">return</span><span> </span><span class="st">&quot;Go&quot;</span><span class="op">;</span>
<span>    </span><span class="kw">default</span><span class="op">:</span>
<span>        </span><span class="cf">throw</span><span> </span><span class="kw">new</span><span> </span><span class="bu">IllegalStateException</span><span class="op">(</span><span class="st">&quot;Unexpected value&quot;</span><span class="op">);</span>
<span class="op">}</span>
</code></pre></div>
<p><strong>Example (Haskell-style pattern matching):</strong></p>
<div class="source-code"><pre><code class="language-haskell"><span class="va">trafficAction</span><span> </span><span class="sy">::</span><span> </span><span class="cr">TrafficLight</span><span> </span><span class="sy">-&gt;</span><span> </span><span class="cr">String</span><span>
</span><span class="va">trafficAction</span><span> </span><span class="cr">Red</span><span>    </span><span class="sy">=</span><span> </span><span class="st">&quot;Stop&quot;</span><span>
</span><span class="va">trafficAction</span><span> </span><span class="cr">Yellow</span><span> </span><span class="sy">=</span><span> </span><span class="st">&quot;Slow down&quot;</span><span>
</span><span class="va">trafficAction</span><span> </span><span class="cr">Green</span><span>  </span><span class="sy">=</span><span> </span><span class="st">&quot;Go&quot;</span><span>
</span></code></pre></div>
<p>Haskell’s approach not only makes the code more concise but also removes the need for an arbitrary default case. There’s no risk of missing an unexpected value, as the compiler will force you to handle every possibility.</p>
<h2 id="guards-finetuning-your-patterns">Guards: Fine-Tuning Your Patterns</h2>
<p>Guards allow you to add additional conditions to a pattern, providing more control over how patterns are matched. They act like filters that further refine the match by specifying conditions that must be true.</p>
<p><strong>Example of Guards:</strong></p>
<p>Let’s improve a function to calculate a grade based on a numeric score using guards.</p>
<div class="source-code"><pre><code class="language-haskell"><span class="va">grade</span><span> </span><span class="sy">::</span><span> </span><span class="cr">Int</span><span> </span><span class="sy">-&gt;</span><span> </span><span class="cr">String</span><span>
</span><span class="va">grade</span><span> </span><span class="va">score</span><span>
  </span><span class="sy">|</span><span> </span><span class="va">score</span><span> </span><span class="op">&gt;=</span><span> </span><span class="it">90</span><span> </span><span class="sy">=</span><span> </span><span class="st">&quot;A&quot;</span><span>
  </span><span class="sy">|</span><span> </span><span class="va">score</span><span> </span><span class="op">&gt;=</span><span> </span><span class="it">80</span><span> </span><span class="sy">=</span><span> </span><span class="st">&quot;B&quot;</span><span>
  </span><span class="sy">|</span><span> </span><span class="va">score</span><span> </span><span class="op">&gt;=</span><span> </span><span class="it">70</span><span> </span><span class="sy">=</span><span> </span><span class="st">&quot;C&quot;</span><span>
  </span><span class="sy">|</span><span> </span><span class="va">score</span><span> </span><span class="op">&gt;=</span><span> </span><span class="it">60</span><span> </span><span class="sy">=</span><span> </span><span class="st">&quot;D&quot;</span><span>
  </span><span class="sy">|</span><span> </span><span class="va">otherwise</span><span>   </span><span class="sy">=</span><span> </span><span class="st">&quot;F&quot;</span><span>
</span></code></pre></div>
<p>Here, we use guards (|) to specify the conditions under which each result is returned:</p>
<ul>
<li>
If score &gt;= 90, the function returns &quot;A&quot;.
</li>
<li>
If score &gt;= 80, it returns &quot;B&quot;, and so on.
</li>
<li>
The otherwise guard acts as a catch-all, ensuring that if none of the above conditions are true, the function will return &quot;F&quot;.
</li>
</ul>
<p><strong>Real-World Example with Guards:</strong></p>
<p>Consider a program that calculates shipping rates based on package weight:</p>
<div class="source-code"><pre><code class="language-haskell"><span class="va">shippingCost</span><span> </span><span class="sy">::</span><span> </span><span class="cr">Double</span><span> </span><span class="sy">-&gt;</span><span> </span><span class="cr">Double</span><span>
</span><span class="va">shippingCost</span><span> </span><span class="va">weight</span><span>
  </span><span class="sy">|</span><span> </span><span class="va">weight</span><span> </span><span class="op">&lt;=</span><span> </span><span class="ra">1.0</span><span>  </span><span class="sy">=</span><span> </span><span class="ra">5.00</span><span>
  </span><span class="sy">|</span><span> </span><span class="va">weight</span><span> </span><span class="op">&lt;=</span><span> </span><span class="ra">5.0</span><span>  </span><span class="sy">=</span><span> </span><span class="ra">10.00</span><span>
  </span><span class="sy">|</span><span> </span><span class="va">weight</span><span> </span><span class="op">&lt;=</span><span> </span><span class="ra">10.0</span><span> </span><span class="sy">=</span><span> </span><span class="ra">20.00</span><span>
  </span><span class="sy">|</span><span> </span><span class="va">otherwise</span><span>      </span><span class="sy">=</span><span> </span><span class="ra">50.00</span><span>
</span></code></pre></div>
<p>In this example, guards allow you to calculate the shipping cost based on weight ranges, providing clean and readable logic for each case.</p>
<h2 id="ifelse">If-Else</h2>
<p>While pattern matching and guards are the more functional way to handle conditional logic in Haskell, traditional if-else expressions still exist and are used for simpler cases. Haskell’s if-else is an expression rather than a statement (like in imperative languages), meaning it must always return a value.</p>
<p><strong>Example of If-Else:</strong></p>
<div class="source-code"><pre><code class="language-haskell"><span class="va">isEven</span><span> </span><span class="sy">::</span><span> </span><span class="cr">Int</span><span> </span><span class="sy">-&gt;</span><span> </span><span class="cr">Bool</span><span>
</span><span class="va">isEven</span><span> </span><span class="va">x</span><span> </span><span class="sy">=</span><span> </span><span class="kw">if</span><span> </span><span class="va">x</span><span> </span><span class="sy">`</span><span class="va">mod</span><span class="sy">`</span><span> </span><span class="it">2</span><span> </span><span class="op">==</span><span> </span><span class="it">0</span><span> </span><span class="kw">then</span><span> </span><span class="cr">True</span><span> </span><span class="kw">else</span><span> </span><span class="cr">False</span><span>
</span></code></pre></div>
<p>Here, the if-else expression evaluates whether x is divisible by 2, returning True if it is, and False otherwise.</p>
<h3 id="why-prefer-pattern-matching">Why Prefer Pattern Matching?</h3>
<p>Although if-else is available, Haskell encourages the use of pattern matching and guards because they allow for clearer and more composable code. You’ll often find that pattern matching leads to cleaner, more maintainable code.</p>
<h2 id="realworld-example">Real-World Example</h2>
<p>Let’s look at how pattern matching, guards, and if-else can come together in a more complex scenario: modeling a traffic light system.</p>
<div class="source-code"><pre><code class="language-haskell"><span class="kw">data</span><span> </span><span class="cr">TrafficLight</span><span> </span><span class="sy">=</span><span> </span><span class="cr">Red</span><span> </span><span class="sy">|</span><span> </span><span class="cr">Yellow</span><span> </span><span class="sy">|</span><span> </span><span class="cr">Green</span><span>

</span><span class="va">nextLight</span><span> </span><span class="sy">::</span><span> </span><span class="cr">TrafficLight</span><span> </span><span class="sy">-&gt;</span><span> </span><span class="cr">TrafficLight</span><span>
</span><span class="va">nextLight</span><span> </span><span class="cr">Red</span><span>    </span><span class="sy">=</span><span> </span><span class="cr">Green</span><span>
</span><span class="va">nextLight</span><span> </span><span class="cr">Yellow</span><span> </span><span class="sy">=</span><span> </span><span class="cr">Red</span><span>
</span><span class="va">nextLight</span><span> </span><span class="cr">Green</span><span>  </span><span class="sy">=</span><span> </span><span class="cr">Yellow</span><span>

</span><span class="va">trafficAction</span><span> </span><span class="sy">::</span><span> </span><span class="cr">TrafficLight</span><span> </span><span class="sy">-&gt;</span><span> </span><span class="cr">String</span><span>
</span><span class="va">trafficAction</span><span> </span><span class="va">light</span><span>
  </span><span class="sy">|</span><span> </span><span class="va">light</span><span> </span><span class="op">==</span><span> </span><span class="cr">Red</span><span>    </span><span class="sy">=</span><span> </span><span class="st">&quot;Stop&quot;</span><span>
  </span><span class="sy">|</span><span> </span><span class="va">light</span><span> </span><span class="op">==</span><span> </span><span class="cr">Yellow</span><span> </span><span class="sy">=</span><span> </span><span class="st">&quot;Slow down&quot;</span><span>
  </span><span class="sy">|</span><span> </span><span class="va">light</span><span> </span><span class="op">==</span><span> </span><span class="cr">Green</span><span>  </span><span class="sy">=</span><span> </span><span class="st">&quot;Go&quot;</span><span>
</span></code></pre></div>
<ul>
<li>
<code>nextLight</code> uses pattern matching to define what the next traffic light will be based on the current state.
</li>
<li>
<code>trafficAction</code> uses guards to specify the action based on the color of the traffic light.
</li>
</ul>
<h3 id="a-more-complex-example-atm-withdrawal">A More Complex Example: ATM Withdrawal</h3>
<p>Let’s design a system that processes withdrawals from an ATM, handling the available balance and the amount requested.</p>
<div class="source-code"><pre><code class="language-haskell"><span class="kw">data</span><span> </span><span class="cr">Account</span><span> </span><span class="sy">=</span><span> </span><span class="cr">Account</span><span> </span><span class="sy">{</span><span> </span><span class="va">balance</span><span> </span><span class="sy">::</span><span> </span><span class="cr">Double</span><span> </span><span class="sy">}</span><span> </span><span class="kw">deriving</span><span> </span><span class="cr">Show</span><span>

</span><span class="va">withdraw</span><span> </span><span class="sy">::</span><span> </span><span class="cr">Account</span><span> </span><span class="sy">-&gt;</span><span> </span><span class="cr">Double</span><span> </span><span class="sy">-&gt;</span><span> </span><span class="cr">Either</span><span> </span><span class="cr">String</span><span> </span><span class="cr">Account</span><span>
</span><span class="va">withdraw</span><span> </span><span class="va">acc</span><span> </span><span class="va">amount</span><span>
  </span><span class="sy">|</span><span> </span><span class="va">amount</span><span> </span><span class="op">&lt;=</span><span> </span><span class="it">0</span><span> </span><span class="sy">=</span><span> </span><span class="cr">Left</span><span> </span><span class="st">&quot;Withdrawal amount must be positive&quot;</span><span>
  </span><span class="sy">|</span><span> </span><span class="va">amount</span><span> </span><span class="op">&gt;</span><span> </span><span class="va">balance</span><span> </span><span class="va">acc</span><span> </span><span class="sy">=</span><span> </span><span class="cr">Left</span><span> </span><span class="st">&quot;Insufficient funds&quot;</span><span>
  </span><span class="sy">|</span><span> </span><span class="va">otherwise</span><span> </span><span class="sy">=</span><span> </span><span class="cr">Right</span><span> </span><span class="va">acc</span><span> </span><span class="sy">{</span><span> </span><span class="va">balance</span><span> </span><span class="sy">=</span><span> </span><span class="va">balance</span><span> </span><span class="va">acc</span><span> </span><span class="op">-</span><span> </span><span class="va">amount</span><span> </span><span class="sy">}</span><span>

</span><span class="va">main</span><span> </span><span class="sy">::</span><span> </span><span class="cr">IO</span><span> </span><span class="sy">(</span><span class="sy">)</span><span>
</span><span class="va">main</span><span> </span><span class="sy">=</span><span> </span><span class="kw">do</span><span>
  </span><span class="kw">let</span><span> </span><span class="va">myAccount</span><span> </span><span class="sy">=</span><span> </span><span class="cr">Account</span><span> </span><span class="ra">100.0</span><span>
  </span><span class="va">print</span><span> </span><span class="op">$</span><span> </span><span class="va">withdraw</span><span> </span><span class="va">myAccount</span><span> </span><span class="ra">150.0</span><span> </span><span class="co">-- Insufficient funds</span><span>
  </span><span class="va">print</span><span> </span><span class="op">$</span><span> </span><span class="va">withdraw</span><span> </span><span class="va">myAccount</span><span> </span><span class="ra">50.0</span><span>  </span><span class="co">-- Right Account {balance = 50.0}</span><span>
</span></code></pre></div>
<p><strong>This example demonstrates:</strong></p>
<ul>
<li>
<strong>Pattern Matching:</strong> We use Either to return either an error message (Left) or the updated account (Right).
</li>
<li>
<strong>Guards:</strong> We use guards to enforce conditions on the withdrawal amount and handle insufficient funds.
</li>
</ul>
<h2 id="recap-exercises">Recap &amp; Exercises</h2>
<h3 id="recap">Recap</h3>
<ul>
<li>
<strong>Pattern Matching</strong> allows us to destructure and inspect data in a clear, concise way. It’s used everywhere in Haskell, from function definitions to working with data structures.
</li>
<li>
<strong>Guards</strong> add conditions to patterns, letting us fine-tune how we match and handle different cases.
</li>
<li>
<strong>If-Else</strong> is available for simple conditions, but Haskell favors pattern matching and guards for more expressive, maintainable code.
</li>
<li>
<strong>Pattern Matching</strong> is Powerful: Haskell’s pattern matching provides guarantees of exhaustive case handling, making it critical for safety, reliability, and comprehensive testing. These features are rooted in Haskell’s strong type system and provide mathematical assurances that functions handle all possible cases correctly.
</li>
</ul>
<h3 id="exercises">Exercises</h3>
<h4 id="exercise-1-categorize-numbers-using-guards">Exercise 1: Categorize Numbers Using Guards</h4>
<p>Write a function categorize that takes an integer and categorizes it as “Negative”, “Zero”, or “Positive” using guards.</p>
<div class="source-code"><pre><code class="language-haskell"><span class="va">categorize</span><span> </span><span class="sy">::</span><span> </span><span class="cr">Int</span><span> </span><span class="sy">-&gt;</span><span> </span><span class="cr">String</span><span>
</span><span class="co">-- Your implementation here</span><span>
</span></code></pre></div>
<h4 id="exercise-2-safe-head">Exercise 2: Safe Head</h4>
<p>Write a function safeHead that takes a list and returns the first element wrapped in a Maybe. If the list is empty, it should return Nothing.</p>
<div class="source-code"><pre><code class="language-haskell"><span class="va">safeHead</span><span> </span><span class="sy">::</span><span> </span><span class="sy">[</span><span class="va">a</span><span class="sy">]</span><span> </span><span class="sy">-&gt;</span><span> </span><span class="cr">Maybe</span><span> </span><span class="va">a</span><span>
</span><span class="co">-- Your implementation here</span><span>
</span></code></pre></div>
<h4 id="exercise-3-simple-atm-withdrawal">Exercise 3: Simple ATM Withdrawal</h4>
<p>Modify the ATM withdrawal example to handle overdraft protection, where an account can go up to $100 in the negative.</p>
<div class="source-code"><pre><code class="language-haskell"><span class="va">withdrawWithOverdraft</span><span> </span><span class="sy">::</span><span> </span><span class="cr">Account</span><span> </span><span class="sy">-&gt;</span><span> </span><span class="cr">Double</span><span> </span><span class="sy">-&gt;</span><span> </span><span class="cr">Either</span><span> </span><span class="cr">String</span><span> </span><span class="cr">Account</span><span>
</span><span class="co">-- Your implementation here</span><span>
</span></code></pre></div>
<h4 id="exercise-4-fibonacci-with-pattern-matching">Exercise 4: Fibonacci with Pattern Matching</h4>
<p>Write a function fib that calculates the Fibonacci sequence using pattern matching.</p>
<div class="source-code"><pre><code class="language-haskell"><span class="va">fib</span><span> </span><span class="sy">::</span><span> </span><span class="cr">Int</span><span> </span><span class="sy">-&gt;</span><span> </span><span class="cr">Int</span><span>
</span><span class="co">-- Your implementation here</span><span>
</span></code></pre></div>
<p><a href="/landing/Blog/Chapter2">Previous Chapter</a> |
<a href="/landing/Blog/Chapter4">Next Chapter</a></p>
</div></div></body></html>